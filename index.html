<!DOCTYPE html>
<html>

  <head>
   <meta charset='utf-8'>
   <meta http-equiv="X-UA-Compatible" content="chrome=1">
   <meta name="description" content="Blogtest : PL&#39;s Blog Test">

   <link rel="stylesheet" type="text/css" media="screen" href="stylesheets/stylesheet.css">

   <title>Algorithm and Data Structure</title>
  </head>

  <body>

   <!-- HEADER -->
   <div id="header_wrap" class="outer">
      <header class="inner">
<!--
       <a id="forkme_banner" href="https://github.com/itoupeter/blogtest">View on GitHub</a>
 -->
       <h1 id="project_title">Algorithm and Data Structure</h1>
       <h2 id="project_tagline">Problem Source: <a href="https://leetcode.com/problemset/algorithms/">LeetCode</a></h2>
       <!-- <h2 id="project_tagline">Problems Solved: 155</h2> -->
       <h2 id="project_tagline">Use Ctrl+F to find solution:)</h2>
<!--
        <section id="downloads">
          <a class="zip_download_link" href="https://github.com/itoupeter/blogtest/zipball/master">Download this project as a .zip file</a>
          <a class="tar_download_link" href="https://github.com/itoupeter/blogtest/tarball/master">Download this project as a tar.gz file</a>
        </section>
 -->
      </header>
   </div>

   <!-- MAIN CONTENT -->
   <div id="main_content_wrap" class="outer">
    <section id="main_content" class="inner">

<h3><a name="390" class="anchor" href="#390"></a>#390 Elimination Game (Medium)</h3>
<p>Math<br></p>
<pre><code>class Solution {
public:
    int lastRemaining(int n) {
        return helper(n, 0);
    }
private:
	int helper(int n, int d) {
		if (n == 1) {
			return 1;
		} else if (d == 0) {
			return helper(n >> 1, 1) << 1;
		} else if (n & 1) {
			return helper(n >> 1, 0) << 1;
		} else {
			return (helper(n >> 1, 0) << 1) - 1;
		}
	}
};
</code></pre>
<p>Runtime: 29 ms</p>
<p>WARNING! Black Magic!!<br></p>
<pre><code>class Solution {
public:
    int lastRemaining(int n) {
        int tmp = 0x7FFFFFFF;
        while(tmp >= n) tmp >>= 1;
        return  ((n|0x55555555)&tmp) + 1;
    }
};
</code></pre>
<p>Runtime: 39 ms</p>


<h3><a name="344" class="anchor" href="#344"><span class="octicon octicon-link"></span></a>#344 Reverse String (Easy)</h3>
<p>Scan first half and swap characters.</p>
<pre><code>
class Solution {
public:
    string reverseString(string s) {
        int length( s.length() );

        for( int i = 0; i < length >> 1; ++i ){
            swap(s[i], s[length - i - 1]);
        }

        return s;
    }
};
</code></pre>
<p>Runtime: 12 ms</p>

<h3><a name="3" class="anchor" href="#3"><span class="octicon octicon-link"></span></a>#LintCode 3 Digit Counts (Medium)</h3>
<p>Count occurence of k on each digit.</p>
<pre><code>class Solution {
public:
    int digitCounts(int k, int n) {
		int base = 1;
		int result = (k == 0 ? 1 : 0);

		while (base <= n) {
			int cur = n % (base * 10) / base;
			int pre = n / (base * 10);
			int suf = n % base;

			if (k == cur) {
				result += max(0, pre - 1) * base;
				result += (pre == 0 ? 0 : suf + 1);
				result += (k == 0 ? 0 : (pre == 0 ? suf + 1 : base));
			} else if (k < cur) {
				result += pre * base;
				result += (k == 0 ? 0 : base);
			} else {
				result += max(0, pre - 1) * base;
				result += (pre == 0 ? 0 : base);
			}

			base *= 10;
		}

		return result;
    }
};
</code></pre>
<p>Runtime: 23 ms</p>

<h3><a name="10" class="anchor" href="#10"><span class="octicon octicon-link"></span></a>#10 Regular Expression Matching (Hard)</h3>
<p>Dynamic Programming.<br>
*Note: An '*' is handled along with its preceding character.</p>
<pre><code>
class Solution {
public:
    bool isMatch(string s, string p) {
        int lens = s.length();
        int lenp = p.length();
        vector<vector<bool>> dp(lens + 1, vector<bool>(lenp + 1, false));

        dp[0][0] = true;
        for (int i = 2; i <= lenp; i += 2) {
            if (p[i - 1] != '*') break;
            dp[0][i] = true;
        }
        for (int i = 1; i <= lens; ++i) {
            for (int j = 1; j <= lenp; ++j) {
                if (j < lenp && p[j] == '*') {
                    continue;
                } else if (p[j - 1] != '*') {
                    dp[i][j] = dp[i - 1][j - 1] && (p[j - 1] == '.' || p[j - 1] == s[i - 1]);
                } else if (p[j - 2] == '.'){
                    dp[i][j] = dp[i][j - 2] || dp[i - 1][j];
                } else {
                    dp[i][j] = dp[i][j - 2] || (dp[i - 1][j] && s[i - 1] == p[j - 2]);
                }
            }
        }

        return dp[lens][lenp];
    }
};
</code></pre>
<p>Runtime: 13 ms</p>

<h3><a name="335" class="anchor" href="#335"><span class="octicon octicon-link"></span></a>#335 Self Crossing (Hard)</h3>
<p>Interestingly, a segment will only intersects with another segment 3, 4, or 5 steps before.<br></p>
<img src="images/NO335.jpg" width="650"></img>
<pre><code>class Solution {
public:
    bool isSelfCrossing(vector<int>& v) {
        int size = v.size();

        for (int i = 3; i < size; ++i) {
            // intersects with 3 steps before
            if (i >= 3 && v[i - 1] <= v[i - 3] && v[i] >= v[i - 2]) return true;
            // intersects with 4 steps before
            if (i >= 4 && v[i - 1] == v[i - 3] && v[i] + v[i - 4] >= v[i - 2]) return true;
            // intersects with 5 steps before
            if (i >= 5 && v[i - 1] >= v[i - 3] - v[i - 5] && v[i - 1] <= v[i - 3] && v[i - 2] >= v[i - 4] && v[i] >= v[i - 2] - v[i - 4]) return true;
        }

        return false;
    }
};
</code></pre>
<p>Runtime: 0 ms</p>

<h3><a name="132" class="anchor" href="#132"><span class="octicon octicon-link"></span></a>#132 Palindrome Partitioning II (Hard)</h3>
<p>Step 1: Preprocess a bool array recording if s[i..j] is a palindrome using dynamic programming.<br>
Step 2: Find min cut using dynamic programming. DP[i] denotes min cut of prefix of lenght i, which can be obtained by DP[j] + 1 if s[j + 1, i] is a palindrome.</p>
<pre><code>class Solution {
public:
    int minCut(string s) {
        if (s.empty()) {
            return 0;
        }

        int len = s.length();
        vector<vector<bool>> b(len, vector<bool>(len + 1, false));
        vector<int> dp(len + 1, INT_MAX);

        preprocess(s, b);
        dp[0] = -1;
        for (int i = 1; i <= len; ++i) {
            for (int j = 0; j < i; ++j) {
                if (!b[j][i - j]) continue;
                dp[i] = min(dp[i], dp[j] + 1);
            }
        }

        return dp[len];
    }
private:
    void preprocess(const string &s, vector<vector<bool>> &b) {
        int len = s.length();

        for (int i = 0; i < len; ++i) {
            b[i][0] = b[i][1] = true;
        }
        for (int i = 2; i <= len; ++i) {
            for (int j = 0; j + i <= len; ++j) {
                b[j][i] = (b[j + 1][i - 2] && s[j] == s[j + i - 1]);
            }
        }
    }
};
</code></pre>
<p>Runtime: 159 ms</p>

<h3><a name="440" class="anchor" href="#440"><span class="octicon octicon-link"></span></a>#440 K-th Smallest in Lexicographical Order (Hard)</h3>
<p>Philosophy: figure out k-th smallest number from prefix.<br>
Given N, K, find count of numbers with prefix 1, let's say X, if<br>
[1] X is Greater than or equal to K, find count of numbers with prefix 10, then 11, then 12...<br>
[2] X is Less than K, find count of numbers with prefix 2, then 3, then 4...</p>
<pre><code>
class Solution {
public:
    int findKthNumber(int n, int k) {
        return helper(0, k + 1, n);
    }
private:
    int helper(int prefix, int k, int bound) {
        if (k == 1) {
            return prefix;
        }
        for (int i = 0; i < 10; ++i) {
            int newPrefix = prefix * 10 + i;
            if (newPrefix == 0) continue;
            int numPrefix = countPrefix(newPrefix, bound);

            if (numPrefix >= k - 1) {
                return helper(newPrefix, k - 1, bound);
            } else {
                k -= numPrefix;
            }
        }
        return 0;
    }
    int countPrefix(int prefix, int bound) {
        int result = 1;
        long long range = 10;
        while (prefix * range <= bound) {
            result += min(bound, prefix * range + range - 1) - prefix * range + 1;
            range *= 10LL;
        }
        return result;
    }
    inline long long min(long long a, long long b) {
        return a < b ? a : b;
    }
};
</code></pre>
<p>Runtime: 3 ms</p>

<h3><a name="316" class="anchor" href="#316"><span class="octicon octicon-link"></span></a>#316 Remove Duplicate Letters (Hard)</h3>
<p>Use a stack to build the answer. If an incoming character is less than the top element in stack and the top element is not its last appearance in the string, pop top element from stack and push the incoming character into stack.</p>
<pre><code>class Solution {
public:
    string removeDuplicateLetters(string s) {
        if (s.empty()) {
            return "";
        }

        int size = s.length();
        int count[26] = {0};
        int used[26] = {0};
        bool present[26] = {false};
        stack<char> st;

        for (char ch : s) {
            count[ch - 'a'] += 1;
        }

        for (char ch : s) {
            while(!present[ch - 'a'] && !st.empty() && ch < st.top()
                    && used[st.top() - 'a'] < count[st.top() - 'a']) {
                present[st.top() - 'a'] = false;
                st.pop();
            }
            if (!present[ch - 'a']) {
                st.push(ch);
                present[ch - 'a'] = true;
            }
            used[ch - 'a'] += 1;
        }

        string result;

        while (!st.empty()) {
            result = st.top() + result;
            st.pop();
        }

        return result;
    }
};
</code></pre>
<p>Runtime: 3 ms</p>

<h3><a name="295" class="anchor" href="#295"><span class="octicon octicon-link"></span></a>#295 Find Median from Data Stream (Hard)</h3>
<p>Use max heap to store left half, and min heap to store right half.<br>
*Max/Min heap trick: store negative of num in max heap to implement min heap.</p>
<pre><code>class MedianFinder {
public:
    MedianFinder() {
        while (!lpq.empty()) lpq.pop();
        while (!spq.empty()) spq.pop();
    }

    void addNum(int num) {
        if (lpq.size() == spq.size()) {
            spq.push(-num);
            lpq.push(-spq.top());
            spq.pop();
        } else {
            lpq.push(num);
            spq.push(-lpq.top());
            lpq.pop();
        }
    }

    double findMedian() {
        return lpq.size() == spq.size()
                ? (lpq.top() - spq.top()) * .5
                : lpq.top();
    }
private:
    priority_queue<int> lpq;
    priority_queue<int> spq;
};

</code></pre>
<p>Runtime: 172 ms</p>

<h3><a name="76" class="anchor" href="#76"><span class="octicon octicon-link"></span></a>#76 Minimum Window Substring (Hard)</h3>
<p>Two pointers i, j iterate on s.<br>
First move j forward.<br>
If s[i, j] contains t, move i forward til s[i, j] does not contain t.</p>
<pre><code>class Solution {
public:
    string minWindow(string s, string t) {
        if (s.empty() || t.empty()) {
            return "";
        }

        int sLength = s.length();
        int tLength = t.length();
        int target[256];
        int count[256];
        int given = 0;
        int current = 0;
        int rBegin = 0;
        int rEnd = INT_MAX;

        memset(target, 0, sizeof target);
        memset(count, 0, sizeof count);

        for (char ch : t) {
            target[ch] += 1;
            if (target[ch] == 1) {
                given += 1;
            }
        }

        for (int i = 0, j = 0; j < sLength; ++j) {
            count[s[j]] += 1;
            if (target[s[j]] && count[s[j]] == target[s[j]]) {
                current += 1;
            }
            if (current == given) {
                int begin = 0;
                int end = j + 1;
                while (current == given) {
                    begin = i;
                    if (target[s[i]] && target[s[i]] == count[s[i]]) {
                        --current;
                    }
                    --count[s[i++]];
                }
                if (rEnd - rBegin > end - begin) {
                    rBegin = begin;
                    rEnd = end;
                }
            }
        }

        return rEnd == INT_MAX ? "" : s.substr(rBegin, rEnd - rBegin);
    }
};
</code></pre>
<p>Runtime: 9 ms</p>

<h3><a name="32" class="anchor" href="#32"><span class="octicon octicon-link"></span></a>#32 Longest Valid Parentheses (Hard)</h3>
<p>Use stack to detect valid parentheses, dynamic programming to count longest substring length.<br>
*validSuffix[i] denotes the length of longest valid parentheses suffix of preceding i characters.</p>
<pre><code>class Solution {
public:
    int longestValidParentheses(string s) {
        if (s.empty()) {
            return 0;
        }

        int len = s.length();
        int result = 0;
        stack<int> st;
        vector<int> validSuffix(len + 1, 0);

        for (int i = 1; i <= len; ++i) {
            char ch = s[i - 1];
            if (ch == '(') {
                st.push(i - 1);
            } else if (!st.empty()){
                result = max(result, i - st.top() + validSuffix[st.top()]);
                validSuffix[i] = i - st.top() + validSuffix[st.top()];
                st.pop();
            }
        }

        return result;
    }
};
</code></pre>
<p>Runtime: 12 ms</p>

<h3><a name="222" class="anchor" href="#222"><span class="octicon octicon-link"></span></a>#222 Count Complete Tree Nodes (Medium)</h3>
<p>Binary search for the last node in the level traversal of the tree.</p>
<pre><code>
class Solution {
public:
    int countNodes(TreeNode* root) {
        if (root == NULL) {
            return 0;
        }

        int depth = findDepth(root);
        int lower = 0;
        int upper = (1 << depth >> 1) - 1;

        while (lower != upper) {
            int mid = lower + (upper - lower + 1 >> 1);
            if (checkPath(root, depth - 2, mid)) {
                lower = mid;
            } else {
                upper = mid - 1;
            }
        }

        return (1 << depth >> 1) + upper;
    }
private:
    int findDepth(TreeNode *root) {
        int result = 0;
        while (root) {
            root = root->left;
            ++result;
        }
        return result;
    }

    bool checkPath(TreeNode *root, int p, int target) {
        if (p < 0) {
            return true;
        }
        if (target & (1 << p)) {
            return root->right != NULL && checkPath(root->right, p - 1, target);
        } else {
            return root->left != NULL && checkPath(root->left, p - 1, target);
        }
    }
};
</code></pre>
<p>Runtime: 232 ms</p>

<h3><a name="179" class="anchor" href="#179"><span class="octicon octicon-link"></span></a>#179 Largest Number (Medium)</h3>
<p>Sort all numbers and concatenate them.<br>
Compare function: a comes before b if a + b > b + a, where a, b are stringified numbers.</p>
<pre><code>class Solution {
public:
    string largestNumber(vector<int>& nums) {
        vector<string> s;
        bool isAllZero = true;

        for (int i : nums) {
            stringstream ss;
            ss << i;
            s.push_back(ss.str());
            if (i) {
                isAllZero = false;
            }
        }

        sort(s.begin(), s.end(), cmp);

        if (isAllZero) {
            return "0";
        } else {
            return concatenate(s);
        }
    }
private:
    string concatenate(vector<string> &s) {
        string result = "";
        for (string &e : s) {
            result += e;
        }
        return result;
    }

    static bool cmp(const string &a, const string &b) {
        return a + b > b + a;
    }
};
</code></pre>
<p>Runtime: 6 ms</p>

<h3><a name="174" class="anchor" href="#174"><span class="octicon octicon-link"></span></a>#174 Dungeon Game (Hard)</h3>
<p>Dynamic programming from lower right to upper left.<br>
Initial health needed to reach [i, j] is dp[i, j], where<br>
dp[i, j] = max(min(dp[i + 1, j], dp[i, j + 1]) - dungeon[i, j], 1).</p>
<pre><code>
class Solution {
public:
    int calculateMinimumHP(vector<vector<int>>& dungeon) {
        if (dungeon.empty() || dungeon.front().empty()) {
            return 0;
        }

        int n = dungeon.size();
        int m = dungeon.front().size();
        vector<vector<int>> dp(n + 1, vector<int>(m + 1, INT_MAX));

        dp[n][m - 1] = 1;
        for (int i = n - 1; i >= 0; --i) {
            for (int j = m - 1; j >= 0; --j) {
                dp[i][j] = max(min(dp[i + 1][j], dp[i][j + 1]) - dungeon[i][j], 1);
            }
        }

        return max(dp[0][0], 1);
    }
};
</code></pre>
<p>Runtime: 9 ms</p>
<p>Binary search for the initial health from 1 to LARGE_NUMBER.<br>
Given a initial health, perform dynamic programming to compute the maximal health left when reaching the each grid, and decide if the last grid is reachable.</p>
<pre><code>
class Solution {
public:
    int calculateMinimumHP(vector<vector<int>>& dungeon) {
        if (dungeon.empty() || dungeon.front().empty()) {
            return 0;
        }

        n = dungeon.size();
        m = dungeon.front().size();
        f = new int * [n];
        for (int i = 0; i < n; ++i) {
            f[i] = new int [m];
        }

        // binary search health
        int lower = 1;
        int upper = 1;

        for (auto &v : dungeon) {
            for (int i : v) {
                upper += max(0, -i);
            }
        }

        while (upper != lower) {
            int mid = lower + (upper - lower >> 1);
            if (isFoundPath(dungeon, mid)) {
                upper = mid;
            } else {
                lower = mid + 1;
            }
        }

        return upper;
    }
private:
    bool isFoundPath(vector<vector<int>> &dungeon, int health) {
        for (int i = 0; i < n; ++i) {
            memset(f[i], 0, m << 2);
        }
        f[0][0] = dungeon[0][0] + health > 0 ? dungeon[0][0] + health : INT_MIN;
        for (int i = 1; i < n; ++i) {
            if (f[i - 1][0] == INT_MIN || dungeon[i][0] + f[i - 1][0] <= 0) {
                f[i][0] = INT_MIN;
            } else {
                f[i][0] = dungeon[i][0] + f[i - 1][0];
            }
        }
        for (int i = 1; i < m; ++i) {
            if (f[0][i - 1] == INT_MIN || dungeon[0][i] + f[0][i - 1] <= 0) {
                f[0][i] = INT_MIN;
            } else {
                f[0][i] = dungeon[0][i] + f[0][i - 1];
            }
        }
        for (int i = 1; i < n; ++i) {
            for (int j = 1; j < m; ++j) {
                int maxPre = max(f[i - 1][j], f[i][j - 1]);
                if (maxPre == INT_MIN || dungeon[i][j] + maxPre <= 0) {
                    f[i][j] = INT_MIN;
                } else {
                    f[i][j] = dungeon[i][j] + maxPre;
                }
            }
        }

        return f[n - 1][m - 1] > 0;
    }

    int n;
    int m;
    int **f;
};
</code></pre>
<p>Runtime: 19 ms</p>

<h3><a name="214" class="anchor" href="#214"><span class="octicon octicon-link"></span></a>#214 Shortest Palindrome (Hard)</h3>
<p>Given s, first find the longest palindrome prefix of s, then append the rest part reversed to the beginning.<br>
Construct t =  s + '#' + reverse(s).<br>
Use KMP algorithm to compute the next array of t, which also means the longest common prefix-suffix.<br>
By the construction, it is also the longest palindrome prefix of s.</p>
<pre><code>
class Solution {
public:
    string shortestPalindrome(string s) {
        if (s.length() < 2) {
            return s;
        }

        string t(s.rbegin(), s.rend());
        t = s + "#" + t;

        int lenS = s.length();
        int lenT = t.length();
        vector<int> next(lenT + 1, 0);

        next[0] = -1;
        for (int i = 1; i <= lenT; ++i) {
            int preNext = next[i - 1];
            while (preNext != -1 && t[preNext] != t[i - 1]) {
                preNext = next[preNext];
            }
            next[i] = preNext + 1;
        }

        t = s.substr(next.back());
        reverse(t.begin(), t.end());

        return t + s;
    }
};
</code></pre>
<p>Runtime: 6 ms</p>

<h3><a name="30" class="anchor" href="#30"><span class="octicon octicon-link"></span></a>#30 Substring with Concatenation (Hard)</h3>
<p>Two pointers. Start scanning from [0, wordLength - 1] to account for all substrings in s.</p>
<pre><code>class Solution {
public:
    vector<int> findSubstring(string s, vector<string>& words) {
        vector<int> result;
        unordered_map<string, int> dict;
        int wordLength = words.front().length();
        int sLength = s.length();

        for (const string &word : words) {
            ++dict[word];
        }

        for (int i = 0; i < wordLength; ++i) {
            unordered_map<string, int> count;
            int target = 0;
            for (int j = i, k = i; k + wordLength <= sLength; ) {
                string sub = s.substr(k, wordLength);

                k += wordLength;

                if (dict.find(sub) == dict.end()) {
                    j = k;
                    target = 0;
                    count.clear();
                    continue;
                }

                ++count[sub];
                if (count[sub] == dict[sub]) {
                    ++target;
                } else if (count[sub] > dict[sub]) {
                    while (count[sub] > dict[sub]) {
                        string sub2 = s.substr(j, wordLength);
                        if (count[sub2] == dict[sub2]) {
                            --target;
                        }
                        --count[sub2];
                        j += wordLength;
                    }
                }
                if (target == dict.size()) {
                    // got a solution
                    result.push_back(j);
                }
            }
        }

        return result;
    }
};
</code></pre>
<p>Runtime: 53 ms</p>

<h3><a name="212" class="anchor" href="#212"><span class="octicon octicon-link"></span></a>#212 Word Search II (Hard)</h3>
<p>Build a trie of all words, search the board for words in the trie.<br>
Optimization: when a word is found, remove it from the trie.</p>
<pre><code>
struct Node {
    Node() {
        next = vector<int>(26, -1);
        isWord = false;
    }

    vector<int> next;
    bool isWord;
};

class Solution {
public:
    vector<string> findWords(vector<vector<char>>& board, vector<string>& words) {
        if (board.empty() || board.front().empty() || words.empty()) {
            return vector<string>();
        }

        n = board.size();
        m = board.front().size();

        trie.clear();
        trie.push_back(Node());
        for (const string &word : words) {
            trieAdd(0, word, 0);
        }

        result.clear();
        for (int i = 0; i < n; ++i) {
            for (int j = 0; j < m; ++j) {
                if (trie.front().next[board[i][j] - 'a'] != -1) {
                    isVisited.clear();
                    isVisited.insert(i << 16 | j);
                    searchWord(trie.front().next[board[i][j] - 'a'], string(1, board[i][j]), board, i, j);
                }
            }
        }

        return vector<string>(result.begin(), result.end());
    }
private:
    void trieAdd(int id, const string &word, int a) {
        if (a >= word.length()) {
            trie[id].isWord = true;
            return;
        }

        int nid = trie[id].next[word[a] - 'a'];

        if (nid == -1) {
            trie.push_back(Node());
            nid = trie.size() - 1;
            trie[id].next[word[a] - 'a'] = nid;
        }

        trieAdd(nid, word, a + 1);
    }

    void trieRemove(int id, const string &word, int a, int &numNext) {
        int numNextChild = 0;
        if (a < word.length()) {
            trieRemove(trie[id].next[word[a] - 'a'], word, a + 1, numNextChild);
        } else {
            trie[id].isWord = false;
        }

        if (a < word.length() && numNextChild == 0) {
            trie[id].next[word[a] - 'a'] = -1;
        }
        for (int i : trie[id].next) {
            numNext += (i == -1 ? 0 : 1);
        }
    }

    void searchWord(int id, string s, const vector<vector<char>> &board, int x, int y) {
        if (trie[id].isWord) {
            result.insert(s);
            int tmp; trieRemove(0, s, 0, tmp);
        }

        for (int i = 0; i < 4; ++i) {
            int nx = x + dx[i];
            int ny = y + dy[i];

            if (nx < 0 || nx >= n || ny < 0 || ny >= m
                    || isVisited.find(nx << 16 | ny) != isVisited.end()
                    || trie[id].next[board[nx][ny] - 'a'] == -1) {
                continue;
            }

            s += board[nx][ny];
            isVisited.insert(nx << 16 | ny);
            searchWord(trie[id].next[board[nx][ny] - 'a'], s, board, nx, ny);
            isVisited.erase(nx << 16 | ny);
            s.pop_back();
        }
    }

    const int dx[4] = {0, 1, 0, -1};
    const int dy[4] = {1, 0, -1, 0};

    int n;
    int m;
    vector<Node> trie;
    unordered_set<int> isVisited;
    unordered_set<string> result;
};
</code></pre>
<p>Runtime: 199 ms</p>

<h3><a name="140" class="anchor" href="#140"><span class="octicon octicon-link"></span></a>#140 Word Break II (Hard)</h3>
<p>Use dynamic programming to find if prefixs of s are breakable, then recursively find all breaks.</p>
<pre><code>
class Solution {
public:
    vector<string> wordBreak(string s, unordered_set<string>& wordDict) {
        if (s.empty() || wordDict.empty()) {
            return vector<string>();
        }

        int length = s.length();
        vector<bool> f(length + 1, false);

        maxLen = 0;
        for (const string &s : wordDict) {
            maxLen = max(maxLen, (int)s.length());
        }

        f[0] = true;
        for (int i = 1; i <= length; ++i) {
            for (int j = i - 1; j >= 0 && i - j <= maxLen; --j) {
                if (f[j] && wordDict.find(s.substr(j, i - j)) != wordDict.end()) {
                    f[i] = true;
                    break;
                }
            }
        }

        result.clear();

        if (f[length]) {
            helper(f, s, length - 1, "", wordDict);
        }

        return result;
    }
private:
    void helper(const vector<bool> &f, const string &s, int b, string cur,
            const unordered_set<string> &dict){
        if (b < 0) {
            result.push_back(cur.substr(1));
            return;
        }

        for (int a = b; a >= 0 && b - a < maxLen; --a) {
            if (!f[a]) {
                continue;
            }
            string sub = s.substr(a, b - a + 1);
            if (dict.find(sub) != dict.end()) {
                helper(f, s, a - 1, " " + sub + cur, dict);
            }
        }
    }

    int maxLen;
    vector<string> result;
};
</code></pre>
<p>Runtime: 3 ms</p>

<h3><a name="273" class="anchor" href="#273"><span class="octicon octicon-link"></span></a>#273 Integer to English Words (Hard)</h3>
<p>Split into chunks of 3 digits and map to words.</p>
<pre><code>class Solution {
public:
    string numberToWords(int num) {
        if (num == 0) {
            return "Zero";
        }

        const vector<string> units = {"", "Thousand", "Million", "Billion"};
        const vector<string> ones = {"", "One", "Two", "Three", "Four", "Five",
                "Six", "Seven", "Eight", "Nine", "Ten", "Eleven", "Twelve",
                "Thirteen", "Fourteen", "Fifteen", "Sixteen", "Seventeen",
                "Eighteen", "Nineteen"};
        const vector<string> tens = {"", "", "Twenty", "Thirty", "Forty", "Fifty",
                "Sixty", "Seventy", "Eighty", "Ninety", "Hundred"};
        vector<int> parts;
        string result;

        while(num) {
            parts.push_back(num % 1000);
            num /= 1000;
        }

        for (int i = parts.size() - 1; i >= 0; --i) {
            int part = parts[i];
            if (part > 99 ) {
                result += ones[part / 100] + " " + tens[10] + " ";
            }
            if (part % 100 >= 20) {
                result += tens[part % 100 / 10] + " ";
                if (part % 10) {
                    result += ones[part % 10] + " ";
                }
            } else if (part % 100) {
                result += ones[part % 100] + " ";
            }
            if (part) {
                result += units[i] + " ";
            }
        }

        while (result.back() == ' ') {
            result.pop_back();
        }

        return result;
    }
};
</code></pre>
<p>Runtime: 3 ms</p>

<h3><a name="4" class="anchor" href="#4"><span class="octicon octicon-link"></span></a>#4 Median of Two Sorted Arrays (Hard)</h3>
<p>Generalize to find Kth element.<br>
Compare arr1[k/2] and arr2[k/2], if:<br>
[1] Less: discard arr1[0]...arr1[k/2], find (K - K/2)th element,<br>
[2] Greater: discard arr2[0]...arr2[k/2], find(K - K/2)th element.</p>
<pre><code>
class Solution {
public:
    double findMedianSortedArrays(vector<int>& nums1, vector<int>& nums2) {
        if (nums1.empty() && nums2.empty()) {
            return 0.;
        }

        int size1 = nums1.size();
        int size2 = nums2.size();

        if (size1 + size2 & 1) {
            // odd number of elements
            return 0. + findKthElement(size1 + size2 + 1 >> 1,
                    nums1, 0, size1, nums2, 0, size2);
        } else {
            // even number of elements
            return (findKthElement(size1 + size2 >> 1,
                    nums1, 0, size1, nums2, 0, size2)
                    + findKthElement(size1 + size2 + 2 >> 1,
                    nums1, 0, size1, nums2, 0, size2)) * .5;
        }
    }
private:
    int findKthElement(int k, const vector<int> &nums1, int b1, int e1,
            const vector<int> &nums2, int b2, int e2) {
        if (e1 == b1) {
            return nums2[b2 + k - 1];
        } else if (e2 == b2) {
            return nums1[b1 + k - 1];
        } else if (k == 1) {
            return nums1[b1] < nums2[b2] ? nums1[b1] : nums2[b2];
        }

        int kk = k >> 1;
        int p1 = (b1 + kk - 1 < e1 ? b1 + kk - 1 : e1 - 1);
        int p2 = (b2 + kk - 1 < e2 ? b2 + kk - 1 : e2 - 1);

        if (nums1[p1] < nums2[p2]) {
            return findKthElement(k - (p1 - b1 + 1), nums1, p1 + 1, e1,
                    nums2, b2, e2);
        } else {
            return findKthElement(k - (p2 - b2 + 1), nums1, b1, e1,
                    nums2, p2 + 1, e2);
        }
    }
};
</code></pre>
<p>Runtime: 35 ms</p>

<h3><a name="391" class="anchor" href="#391"><span class="octicon octicon-link"></span></a>#391 Perfect Rectangle (Hard)</h3>
<p>Sweep line.<br>
Create a list of all vertical borders and sort them according to x coordinate.<br>
Iterate on the list, if the vertical border is a:<br>
[1] Left border: try to insert its [bottom, top] interval to set {active}. Before inserting, check if it conflicts with other intervals in the set.<br>
[2] Right border: remove its [bottom, top] interval from set{active}.<br>
If no conflict exists, check whether the area of all rectangles sum to area of their bounding box.</p>
<pre><code>
struct Node {
    Node(int id, int x, int b, int t, int type) {
        this->id = id;
        this->x = x;
        this->b = b;
        this->t = t;
        this->type = type;
    }

    int id;
    int x, b, t;
    int type;
};

bool cmp(const Node &a, const Node &b) {
    return a.x == b.x ? a.type > b.type : a.x < b.x;
}

class Solution {
public:
    bool isRectangleCover(vector<vector<int>>& rectangles) {
        if (rectangles.empty()) {
            return true;
        }

        int size = rectangles.size();
        int area = 0;
        int xMax = INT_MIN;
        int xMin = INT_MAX;
        int yMax = INT_MIN;
        int yMin = INT_MAX;
        vector<Node> nodes;
        map<int, int> active;

        nodes.reserve(size << 1);

        for (auto &v : rectangles) {
            xMax = max(xMax, v[2]);
            xMin = min(xMin, v[0]);
            yMax = max(yMax, v[3]);
            yMin = min(yMin, v[1]);
            area += (v[2] - v[0]) * (v[3] - v[1]);
            nodes.push_back(Node(nodes.size() >> 1, v[0], v[1], v[3], 0));
            nodes.push_back(Node(nodes.size() >> 1, v[2], v[1], v[3], 1));
        }

        sort(nodes.begin(), nodes.end(), cmp);

        for (Node &node : nodes) {
            if (node.type == 1) {
                // right border of a rectangle
                active.erase(node.b);
                continue;
            }

            auto ite = active.find(node.b);
            // left border of a rectangles
            if (ite != active.end()) {
                return false;
            }
            if ((ite = active.lower_bound(node.b)) != active.begin()
                    && (--ite)->second > node.b) {
                return false;
            }
            if ((ite = active.upper_bound(node.b)) != active.end()
                    && ite->first < node.t) {
                return false;
            }
            active.insert(make_pair(node.b, node.t));
        }

        return area == (xMax - xMin) * (yMax - yMin);
    }
};
</code></pre>
<p>Runtime: 242 ms</p>

<h3><a name="44" class="anchor" href="#44"><span class="octicon octicon-link"></span></a>#44 Wildcard Matching (Hard)</h3>
<p>Dynamic Programming.</p>
<pre><code>class Solution {
public:
    bool isMatch(string s, string p) {
        if (s.empty() && p.empty()) {
            return true;
        } else if (s.empty()) {
            bool isAllAsterisk = true;

            for (char ch : p) {
                if (ch != '*') {
                    isAllAsterisk = false;
                    break;
                }
            }

            return isAllAsterisk;
        } else if (p.empty()) {
            return false;
        }

        int lengthS = s.length();
        int lengthP = p.length();
        int input = 0;
        int *f[2] = {new int [lengthP + 1], new int [lengthP + 1]};
        bool *star = new bool [lengthP + 1];

        memset(f[0], 0, sizeof(int) * (lengthP + 1));
        memset(f[1], 0, sizeof(int) * (lengthP + 1));
        memset(star, 0, sizeof(bool) * (lengthP + 1));

        f[input][0] = star[0] = true;
        for (int i = 1; i <= lengthP; ++i) {
            if (p[i - 1] != '*') {
                break;
            }
            f[input][i] = star[i] = true;
        }
        for (int i = 1; i <= lengthS; ++i) {
            f[input ^ 1][0] = false;
            for (int j = 1; j <= lengthP; ++j) {
                f[input ^ 1][j] = false;
                if (p[j - 1] == '*') {
                    f[input ^ 1][j] = star[j - 1];
                } else {
                    f[input ^ 1][j] = f[input][j - 1] && (p[j - 1] == '?' || s[i - 1] == p[j - 1]);
                }
                star[j] = star[j] || f[input ^ 1][j];
            }
            input ^= 1;
        }

        return f[input][lengthP];
    }
};
</code></pre>
<p>Runtime: 262 ms</p>

<h3><a name="68" class="anchor" href="#68"><span class="octicon octicon-link"></span></a>#68 Text Justification (Hard)</h3>
<p>String manipulation.</p>
<pre><code>class Solution {
public:
    vector<string> fullJustify(vector<string>& words, int maxWidth) {
        if (words.empty()) {
            return vector<string>{""};
        }

        int numWords = words.size();
        vector<string> result;

        for (int i = 0, j = 0; i < numWords; i = j) {
            int numCharacters = 0;

            numCharacters += words[j++].length();
            for (; j < numWords; ++j) {
                if (numCharacters + 1 + words[j].length() <= maxWidth) {
                    numCharacters += 1 + words[j].length();
                } else {
                    break;
                }
            }

            string line;

            if (j == numWords) {
                // last line
                for (int k = 0; k < j - i; ++k) {
                    if (k != 0) {
                        line += " ";
                    }
                    line += words[i + k];
                }
                line += string(maxWidth - line.length(), ' ');
            } else if (j - i == 1) {
                // not last line but only one word
                line += words[i];
                line += string(maxWidth - line.length(), ' ');
            } else {
                numCharacters -= j - i - 1;

                int space = (maxWidth - numCharacters) / (j - i - 1);
                int more = (maxWidth - numCharacters) % (j - i - 1);

                for (int k = i; k < j; ++k) {
                    if (k != i) {
                        line += string(space, ' ');
                        if (more-- > 0) {
                            line += " ";
                        }
                    }
                    line += words[k];
                }
            }

            result.push_back(line);
        }

        return result;
    }
};
</code></pre>
<p>Runtime: 0 ms</p>

<h3><a name="146" class="anchor" href="#146"><span class="octicon octicon-link"></span></a>#146 LRU Cache (Hard)</h3>
<p>Use doubly linked list to store list of cache, and a hashmap to store the (key, pointer pointing to the cache list node) pair.</p>
<pre><code>
typedef pair<int, int> PII;
class LRUCache{
public:
    LRUCache(int capacity) {
        this->capacity = capacity;
        while (!cache.empty()) {
            cache.pop_back();
        }
        umap.clear();
    }

    int get(int key) {
        if (umap.find(key) == umap.end()) {
            return -1;
        } else {
            auto ite = umap[key];

            cache.push_front(PII(key, ite->second));
            cache.erase(ite);
            umap[key] = cache.begin();
            return cache.front().second;
        }
    }

    void set(int key, int value) {
        if (umap.find(key) == umap.end()) {
            if (cache.size() >= capacity) {
                auto lru = cache.end(); --lru;
                umap.erase(lru->first);
                cache.erase(lru);
            }
        } else {
            cache.erase(umap[key]);
        }
        cache.push_front(PII(key, value));
        umap[key] = cache.begin();
    }
private:
    int capacity;
    list<PII> cache;
    unordered_map<int, list<PII>::iterator> umap;
};
</code></pre>
<p>Runtime: 76 ms</p>

<h3><a name="149" class="anchor" href="#149"><span class="octicon octicon-link"></span></a>#149 Max Points on a Line (Hard)</h3>
<p>Use a hashmap to record number of colinear points. For each point, calculate the slope of the line formed of that point with other points and insert into hashmap, whose key is slope and value is number of points. Note coincident points.</p>
<pre><code>class Solution {
public:
    int maxPoints(vector<Point>& points) {
        if (points.size() < 3) {
            return points.size();
        }

        unordered_map<double, int> umap;
        int size = points.size();
        int result = 0;

        for (int i = 0; i < size; ++i) {
            int numSamePoints = 0;

            umap.clear();
            for (int j = 0; j < size; ++j) {
                const Point &p1 = points[i];
                const Point &p2 = points[j];

                if (i == j) {
                    continue;
                } else if (p1.x == p2.x && p1.y == p2.y) {
                    ++numSamePoints;
                    continue;
                } else {
                    double slope = 0.;
                    // compute slope
                    if (p1.x == p2.x) {
                        slope = INT_MAX + 0.;
                    } else {
                        slope = (p2.y - p1.y + 0.) / (p2.x - p1.x + 0.);
                    }
                    // insert to hash map
                    if (umap.find(slope) == umap.end()) {
                        umap[slope] = 1;
                    } else {
                        umap[slope] += 1;
                    }
                }
            }

            result = max(result, 1 + numSamePoints);
            for (auto &e : umap) {
                result = max(result, 1 + e.second + numSamePoints);
            }
        }

        return result;
    }
};
</code></pre>
<p>Runtime: 46 ms</p>

<h3><a name="421" class="anchor" href="#421"><span class="octicon octicon-link"></span></a>#421 Maximum XOR of Two Numbers in an Array (Medium)</h3>
<p>Find max answer from MSB to LSB: say nums = [3, 1, 8, 10] = [0011, 0001, 1000, 1010]<br>
Assume max = 1000, for each num, insert its first bit into set, resulting in [0000, 1000]. For each num a in set, find whether max^a exists. If yes, assume max = 1100, else assume max = 0100, and test next bit. In this case, max = 1000.<br>
Assume max = 1100, take first 2 bits, resulting set = [0000, 1000], 0000^1100 not in set, 1000^1100 not in set, thus second MSB in answer is not set.<br>
Assume max = 1010, take first 3 bits, resulting set = [0010, 0000, 1000, 1010], 0010^1010 in set, third bit in answer is set.<br>
Assume max = 1011, take first 4 bits, resulting set = [0011, 0001, 1000, 1010], 0011^1011 in set, fourth bit in answer is set.<br>
Thus max = 1011 = 11.</p>
<pre><code>
class Solution {
public:
    int findMaximumXOR(vector<int>& nums) {
        if (nums.empty()) {
            return 0;
        }

        int mask = 0;
        int result = 0;
        unordered_set<int> uset;

        for (int i = 30; i >= 0; --i) {
            uset.clear();
            mask |= (1 << i);

            for (int i : nums) {
                uset.insert(i & mask);
            }

            int test = result | (1 << i);

            for (int i : uset) {
                if (uset.find(test ^ i) != uset.end()) {
                    result = test;
                    break;
                }
            }
        }

        return result;
    }
};
</code></pre>
<p>Runtime: 985 ms</p>

<h3><a name="126" class="anchor" href="#126"><span class="octicon octicon-link"></span></a>#126 Word Ladder II (Hard)</h3>
<p>Build graph using BFS starting from endWord, for each node record its distance to endWord, then find all solutions using DFS from beginWord to endWord with decreasing distance.</p>
<pre><code>
struct Node {
    Node(string word, int dist) {
        this->word = word;
        this->dist = dist;
    }

    int dist;
    string word;
    vector<int> next;
};

class Solution {
public:
    vector<vector<string>> findLadders(string beginWord, string endWord, unordered_set<string> &wordList) {
        if (beginWord.length() != endWord.length()) {
            return vector<vector<string>>();
        }

        current.clear();
        result.clear();
        graph.clear();
        id.clear();
        for(; !q.empty(); q.pop());

        wordList.insert(beginWord);
        wordList.insert(endWord);
        buildGraph(endWord, wordList);

        if (id.find(beginWord) == id.end()) {
            return result;
        }

        findPath(beginWord, endWord);

        return result;
    }

    void buildGraph(string endWord, unordered_set<string> &dict) {
        q.push(make_pair(endWord, 0));
        id[endWord] = graph.size();
        graph.push_back(Node(endWord, 0));

        while (!q.empty()) {
            string word = q.front().first;
            int dist = q.front().second;
            int len = word.length();

            for (int i = 0; i < len; ++i) {
                // change one (ith) character
                for (char ch = 'a'; ch <= 'z'; ++ch) {
                    string newWord = word;

                    newWord[i] = ch;
                    if (dict.find(newWord) == dict.end()) {
                        // not in dict
                        continue;
                    }
                    if (id.find(newWord) == id.end()) {
                        // new word
                        id[newWord] = graph.size();
                        graph.push_back(Node(newWord, dist + 1));
                        q.push(make_pair(newWord, dist + 1));
                    }
                    if (newWord != word) {
                        graph[id[word]].next.push_back(id[newWord]);
                    }
                }
            }

            q.pop();
        }
    }

    void findPath(string beginWord, string endWord) {
        current.push_back(beginWord);
        helper(id[beginWord], graph[id[beginWord]].dist);
    }

    void helper(int id, int dist) {
        if (dist == 0) {
           result.push_back(current);
           return;
        }

        for (int i : graph[id].next) {
            if (graph[i].dist >= dist) {
                continue;
            }
            current.push_back(graph[i].word);
            helper(i, dist - 1);
            current.pop_back();
        }
    }

private:
    vector<Node> graph;
    unordered_map<string, int> id;
    queue<pair<string, int>> q;
    vector<vector<string>> result;
    vector<string> current;
};
</code></pre>
<p>Runtime: 565 ms</p>

<h3><a name="65" class="anchor" href="#65"><span class="octicon octicon-link"></span></a>#65 Valid Number (Hard)</h3>
<p>Complex state machine.</p>
<img src="images/NO65.jpg" width="650"></img>
<pre><code>
class Solution {
public:
    bool isNumber(string s) {

        if (s.empty()) {
            return false;
        }

        int length = (s += "#END#").length();
        int ptr = 0;
        enum state {
            START, DECIMAL_SIGN, INTEGER_DIGIT, DECIMAL_POINT, FRACTIONAL_DIGIT,
            E, EXPONENT_SIGN, EXPONENT_DIGIT, SPACE, TERMINATION, INVALID
        } stateId;
        bool isDecimalPointOnlyError = false;

        while (ptr < length && s[ptr] == ' ') {
            ++ptr;
        }

        stateId = START;
        while (ptr < length) {
            char nxt = s[ptr];

            if (stateId == START) {
                if (nxt == '+' || nxt == '-') {
                    stateId = DECIMAL_SIGN;
                } else if (nxt >= '0' && nxt <= '9') {
                    stateId = INTEGER_DIGIT;
                } else if (nxt == '.') {
                    isDecimalPointOnlyError = true;
                    stateId = DECIMAL_POINT;
                } else {
                    break;
                }

            } else if (stateId == DECIMAL_SIGN) {
                if (nxt >= '0' && nxt <= '9') {
                    stateId = INTEGER_DIGIT;
                }else if (nxt == '.') {
                    isDecimalPointOnlyError = true;
                    stateId = DECIMAL_POINT;
                } else {
                    break;
                }

            } else if (stateId == INTEGER_DIGIT) {
                if (nxt == ' ') {
                    stateId = SPACE;
                } else if (nxt >= '0' && nxt <= '9') {
                    // state unchanged
                } else if (nxt == '.') {
                    stateId = DECIMAL_POINT;
                } else if (nxt == 'e' || nxt == 'E') {
                    stateId = E;
                } else if (nxt == '#' && s.substr(ptr, 5) == "#END#") {
                    stateId = TERMINATION;
                    break;
                } else {
                    break;
                }

            } else if (stateId == DECIMAL_POINT) {
                if (nxt == ' ') {
                    stateId = SPACE;
                } else if (nxt >= '0' && nxt <= '9') {
                    isDecimalPointOnlyError = false;
                    stateId = FRACTIONAL_DIGIT;
                } else if (nxt == 'e' || nxt == 'E') {
                    stateId = E;
                } else if (nxt == '#' && s.substr(ptr, 5) == "#END#") {
                    stateId = TERMINATION;
                    break;
                } else {
                    break;
                }

                if (isDecimalPointOnlyError) {
                    break;
                }

            } else if (stateId == FRACTIONAL_DIGIT) {
                if (nxt == 'e' || nxt == 'E') {
                    stateId = E;
                } else if (nxt >= '0' && nxt <= '9') {
                    // state unchanged
                } else if (nxt == ' ') {
                    stateId = SPACE;
                } else if (nxt == '#' && s.substr(ptr, 5) == "#END#") {
                    stateId = TERMINATION;
                    break;
                } else {
                    break;
                }

            } else if (stateId == E) {
                if (nxt == '+' || nxt == '-') {
                    stateId = EXPONENT_SIGN;
                } else if (nxt >= '0' && nxt <= '9') {
                    stateId = EXPONENT_DIGIT;
                } else {
                    break;
                }

            } else if (stateId == EXPONENT_SIGN) {
                if (nxt >= '0' && nxt <= '9') {
                    stateId = EXPONENT_DIGIT;
                } else if (nxt == ' ') {
                    stateId = SPACE;
                } else {
                    break;
                }

            } else if (stateId == EXPONENT_DIGIT) {
                if (nxt >= '0' && nxt <= '9') {
                    // state unchanged
                } else if (nxt == ' ') {
                    stateId = SPACE;
                } else if (nxt == '#' && s.substr(ptr, 5) == "#END#") {
                    stateId = TERMINATION;
                    break;
                } else {
                    break;
                }

            } else if (stateId == SPACE) {
                if (nxt == ' ') {
                    // state unchanged
                } else if (nxt == '#' && s.substr(ptr, 5) == "#END#") {
                    stateId = TERMINATION;
                    break;
                } else {
                    break;
                }
            }

            ++ptr;
        }

        return stateId == TERMINATION && !isDecimalPointOnlyError;
    }
};
</code></pre>
<p>Runtime: 6 ms</p>

<h3><a name="413" class="anchor" href="#413"><span class="octicon octicon-link"></span></a>#413 Arithmetic Slices (Medium)</h3>
<p>Find arithmetic subsequence, count number of arithmetic slices.<br>
An arithmetic subsequence of size N has 1+2+...+(n-2) slices.</p>
<pre><code>class Solution {
public:
    int numberOfArithmeticSlices(vector<int>& A) {
        if (A.size() < 3) {
            return 0;
        }

		int size = A.size();
		int result = 0;
		int diff = A[0] - A[1];
		int slot = 0;

		for (int i = 1; i < size - 1; ++i) {
			if (A[i] - A[i + 1] == diff) {
				slot += 1;
				result += slot;
			} else {
				slot = 0;
				diff = A[i] - A[i + 1];
			}
		}

		return result;
    }
};
</code></pre>
<p>Runtime: 3 ms</p>

<h3><a name="343" class="anchor" href="#343"><span class="octicon octicon-link"></span></a>#343 Integer Break (Medium)</h3>
<p>Dynamic Programming.</p>
<pre><code>
class Solution {
public:
    int integerBreak(int n) {
        vector<int> f(n + 1, 0);

        f[1] = 1;
        for (int i = 2; i <= n; ++i) {
            for (int j = 1; j <= (i >> 1); ++j) {
                f[i] = max(f[i], j * (i - j));
                f[i] = max(f[i], f[j] * (i - j));
                f[i] = max(f[i], j * f[i - j]);
                f[i] = max(f[i], f[j] * f[i - j]);
            }
        }

        return f[n];
    }
};
</code></pre>
<p>Runtime: 3 ms</p>

<h3><a name="357" class="anchor" href="#357"><span class="octicon octicon-link"></span></a>#357 Count Numbers with Unique Digits (Medium)</h3>
<p>Number of unique numbers using i digits can be computed based on number of unique numbers using i-1 digits.</p>
<pre><code>
class Solution {
public:
    int countNumbersWithUniqueDigits(int n) {
        if (n == 0) {
            return 1;
        } else if (n == 1) {
            return 10;
        } else if (n > 10) {
            n = 10;
        }

        vector<int> vi(11);

        vi[1] = 9;
        for (int i = 2; i <= n; ++i) {
            vi[i] = vi[i - 1] * (11 - i);
        }

        vi[1] = 10;
        for (int i = 2; i <= n; ++i) {
            vi[i] += vi[i - 1];
        }

        return vi[n];
    }
};
</code></pre>
<p>Runtime: 0 ms</p>

<h3><a name="392" class="anchor" href="#392"><span class="octicon octicon-link"></span></a>#392 Is Subsequence (Medium)</h3>
<p>Pointer i, j scan s, t respectively. If s[i] == t[j], move i, j forwards, else move j forwards only.</p>
<pre><code>
class Solution {
public:
    bool isSubsequence(string s, string t) {
        if (s.empty()) {
            return true;
        } else if (t.empty() || s.length() > t.length()) {
            return false;
        }

        int lenS = s.length();
        int lenT = t.length();
        int i = 0;

        for (int j = 0; i < lenS && j < lenT; ++i, ++j) {
            while (j < lenT && s[i] != t[j]) {
                ++j;
            }
        }

        return i == lenS;
    }
};
</code></pre>
<p>Runtime: 72 ms</p>

<h3><a name="339" class="anchor" href="#339"><span class="octicon octicon-link"></span></a>#339 Shuffle an Array (Medium)</h3>
<p>Let all numbers be in the pool, each time randomly pick a number from the pool and append it to the result list.</p>
<pre><code>
class Solution {
public:
    Solution(vector<int> nums) {
        this->nums = nums;
        this->numsShuffled = nums;
    }

    /** Resets the array to its original configuration and return it. */
    vector<int> reset() {
        return nums;
    }

    /** Returns a random shuffling of the array. */
    vector<int> shuffle() {
        int n = nums.size();

        for (int i = 0; i < n - 1; ++i) {
            int j = rand() % (n - i);
            swap(numsShuffled[i], numsShuffled[j + i]);
        }

        return numsShuffled;
    }

private:
    vector<int> nums;
    vector<int> numsShuffled;
};
</code></pre>
<p>Runtime: 339 ms</p>

<h3><a name="167" class="anchor" href="#167"><span class="octicon octicon-link"></span></a>#167 Two Sum II - Input array is sorted (Medium)</h3>
<p>Pointer i, j scan from head to tail, tail to head respectively. If two sum is greater that target, move j backwards; else move i forwards.</p>
<pre><code>
class Solution {
public:
    vector<int> twoSum(vector<int>& numbers, int target) {
        int n = numbers.size();

        if (n < 2) {
            return vector<int>{-1, -1};
        }

        int i = 0;
        int j = n - 1;

        while (i < j && numbers[i] + numbers[j] != target) {
            if (numbers[i] + numbers[j] < target) {
                ++i;
            } else {
                --j;
            }
        }

        return i < j ? vector<int>{i + 1, j + 1} : vector<int>{-1, -1};
    }
};
</code></pre>
<p>Runtime: 6 ms</p>

<h3><a name="406" class="anchor" href="#406"><span class="octicon octicon-link"></span></a>#406 Queue Reconstruction by Height (Medium)</h3>
<p>Sort by h (taller first) and k (smaller first), then for each person, shift him ahead until satisfying requirement on k.</p>
<pre><code>class Solution {
public:
    vector<pair<int, int>> reconstructQueue(vector<pair<int, int>>& people) {

        int n = people.size();

        if (n == 0) {
            return vector<pair<int, int>>();
        }

        sort(people.begin(), people.end(), comparePeople);

        for (int i = 1; i < n; ++i) {
            for (int j = i; people[j].second < j; --j) {
                swap(people[j], people[j - 1]);
            }
        }

        return people;
    }

private:
    static bool comparePeople(const pair<int, int> &a, const pair<int, int> &b) {
        return (a.first == b.first) ? (a.second < b.second) : (a.first > b.first);
    }
};
</code></pre>
<p>Runtime: 139 ms</p>

<h3><a name="338" class="anchor" href="#338"><span class="octicon octicon-link"></span></a>#338 Counting Bits (Medium)</h3>
<p>Number of 1 in i is: <br>1) number of 1 in i/2 if i is even, <br>2) number of 1 in i/2 plus 1 if i is odd. </p>
<pre><code>
class Solution {
public:
    vector<int> countBits(int num) {

        vector<int> result(num + 1);

        result[0] = 0;
        for (int i = 1; i <= num; ++i) {
            result[i] = (i & 1) ? result[i >> 1] + 1: result[i >> 1];
        }

        return result;
    }
};
</code></pre>
<p>Runtime: 103 ms</p>

<h3><a name="292" class="anchor" href="#292"><span class="octicon octicon-link"></span></a>#292 Nim Game (Easy)</h3>
<p>Determine if n can be exactly divided by 4. If yes, you lose, else you win.</p>
<pre><code>class Solution {
public:
   bool canWinNim(int n) {
      return n & 3;
   }
};
</code></pre>
<p>Runtime: 0 ms</p>

<h3><a name="389" class="anchor" href="#389"><span class="octicon octicon-link"></span></a>#389 Find the Difference (Easy)</h3>
<p>Simply count letters in s and t.</p>
<pre><code>class Solution {
public:
    char findTheDifference(string s, string t) {

        int count[256];

        memset(count, 0, sizeof count);

        for (auto &ch : s) {
            ++count[(int)ch];
        }

        for (auto &ch : t) {
            if (--count[(int)ch] == -1) {
                return ch;
            }
        }

        return 'A';
    }
};
</code></pre>
<p>Runtime: 3 ms</p>

<h3><a name="345" class="anchor" href="#345"><span class="octicon octicon-link"></span></a>#345 Reverse Vowels of a String (Easy)</h3>
<p>Scan from both ends and swap vowels.</p>
<pre><code>class Solution {
public:
    string reverseVowels(string s) {

        int length = s.length();
        int i = 0;
        int j = length - 1;
        char tmp;

        while( i < j ){
            while( !isVowel( s[ i ] ) && i < j ) ++i;
            while( !isVowel( s[ j ] ) && i < j ) --j;
            if( i < j ){
                tmp = s[ i ];
                s[ i ] = s[ j ];
                s[ j ] = tmp;
            }
            ++i;
            --j;
        }

        return s;
    }

private:
    bool isVowel( char ch ){
        return ch == 'a' || ch == 'e' || ch == 'i' || ch == 'o' || ch == 'u'
            || ch == 'A' || ch == 'E' || ch == 'I' || ch == 'O' || ch == 'U';
    }
};
</code></pre>
<p>Runtime: 16 ms</p>

<h3><a name="350" class="anchor" href="#350"><span class="octicon octicon-link"></span></a>#350 Intersection of Two Arrays II (Easy)</h3>
<p>Application of map.</p>
<pre><code>class Solution {
public:
    vector<int> intersect(vector<int>& nums1, vector<int>& nums2) {

        map< int, int > map1;
        vector< int > intersection;

        for( auto i : nums1 ){

            auto ite = map1.find( i );

            if( ite == map1.end() ){
                map1[ i ] = 1;
            }else{
                ++ite->second;
            }
        }

        for( auto i : nums2 ){

            auto ite = map1.find( i );

            if( ite != map1.end() ){
                intersection.push_back( i );
                if( --ite->second == 0 ){
                    map1.erase( ite );
                }
            }
        }

        return intersection;
    }
};
</code></pre>
<p>Runtime: 16 ms</p>

<h3><a name="349" class="anchor" href="#349"><span class="octicon octicon-link"></span></a>#349 Intersection of Two Arrays (Easy)</h3>
<p>Application of unordered_set.</p>
<pre><code>class Solution {
public:
    vector<int> intersection(vector<int>& nums1, vector<int>& nums2) {

        vector< int > intersection;
        unordered_set< int > uset1, uset2;

        for( auto i : nums1 ){
            uset1.insert( i );
        }

        for( auto i : nums2 ){
            if( uset1.find( i ) != uset1.end() ){
                uset2.insert( i );
            }
        }

        for( auto i : uset2 ){
            intersection.push_back( i );
        }

        return intersection;
    }
};
</code></pre>
<p>Runtime: 12 ms</p>

<h3><a name="371" class="anchor" href="#371"><span class="octicon octicon-link"></span></a>#371 Sum of Two Integers (Easy)</h3>
<p>Use AND to compute carry, lshift it by 1 bit and sum it to result of XOR till no carry.</p>
<pre><code>class Solution {
public:
    int getSum(int a, int b) {

        int c;

        while( b ){
            c = ( a & b ) << 1;
            a = a ^ b;
            b = c;
        }

        return a;
    }
};
</code></pre>
<p>Runtime: 0 ms</p>

<h3><a name="401" class="anchor" href="#401"><span class="octicon octicon-link"></span></a>#401 Binary Watch (Easy)</h3>
<p>Enumerate time from 0:00 to 11:59, check number of bits set and append to result list if equal to num.</p>
<pre><code>class Solution {
public:
    vector<string> readBinaryWatch(int num) {
        vector<string> result;

        for (int i = 0; i <= 11; ++i) {
            for (int j = 0; j <= 5; ++j) {
                for (int k = 0; k <= 9; ++k) {
                    if (num == numBitOnes(i) + numBitOnes(j * 10 + k)) {
                        stringstream ss;
                        ss << i << ":" << j << k;
                        result.push_back(ss.str());
                    }
                }
            }
        }
        return result;
    }
private:
    int numBitOnes(int x) {
        int result = 0;
        while(x) {
            result += 1;
            x = x & (x - 1);
        }
        return result;
    }
};
</code></pre>
<p>Runtime: 0 ms</p>

<h3><a name="258" class="anchor" href="#258"></a>#258 Add Digits (Easy)</h3>
<p>There are 10 possible results. If num is 0, print 0. Else if num can be exactly divided by 9, print 9. Else print the remainder.</p>
<pre><code>class Solution {
public:
   int addDigits(int num) {
      return ( num - 1 ) % 9 + 1;
   }
};
</code></pre>
<p>Runtime: 8 ms</p>

<h3><a name="104" class="anchor" href="#104"></a>#104 Maximum Depth of Binary Tree (Easy)</h3>
<p>Recursively find maximum depth of subtrees of the current node, return the larger one incremented by 1.</p>
<pre><code>class Solution {
public:
   int maxDepth(TreeNode* root) {
      return root? max( maxDepth( root->left ), maxDepth( root->right ) ) + 1 : 0;
   }
};
</code></pre>
<p>Runtime: 8 ms</p>

<h3><a name="237" class="anchor" href="#237"></a>#237 Delete Node in a Linked List (Easy)</h3>
<p>Instead of delete the given node, replace it by its next node and delete the next node.</p>
<pre><code>class Solution {
public:
   void deleteNode(ListNode* node) {

      ListNode *nextNode( node->next );
      ListNode *nextNextNode( nextNode->next );

      node->val = nextNode->val;
      node->next = nextNextNode;

      delete nextNode;
   }
};
</code></pre>
<p>Runtime: 20 ms</p>

<h3><a name="283" class="anchor" href="#283"></a>#283 Move Zeroes (Easy)</h3>
<p>Suppose we already have a "sorted" sequence in the form [num,...,num,0,...,0] and here comes a:<br>
I) zero: simply add it to the tail<br>
II) non-zero: add it to the tail and swap it with the first zero in the original sequence<br>
Run the algorithm above with original sequence empty.</p>
<pre><code>class Solution {
public:
   void moveZeroes(vector< int >& nums) {

      int nNums( nums.size() );
      int nZeros( 0 );

      for( int i = 0; i < nNums; ++i ){
        if( nums[ i ] == 0 ){
          ++nZeros;
        }else if( nZeros > 0 && i - nZeros >= 0 ){
          swap( nums[ i ], nums[ i - nZeros ] );
        }
      }
   }

   void swap( int &a, int &b ){
      a ^= b ^= a ^= b;
   }
};
</code></pre>
<p>Runtime: 20 ms</p>

<h3><a name="100" class="anchor" href="#100"></a>#100 Same Tree (Easy)</h3>
<p>Compare current node, then subtrees recursively. Mind null pointer error.</p>
<pre><code>class Solution {
public:
   bool isSameTree(TreeNode* p, TreeNode* q) {
      if( p == NULL && q == NULL ) return true;
      if( p == NULL && q != NULL ) return false;
      if( p != NULL && q == NULL ) return false;
      if( p->val != q->val ) return false;
      if( !isSameTree( p->left, q->left ) ) return false;
      if( !isSameTree( p->right, q->right ) ) return false;
      return true;
   }
};
</code></pre>
<p>Runtime: 0 ms</p>

<h3><a name="226" class="anchor" href="#226"></a>#226 Invert Binary Tree (Easy)</h3>
<p>Recursively swap left subtree and right subtree.</p>
<pre><code>class Solution {
public:
   TreeNode* invertTree(TreeNode* root) {

      if( root == NULL ) return NULL;

      TreeNode *tmp( root->left );
      root->left = root->right;
      root->right = tmp;

      invertTree( root->left );
      invertTree( root->right );

      return root;
   }
};
</code></pre>
<p>Runtime: 0 ms</p>

<h3><a name="242" class="anchor" href="#242"></a>#242 Valid Anagram (Easy)</h3>
<p>Simply compare occurrence of letters in each word.</p>
<pre><code>class Solution {
public:
   bool isAnagram(string s, string t) {

      if( s.length() != t.length() ) return false;

      int len( s.length() );
      int count[ 26 ];

      memset( count, 0, sizeof count );

      for( int i = 0; i < len; ++i ){
        ++count[ s[ i ] - ( int )'a' ];
        --count[ t[ i ] - ( int )'a' ];
      }

      for( int i = 0; i < 26; ++i ){
        if( count[ i ] ) return false;
      }

      return true;
   }
};
</code></pre>
<p>Runtime: 12 ms</p>

<h3><a name="217" class="anchor" href="#217"></a>#217 Contains Duplicate (Easy)</h3>
<p>Use std::unordered_set.</p>
<pre><code>class Solution {
public:
   bool containsDuplicate(vector< int >& nums) {

      unordered_set< int > uset;

      for( int num : nums ){

        if( uset.find( num ) != uset.end() )
          return true;
        else
          uset.insert( num );
      }

      return false;
   }
};
</code></pre>
<p>Runtime: 48 ms</p>
<p>Runtime (using std::set): 104 ms</p>

<h3><a name="171" class="anchor" href="#171"></a>#171 Excel Sheet Column Number (Easy)</h3>
<p>A new type of number with numerical base 26.</p>
<pre><code>class Solution {
public:
   int titleToNumber(string s) {

      int len( s.length() );
      int result( 0 );

      for( int i = 0; i < len; ++i ){
        if( i ) result *= 26;
        result += s[ i ] - ( int )'A' + 1;
      }

      return result;
   }
};
</code></pre>
<p>Runtime: 8 ms</p>

<h3><a name="169" class="anchor" href="#169"></a>#169 Majority Element (Easy)</h3>
<p>Since we are given the condition "majority element always exists", its number of occurrence is greater than that of other numbers. Subtract the number of occurrence of the currently expected ME by number of occurrence of other numbers.</p>
<pre><code>class Solution {
public:
   int majorityElement(vector< int >& nums) {

      int majorCount( 0 );
      int majorNum( 0 );

      for( int num : nums ){
        if( majorCount == 0 ){
          ++majorCount;
          majorNum = num;
        }else if( majorNum == num ){
          ++majorCount;
        }else{
          --majorCount;
        }
      }

      return majorNum;
   }
};
</code></pre>
<p>Runtime: 20 ms</p>

<h3><a name="235" class="anchor" href="#235"></a>#235 Lowest Common Ancestor of a Binary Search Tree (Easy)</h3>
<p>Since the given tree is a BST, value of LCA must be between values of p and q.</p>
<pre><code>class Solution {
public:
   TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {

      if( p->val > q->val ){
        TreeNode *tmp( p );
        p = q;
        q = tmp;
      }

      if( root == p || root == q )
        return root;
      else if( root->val > p->val && root->val <= q->val )
        return root;
      else if( q->val < root->val )
        return lowestCommonAncestor( root->left, p, q );
      else
        return lowestCommonAncestor( root->right, p, q );
   }

};
</code></pre>
<p>Runtime: 44 ms</p>

<h3><a name="191" class="anchor" href="#191"></a>#191 Number of 1 Bits (Easy)</h3>
<p>Simple counting.</p>
<pre><code>class Solution {
public:
   int hammingWeight(uint32_t n) {
      n = ( n & 0x55555555U ) + ( n >> 1 & 0x55555555U );
      n = ( n & 0x33333333U ) + ( n >> 2 & 0x33333333U );
      n = ( n & 0x0f0f0f0fU ) + ( n >> 4 & 0x0f0f0f0fU );
      n = ( n & 0x00ff00ffU ) + ( n >> 8 & 0x00ff00ffU );
      n = ( n & 0x0000ffffU ) + ( n >> 16 & 0x0000ffffU );
      return ( int )n;
   }
};
</code></pre>
<p>Runtime: 4 ms</p>

<h3><a name="13" class="anchor" href="#13"></a>#13 Roman to Integer (Easy)</h3>
<p>If a digit is less than its following digit, subtract it from result, else add it to result.</p>
<pre><code>class Solution {
public:
   int romanToInt(string s) {

      static const int r2d[ 26 ]{
        0, 0, 100, 500, 0, 0, 0, 0, 1, 0, 0, 50, 1000,
        0, 0, 0, 0, 0, 0, 0, 0, 5, 0, 10, 0, 0,
      };

      int result( r2d[ s[ 0 ] - ( int )'A'] );
      int pre( result ), cur( 0 );
      int len( s.length() );

      for( int i = 1; i < len; ++i ){
        cur = r2d[ s[ i ] - ( int )'A' ];
        if( cur > pre ) result -= pre << 1;
        result += cur;
        pre = cur;
      }

      return result;
   }
};
</code></pre>
<p>Runtime: 36 ms</p>

<h3><a name="206" class="anchor" href="#206"></a>#206 Reverse Linked List (Easy)</h3>
<p>Use a vector. OK I am cheating.</p>
<pre><code>class Solution {
public:
   ListNode* reverseList(ListNode* head) {

      if( head == NULL ) return NULL;

      vector< ListNode * > nodes;

      for( ListNode *pNode = head; pNode != NULL; pNode = pNode->next ){
        nodes.push_back( pNode );
      }

      for( int i = nodes.size() - 1; i > 0; --i ){
        nodes[ i ]->next = nodes[ i - 1 ];
      }

      nodes[ 0 ]->next = NULL;

      return nodes.back();
   }
};
</code></pre>
<p>Runtime: 8 ms</p>

<h3><a name="70" class="anchor" href="#70"></a>#70 Climbing Stairs (Easy)</h3>
<p>Number of ways to reach nth step can be added up by:<br>
number of ways to reach (n-1)th step (climb 1 step from here) and<br>
number of ways to reach (n-2)th step (climb 2 steps from here).</p>
<pre><code>class Solution {
public:
   int climbStairs(int n) {

      vector< int > v( 2, 1 );

      for( int i = 2; i <= n; ++i ){
        v.push_back( v[ i - 1 ] + v[ i - 2 ] );
      }

      return v[ n ];
   }
};
</code></pre>
<p>Runtime: 0 ms</p>

<h3><a name="83" class="anchor" href="#83"></a>#83 Remove Duplicates from Sorted List (Easy)</h3>
<p>If next node has same value as current node, delete next node (and release memory).</p>
<pre><code>class Solution {
public:
   ListNode* deleteDuplicates(ListNode* head) {

      for( ListNode *cur = head; cur != NULL; ){

        ListNode *nxt( cur->next );

        if( nxt == NULL ) break;
        if( nxt->val == cur->val ){
          cur->next = nxt->next;
          delete nxt;
        }else{
          cur = nxt;
        }
      }

      return head;
   }
};
</code></pre>
<p>Runtime: 16 ms</p>

<h3><a name="263" class="anchor" href="#263"></a>#263 Ugly Number (Easy)</h3>
<p>Divide the number by 2, 3, and 5 repeatedly. If 1 is left, the number is ugly.</p>
<pre><code>class Solution {
public:
   bool isUgly(int num) {

      if( num <= 0 ) return false;

      while( num % 2 == 0 ) num /= 2;
      while( num % 3 == 0 ) num /= 3;
      while( num % 5 == 0 ) num /= 5;

      return num == 1;
   }
};
</code></pre>
<p>Runtime: 4 ms</p>

<h3><a name="202" class="anchor" href="#202"></a>#202 Happy Number (Easy)</h3>
<p>Use std::unordered_set to check if a cycle exists.</p>
<pre><code>class Solution {
public:
   bool isHappy(int n) {

      if( n <= 0 ) return false;

      unordered_set< int > uset;

      while( n != 1 ){
        if( uset.find( n ) != uset.end() )
          return false;
        else{
          uset.insert( n );
          n = nextN( n );
        }
      }

      return true;
   }

   int nextN( int n ){

      int result( 0 ), tmp;

      while( n ){
        tmp = n % 10;
        n /= 10;
        result += tmp * tmp;
      }

      return result;
   }
};
</code></pre>
<p>Runtime: 4 ms</p>

<h3><a name="21" class="anchor" href="#21"></a>#21 Merge Two Sorted Lists (Easy)</h3>
<p>Repeatedly take the larger head node of the lists.</p>
<pre><code>class Solution {
public:
   ListNode* mergeTwoLists(ListNode* l1, ListNode* l2) {

      if( l1 == NULL )
        return l2;
      else if( l2 == NULL )
        return l1;

      ListNode head( 0 ), *tail( &head );

      for( ; l1 != NULL && l2 != NULL; tail = tail->next ){

        if( l1->val < l2->val ){
          tail->next = l1;
          l1 = l1->next;
        }else{
          tail->next = l2;
          l2 = l2->next;
        }
      }

      if( l1 == NULL )
        tail->next = l2;
      else
        tail->next = l1;

      return head.next;
   }
};
</code></pre>
<p>Runtime: 12 ms</p>

<h3><a name="232" class="anchor" href="#232"></a>#232 Implement Queue using Stacks (Easy)</h3>
<p>Take advantage of 2 stacks to get access to both head and tail.</p>
<pre><code>class Queue {
public:
   // Push element x to the back of queue.
   void push(int x) {
      while( !b.empty() ){ a.push( b.top() ); b.pop(); }
      a.push( x );
   }

   // Removes the element from in front of queue.
   void pop(void) {
      while( !a.empty() ){ b.push( a.top() ); a.pop(); }
      b.pop();
   }

   // Get the front element.
   int peek(void) {
      while( !a.empty() ){ b.push( a.top() ); a.pop(); }
      return b.top();
   }

   // Return whether the queue is empty.
   bool empty(void) {
      return a.empty() && b.empty();
   }

   stack< int > a, b;
};
</code></pre>
<p>Runtime: 0 ms</p>

<h3><a name="231" class="anchor" href="#231"></a>#231 Power of 2 (Easy)</h3>
<p>In binary representation, (n & -n) is the rightmost 1 of n. Use it to cancel the rightmost 1 of n (by XOR) and n will be 0 if it is a power of 2.</p>
<pre><code>class Solution {
public:
   bool isPowerOfTwo(int n) {
      return n > 0 && ( n & -n ^ n ) == 0;
   }
};
</code></pre>
<p>Runtime: 4 ms</p>

<h3><a name="110" class="anchor" href="#110"></a>#110 Balanced Binary Tree (Easy)</h3>
<p>Recursively compare depths of subtrees.</p>
<pre><code>class Solution {
public:
   bool isBalanced(TreeNode* root) {

      int depth( 0 );

      return isBalancedAndGetDepth( root, depth );
   }

   bool isBalancedAndGetDepth( TreeNode *root, int &depth ){

      if( root == NULL ) return true;

      int lDepth( 0 ), rDepth( 0 );

      if( !isBalancedAndGetDepth( root->left, lDepth ) ) return false;
      if( !isBalancedAndGetDepth( root->right, rDepth ) ) return false;
      if( lDepth - rDepth > 1 || lDepth - rDepth < -1 ) return false;
      depth = lDepth > rDepth ? lDepth + 1 : rDepth + 1;

      return true;
   }
};
</code></pre>
<p>Runtime: 20 ms</p>

<h3><a name="101" class="anchor" href="#101"></a>#101 Symmetric Tree (Easy)</h3>
<p>For a symmetric tree, its right subtree is a mirror of its left subtree.<br>
For two mirrored trees A and B, A's right subtree is a mirror of B's left subtree, and A's left subtree is a mirror of B's right subtree.</p>
<pre><code>class Solution {
public:
   bool isSymmetric(TreeNode* root) {
      return root == NULL || isMirror( root->left, root->right );
   }

   bool isMirror( TreeNode *left, TreeNode *right ){
      if( left == NULL && right == NULL ) return true;
      if( left != NULL && right == NULL ) return false;
      if( left == NULL && right != NULL ) return false;

      return left->val == right->val
        && isMirror( left->left, right->right )
        && isMirror( left->right, right->left );
   }
};
</code></pre>
<p>Runtime: 4 ms</p>

<h3><a name="27" class="anchor" href="#27"></a>#27 Remove Element (Easy)</h3>
<p>Just remove element.</p>
<pre><code>class Solution {
public:
   int removeElement(vector< int >& nums, int val) {

      int len( nums.size() );

      for( int i = 0; i < len; ++i ){
        if( nums[ i ] != val ) continue;
        while( i < len && nums[ len - 1 ] == val ) --len;
        if( i < len ) nums[ i ] = nums[ --len ];
      }

      return len;
   }
};
</code></pre>
<p>Runtime: 4 ms</p>

<h3><a name="107" class="anchor" href="#107"></a>#107 Binary Tree Level Order Traversal II (Easy)</h3>
<p>Use std::queue to implement BFS and use std::stack to print result in expected order.</p>
<pre><code>class Solution {
public:
   vector< vector< int > > levelOrderBottom(TreeNode* root) {

      if( root == NULL ) return vector< vector< int > >();

      vector< vector< int > > result;
      queue< pair< TreeNode *, int > > mqueue;
      stack< pair< TreeNode *, int > > mstack;

      mqueue.push( make_pair( root, 0 ) );

      while( !mqueue.empty() ){

        TreeNode *node( mqueue.front().first );
        int layer( mqueue.front().second );

        mstack.push( mqueue.front() );
        if( node->right != NULL ) mqueue.push( make_pair( node->right, layer + 1 ) );
        if( node->left != NULL ) mqueue.push( make_pair( node->left, layer + 1 ) );
        mqueue.pop();
      }

      while( !mstack.empty() ){

        vector< int > v;
        int maxLayer( mstack.top().second );

        while( !mstack.empty() && mstack.top().second == maxLayer ){
          v.push_back( mstack.top().first->val );
          mstack.pop();
        }

        result.push_back( v );
      }

      return result;
   }
};
</code></pre>
<p>Runtime: 8 ms</p>

<h3><a name="198" class="anchor" href="#198"></a>#198 House Robber (Easy)</h3>
<p>Dynamic Progromming<br>
a[i] is the maximum value I can get from previous i houses without robbing the ith house,<br>
b[i] is the maximum value I can get from previous i houses with robbing the ith house,<br>
Then we have:<br>
a[i+1] = max{ a[i], b[i] }, without robbing (i+1)th house,<br>
b[i+1] = a[i] + {value of (i+1)th house}, with robbing (i+1)th house.</p>
<pre><code>class Solution {
public:
   int rob(vector< int >& nums) {

      int nNums( nums.size() );
      vector< int > a( nNums + 1, 0 ), b( nNums + 1, 0 );

      for( int i = 0; i < nNums; ++i ){
        a[ i + 1 ] = max( a[ i ], b[ i ] );
        b[ i + 1 ] = a[ i ] + nums[ i ];
      }

      return max( a[ nNums ], b[ nNums ] );
   }
};
</code></pre>
<p>Runtime: 0 ms</p>

<h3><a name="26" class="anchor" href="#26"></a>#26 Remove Duplicates from Sorted Array (Easy)</h3>
<p>Iterate and remove duplicates.</p>
<pre><code>class Solution {
public:
   int removeDuplicates(vector< int >& nums) {

      if( nums.empty() ) return 0;

      int nNums( nums.size() ), result( 1 );

      for( int i = 1; i < nNums; ++i ){
        if( nums[ i ] != nums[ i - 1 ] ){
          nums[ result++ ] = nums[ i ];
        }
      }

      return result;
   }
};
</code></pre>
<p>Runtime: 32 ms</p>

<h3><a name="66" class="anchor" href="#66"></a>#66 Plus One (Easy)</h3>
<p>Simple iteration. Increment from least significant digit and break if no carry.</p>
<pre><code>class Solution {
public:
   vector< int > plusOne(vector< int >& digits) {

      vector< int > result;
      int nDigits( digits.size() );
      bool carry( true );

      for( int i = nDigits - 1; i >= 0; --i ){
        if( ++digits[ i ] > 9 ){
          digits[ i ] -= 10;
        }else{
          carry = false;
          break;
        }
      }

      if( carry ) result.push_back( 1 );
      result.insert( result.end(), digits.begin(), digits.end() );

      return result;
   }
};
</code></pre>
<p>Runtime: 4 ms</p>

<h3><a name="118" class="anchor" href="#118"></a>#118 Pascal's Triangle (Easy)</h3>
<p>a[i,1] = a[i,i] = 1<br>
a[i,j] = a[i-1,j-1] + a[i-1,j].</p>
<pre><code>class Solution {
public:
   vector< vector< int > > generate(int numRows) {

      if( numRows == 0 ) return vector< vector< int > >();

      vector< vector< int > > result{{1}};

      for( int i = 2; i <= numRows; ++i ){

        vector< int > v{1};

        for( int j = 1; j <= i - 2; ++j ){
          v.push_back( result[ i - 2 ][ j - 1 ] + result[ i - 2 ][ j ] );
        }

        v.push_back( 1 );
        result.push_back( v );
      }

      return result;
   }
};
</code></pre>
<p>Runtime: 0 ms</p>

<h3><a name="172" class="anchor" href="#172"></a>#172 Factorial Trailing Zeroes (Easy)</h3>
<p>Since trailing zeroes are produced by 2 and 5 (2*5=10) in n!'s factors and 5 appears less frequently, simply count number of occurrence of 5 in n!'s factors.</p>
<pre><code>class Solution {
public:
   int trailingZeroes(int n) {

      int result( 0 );
      long long N( n ), powerOf5( 5 );

      while( N >= powerOf5 ){
        result += ( int )( N / powerOf5 );
        powerOf5 *= 5LL;
      }

      return result;
   }
};
</code></pre>
<p>Runtime: 4 ms</p>

<h3><a name="119" class="anchor" href="#119"></a>#119 Pascal's Triangle II (Easy)</h3>
<p>Reverse order of calculation so that next row can be produced in place.</p>
<pre><code>class Solution {
public:
   vector< int > getRow(int rowIndex) {

      vector< int > result{ 1 };

      for( int i = 1; i <= rowIndex; ++i ){
        for( int j = i - 1; j > 0; --j ){
          result[ j ] += result[ j - 1 ];
        }
        result.push_back( 1 );
      }

      return result;
   }
};
</code></pre>
<p>Runtime: 0 ms</p>

<h3><a name="102" class="anchor" href="#102"></a>#102 Binary Tree Level Order Traversal (Easy)</h3>
<p>Use a queue to implement BFS.</p>
<pre><code>class Solution {
public:
   vector< vector< int > > levelOrder(TreeNode* root) {

      if( root == NULL ) return vector< vector< int > >();

      vector< vector< int > > result;
      vector< int > v;
      queue< pair< TreeNode *, int > > mqueue;
      int currentLevel( 0 );

      mqueue.push( make_pair( root, 0 ) );

      while( !mqueue.empty() ){

        TreeNode *node( mqueue.front().first );
        int nodeLevel( mqueue.front().second );

        if( nodeLevel != currentLevel ){
          result.push_back( v );
          v.clear();
          ++currentLevel;
        }

        v.push_back( node->val );

        if( node->left != NULL ){
          mqueue.push( make_pair( node->left, currentLevel + 1 ) );
        }
        if( node->right != NULL ){
          mqueue.push( make_pair( node->right, currentLevel + 1 ) );
        }

        mqueue.pop();
      }

      result.push_back( v );

      return result;
   }
};
</code></pre>
<p>Runtime: 8 ms</p>

<h3><a name="112" class="anchor" href="#112"></a>#112 Path Sum (Easy)</h3>
<p>If there's a path from current node to leaf summed to {Sum}, there's a path from its child node to leaf Summed to {Sum - value of current node}.</p>
<pre><code>class Solution {
public:
   bool hasPathSum(TreeNode* root, int sum) {

      if( root == NULL ) return false;
      if( root->left == NULL && root->right == NULL ){
        return root->val == sum;
      }else{
        sum -= root->val;
        if( root->left != NULL && hasPathSum( root->left, sum ) ) return true;
        if( root->right != NULL && hasPathSum( root->right, sum ) ) return true;
        return false;
      }
   }
};
</code></pre>
<p>Runtime: 12 ms</p>

<h3><a name="225" class="anchor" href="#225"></a>#225 Implement Stack using Queues (Easy)</h3>
<p>Take advantage of 2 queues to get access to both head and tail.</p>
<pre><code>class Stack {
public:
   // Push element x onto stack.
   void push(int x) {
      b.push( x );
   }

   // Removes the element on top of the stack.
   void pop() {
      if( !b.empty() ){
        while( b.size() > 1 ){ a.push( b.front() ); b.pop(); }
        b.pop();
      }else{
        while( !a.empty() ){ b.push( a.front() ); a.pop(); }
        pop();
      }
   }

   // Get the top element.
   int top() {
      if( !b.empty() ){
        while( b.size() > 1 ){ a.push( b.front() ); b.pop(); }
        return b.front();
      }else{
        while( !a.empty() ){ b.push( a.front() ); a.pop(); }
        return top();
      }
   }

   // Return whether the stack is empty.
   bool empty() {
      return a.empty() && b.empty();
   }

   queue< int > a, b;
};
</code></pre>
<p>Runtime: 0 ms</p>

<h3><a name="9" class="anchor" href="#9"></a>#9 Panlindrome Number (Easy)</h3>
<p>(Discussion) Reverse till half and compare.</p>
<pre><code>class Solution {
public:
   bool isPalindrome(int x) {

      if( x < 0 || x != 0 && x % 10 == 0 ) return false;

      int y( 0 );

      while( x >= y ){
        if( x == y || x / 10 == y ) return true;
        y = y * 10 + x % 10;
        x /= 10;
      }

      return false;
   }
};
</code></pre>
<p>Runtime: 80 ms</p>

<h3><a name="111" class="anchor" href="#111"></a>#111 Minimum Depth of Binary Tree (Easy)</h3>
<p>Recursively find min depth. Trim branches deeper than current min depth.</p>
<pre><code>class Solution {
public:
   int minDepth(TreeNode* root) {

      if( root == NULL ) return 0;

      result = 0x7fffffff;
      traverse( root, 1 );

      return result;
   }

   void traverse( TreeNode *root, int depth ){

      if( root->left == NULL && root->right == NULL )
        result = depth;
      else if( result <= depth )
        return;
      else{
        if( root->left != NULL ) traverse( root->left, depth + 1 );
        if( root->right != NULL ) traverse( root->right, depth + 1 );
      }
   }

   int result;
};
</code></pre>
<p>Runtime: 12 ms</p>

<h3><a name="160" class="anchor" href="#160"></a>#160 Intersection of Two Linked Lists (Easy)</h3>
<p>Calculate difference of length of the given lists D.<br>
Two pointers walk on the lists, with the pointer on longer list walked D steps in advance.<br>
The intersection is where they meet.</p>
<pre><code>class Solution {
public:
   ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {

      ListNode *ptrA( headA ), *ptrB( headB );
      ListNode *tailA( NULL ), *tailB( NULL );
      int lenA( 0 ), lenB( 0 );

      for( ; ptrA != NULL; ptrA = ptrA->next ){
        if( ptrA->next == NULL ) tailA = ptrA;
        ++lenA;
      }

      for( ; ptrB != NULL; ptrB = ptrB->next ){
        if( ptrB->next == NULL ) tailB = ptrB;
        ++lenB;
      }

      if( tailA != tailB ) return NULL;

      if( lenA < lenB ){
        auto tmp1( lenA ); lenA = lenB; lenB = tmp1;
        auto tmp2( headA ); headA = headB; headB = tmp2;
      }

      ptrA = headA;
      ptrB = headB;

      for( int i = lenA - lenB; i > 0; ptrA = ptrA->next, --i );
      for( ; ptrA != ptrB; ptrA = ptrA->next, ptrB = ptrB->next );

      return ptrA;
   }
};
</code></pre>
<p>Runtime: 52 ms</p>
<p>(Discussion) Smart solution!</p>
<pre><code>class Solution {
public:
   ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {
      ListNode *ptrA = headA, *ptrB = headB;
      while (ptrA != ptrB) {
        ptrA = ptrA ? ptrA->next : headB;
        ptrB = ptrB ? ptrB->next : headA;
      }
      return ptrA;
   }
};
</code></pre>

<h3><a name="88" class="anchor" href="#88"></a>#88 Merge Sorted Array (Easy)</h3>
<p>Merge from tail, so that no extra memory is needed.</p>
<pre><code>class Solution {
public:
   void merge(vector< int >& nums1, int m, vector< int >& nums2, int n) {

      if( m == 0 ){ nums1 = nums2; return; }
      if( n == 0 ) return;

      nums1.resize( m + n );

      for( int i = m - 1, j = n - 1, k = m + n - 1; k >= 0; --k ){
        if( i < 0 ){ nums1[ k ] = nums2[ j-- ]; continue; }
        if( j < 0 ){ nums1[ k ] = nums1[ i-- ]; continue; }
        nums1[ k ] = nums1[ i ] > nums2[ j ] ? nums1[ i-- ] : nums2[ j-- ];
      }
   }
};
</code></pre>
<p>Runtime: 4 ms</p>

<h3><a name="190" class="anchor" href="#190"></a>#190 Reverse Bits (Easy)</h3>
<p>Simple bits manipulation.</p>
<pre><code>class Solution {
public:
   uint32_t reverseBits(uint32_t n) {

      n = ( n << 1 & 0xAAAAAAAAU ) | ( n >> 1 & 0x55555555U );
      n = ( n << 2 & 0xCCCCCCCCU ) | ( n >> 2 & 0x33333333U );
      n = ( n << 4 & 0xF0F0F0F0U ) | ( n >> 4 & 0x0F0F0F0FU );
      n = ( n << 8 & 0xFF00FF00U ) | ( n >> 8 & 0x00FF00FFU );
      n = ( n << 16 & 0xFFFF0000U ) | ( n >> 16 & 0x0000FFFFU );

      return n;
   }
};
</code></pre>
<p>Runtime: 4 ms</p>

<h3><a name="36" class="anchor" href="#36"></a>#36 Valid Sudoku (Easy)</h3>
<p>Simple counting.</p>
<pre><code>class Solution {
public:
   bool isValidSudoku(vector< vector<char>>& board) {

      vector< bool > flag;
      char tmp;

      for( int i = 0, jj, kk; i < 9; ++i ){

        flag.assign( 10, false );
        for( int j = 0; j < 9; ++j ){
          if( ( tmp = board[ i ][ j ] ) == '.' ) continue;
          if( flag[ tmp - '0' ] ) return false;
          flag[ tmp - '0' ] = true;
        }

        flag.assign( 10, false );
        for( int j = 0; j < 9; ++j ){
          if( ( tmp = board[ j ][ i ] ) == '.' ) continue;
          if( flag[ tmp - '0' ] ) return false;
          flag[ tmp - '0' ] = true;
        }

        jj = i / 3 * 3; kk = i % 3 * 3;
        flag.assign( 10, false );
        for( int j = 0; j < 3; ++j ){
          for( int k = 0; k < 3; ++k ){
              if( ( tmp = board[ jj + j ][ kk + k ] ) == '.' ) continue;
              if( flag[ tmp - '0' ] ) return false;
              flag[ tmp - '0' ] = true;
          }
        }
      }

      return true;
   }
};
</code></pre>
<p>Runtime: 16 ms</p>

<h3><a name="223" class="anchor" href="#223"></a>#223 Rectangle Area (Easy)</h3>
<p>Use long long to avoid int overflow.</p>
<pre><code>class Solution {
public:
   int computeArea(int A, int B, int C, int D, int E, int F, int G, int H) {

      long long a( ( 0LL + C - A ) * ( 0LL + D - B ) );
      long long b( ( 0LL + G - E ) * ( 0LL + H - F ) );
      long long c( 0LL + min( C, G ) - max( A, E ) );
      long long d( 0LL + min( D, H ) - max( B, F ) );
      long long e( c > 0LL && d > 0LL ? c * d : 0LL );

      return ( int )( a + b - e );
   }
};
</code></pre>
<p>Runtime: 32 ms</p>

<h3><a name="219" class="anchor" href="#219"></a>#219 Contains Duplicate II (Easy)</h3>
<p>Use std::unordered_set.</p>
<pre><code>class Solution {
public:
   bool containsNearbyDuplicate(vector< int >& nums, int k) {

      if( k <= 0 ) return false;

      unordered_set< int > uset;
      int nNums( nums.size() );

      for( int i = 0; i < nNums; ++i ){
        if( uset.find( nums[ i ] ) != uset.end() ) return true;
        if( i - k >= 0 ) uset.erase( nums[ i - k ] );
        uset.insert( nums[ i ] );
      }

      return false;
   }
};
</code></pre>
<p>Runtime: 32 ms</p>

<h3><a name="58" class="anchor" href="#58"></a>#58 Length of Last Word (Easy)</h3>
<p>Simple counting.</p>
<pre><code>class Solution {
public:
   int lengthOfLastWord(string s) {

      int len( s.length() );
      int result( 0 );

      while( len > 0 && s[ len - 1 ] == ' ' ) --len;
      while( len > 0 && s[ len - 1 ] != ' ' ) --len, ++result;

      return result;
   }
};
</code></pre>
<p>Runtime: 4 ms</p>

<h3><a name="19" class="anchor" href="#19"></a>#19 Remove Nth Node From End of List (Easy)</h3>
<p>2 pointers walk along the list with fast one ahead of slow one by N steps. Delete slow one when fast one meets the end.</p>
<pre><code>class Solution {
public:
   ListNode* removeNthFromEnd(ListNode* head, int &n) {

      ListNode *fast( head ), *slow( head );

      for( int i = 0; i < n; ++i, fast = fast->next );

      if( !fast ){
        auto tmp( head );
        head = head->next;
        delete tmp;
        return head;
      }else{
        fast = fast->next;
        while( fast ){ slow = slow->next; fast = fast->next; }
        auto nxt( slow->next ); slow->next = nxt->next; delete nxt;
      }

      return head;
   }
};
</code></pre>
<p>Runtime: 4 ms</p>

<h3><a name="20" class="anchor" href="#20"></a>#20 Valid Parentheses (Easy)</h3>
<p>Use a stack. When it comes a left bracket, push into stack, or it comes a right bracket, check if it makes a pair with the top element in stack.</p>
<pre><code>class Solution {
public:
   bool isValid(string s) {

      stack< int > mstack;
      unordered_map< char, int > umap{
        { '(', 0 }, { ')', 1 },
        { '{', 2 }, { '}', 3 },
        { '[', 4 }, { ']', 5 },
      };

      for( char ch : s ){
        int code( umap[ ch ] );
        if( code & 1 ){
          if( mstack.empty() ) return false;
          if( mstack.top() != code - 1 ) return false;
          mstack.pop();
        }else
          mstack.push( code );
      }

      return mstack.empty();
   }
};
</code></pre>
<p>Runtime: 0 ms</p>

<h3><a name="205" class="anchor" href="#205"></a>#205 Isomorphic Strings (Easy)</h3>
<p>Check 1-to-1 mapping.</p>
<pre><code>class Solution {
public:
   bool isIsomorphic(string s, string t) {

      char chmap[ 256 ]{ 0 };
      bool used[ 256 ]{ false };
      int len( s.length() );

      for( int i = 0; i < len; ++i ){
        if( chmap[ s[ i ] ] ){
          if( chmap[ s[ i ] ] != t[ i ] ) return false;
        }else{
          if( used[ t[ i ] ] ) return false;
          chmap[ s[ i ] ] = t[ i ];
          used[ t[ i ] ] = true;
        }
      }

      return true;
   }
};
</code></pre>
<p>Runtime: 36 ms</p>
<p>(Discussion) Smarter solution.</p>
<pre><code>class Solution {
public:
   bool isIsomorphic(string s, string t) {

      char stmap[ 512 ]{ 0 };
      int len( s.length() );

      for( int i = 0; i < len; ++i ){
        if( stmap[ s[ i ] ] != stmap[ t[ i ] + 256 ] return false;
        stmap[ s[ i ] ] = stmap[ t[ i ] + 256 ] = i + 1;
      }

      return true;
   }
};
</code></pre>
<p>Runtime: 8 ms</p>

<h3><a name="290" class="anchor" href="#290"></a>#290 Word Pattern (Easy)</h3>
<p>1-to-1 map, similar idea as #205.<br>
(Discussion) Use istringstream to read words from str.</p>
<pre><code>class Solution {
public:
   bool wordPattern(string pattern, string str) {

      unordered_map< char, int > pmap;
      unordered_map< string, int > smap;
      int head( 0 ), tail( 0 ), len( pattern.length() ), i;
      string word;

      for( i = 0; i < len && tail != -1; ++i ){
        tail = str.find( " ", head );
        word = str.substr( head, tail - head );
        head = tail + 1;

        auto ite1( pmap.find( pattern[ i ] ) );
        auto ite2( smap.find( word ) );

        if( ( ite1 == pmap.end() ) != ( ite2 == smap.end() ) )
          return false;
        if( ( ite1 != pmap.end() ) && ( ite2 != smap.end() )
          && ( ite1->second != ite2->second ) ) return false;

        pmap[ pattern[ i ] ] = smap[ word ] = i;
      }

      return i == len && tail == -1;
   }
};
</code></pre>
<p>Runtime: 0 ms</p>

<h3><a name="203" class="anchor" href="#203"></a>#203 Remove Linked List Elements (Easy)</h3>
<p>Use a dummy head node to simplify situation.</p>
<pre><code>class Solution {
public:
   ListNode* removeElements(ListNode* head, int val) {

      ListNode result( 0 ); result.next = head;

      for( auto ptr = &result; ptr->next; ){
        if( ptr->next->val == val ){
          auto tmp( ptr->next->next );
          delete ptr->next;
          ptr->next = tmp;
        }else
          ptr = ptr->next;
      }

      return result.next;
   }
};
</code></pre>
<p>Runtime: 32 ms</p>

<h3><a name="38" class="anchor" href="#38"></a>#38 Count and Say (Easy)</h3>
<p>Use std::stringstream to simplify string manipulation.</p>
<pre><code>class Solution {
public:
   string countAndSay(int n) {

      if( n <= 1 ) return string( "1" );

      stringstream ss;
      string s( "1" );

      while( --n ){

        char pre( '\0' );
        int preCount( 0 );

        for( char cur : s ){
          if( cur != pre ){
              if( preCount ) ss << preCount << pre;
              pre = cur;
              preCount = 1;
          }else
              ++preCount;
        }

        if( preCount ) ss << preCount << pre;
        ss >> s; ss.clear(); ss.str( "" );
      }

      return s;
   }
};
</code></pre>
<p>Runtime: 4 ms</p>

<h3><a name="299" class="anchor" href="#299"></a>#299 Bulls and Cows (Easy)</h3>
<p>Simple counting. Use std::stringstream or std::to_string.</p>
<pre><code>class Solution {
public:
   string getHint(string secret, string guess) {

      stringstream ss;
      int nBulls( 0 ), nCows( 0 );
      int count[ 20 ]{ 0 };
      int len( secret.length() );

      for( int i = 0; i < len; ++i ){
        nBulls += secret[ i ] == guess[ i ] ? 1 : 0;
        ++count[ secret[ i ] - '0' ];
        ++count[ guess[ i ] - '0' + 10 ];
      }

      for( int i = 0; i < 10; ++i ){
        nCows += min( count[ i ], count[ i + 10 ] );
      }

      ss << nBulls << "A" << nCows - nBulls << "B";
      return ss.str();
   }
};
</code></pre>
<p>Runtime: 4 ms</p>

<h3><a name="14" class="anchor" href="#14"></a>#14 Longest Common Prefix (Easy)</h3>
<p>Simple counting.</p>
<pre><code>class Solution {
public:
   string longestCommonPrefix(vector<string>& strs) {

      if( strs.empty() ) return string( "" );

      int nStrs( strs.size() );
      int maxLen( strs[ 0 ].length() );

      for( int i = 1; i < nStrs; ++i ){
        int len( strs[ i ].length() ), j;
        for( j = 0; j < len && j < maxLen; ++j )
          if( strs[ 0 ][ j ] != strs[ i ][ j ] ) break;
        maxLen = j;
      }

      return strs[ 0 ].substr( 0, maxLen );
   }
};
</code></pre>
<p>Runtime: 4 ms</p>

<h3><a name="67" class="anchor" href="#67"></a>#67 Add Binary (Easy)</h3>
<p>Split digits into vector and add.</p>
<pre><code>class Solution {
public:
   string addBinary(string a, string b) {

      vector< int > va, vb;
      string result;

      split( a, va );
      split( b, vb );

      int lenA( va.size() );
      int lenB( vb.size() );

      if( lenA < lenB ){
        va.swap( vb );
        lenA = lenB;
      }
      vb.resize( lenA );
      va.push_back( 0 );

      for( int i = 0; i < lenA; ++i ){
        va[ i + 1 ] += va[ i ] + vb[ i ] >> 1;
        result = ( va[ i ] + vb[ i ] & 1 ? '1' : '0' ) + result;
      }

      return va.back() ? '1' + result : result;
   }

   void split( const string &s, vector< int > &v ){
      for( int i = s.length() - 1; i >= 0; --i ){
        v.push_back( s[ i ] - '0' );
      }
   }
};
</code></pre>
<p>Runtime: 8 ms</p>
(Discussion) More concise code!</p>
<pre><code>class Solution {
public:
   string addBinary(string a, string b) {

      int i( a.length() - 1 );
      int j( b.length() - 1 );
      int carry( 0 );
      string result;

      while( i >= 0 || j >= 0 || carry ){
        carry += i >= 0 && a[ i-- ] - '0' ? 1 : 0;
        carry += j >= 0 && b[ j-- ] - '0' ? 1 : 0;
        result = ( carry & 1 ? '1' : '0' ) + result;
        carry >>= 1;
      }

      return result;
   }
};
</code></pre>
<p>Runtime: 4 ms</p>

<h3><a name="234" class="anchor" href="#234"></a>#234 Palindrome Linked List (Easy)</h3>
<p>Reverse first half and compare.</p>
<pre><code>class Solution {
public:
   bool isPalindrome(ListNode* head) {

      if( head == NULL || head->next == NULL ) return true;

      ListNode dummy( 0 ); dummy.next = head;
      ListNode *fast( &dummy ), *slow( &dummy );
      ListNode *l, *r;

      while( fast->next && fast->next->next ){
        slow = slow->next;
        fast = fast->next->next;
      }

      l = slow; r = slow->next;
      if( fast->next ) r = r->next;
      l->next = NULL;

      for( auto p = &dummy, c = head, n = c->next; ; ){
        c->next = p;
        if( !n ){ head->next = NULL; break; }
        p = c; c = n; n = n->next;
      }

      for( ; l && l->val == r->val; l = l->next, r = r->next );
      return l == NULL;
   }
};
</code></pre>
<p>Runtime: 28 ms</p>

<h3><a name="257" class="anchor" href="#257"></a>#257 Binary Tree Paths (Easy)</h3>
<p>Simple DFS. Use a vector to record nodes on current path.</p>
<pre><code>class Solution {
public:
   vector<string> binaryTreePaths(TreeNode* root) {
      if( root == NULL )
        return vector< string >();
      else{
        traverse( root );
        return vs;
      }
   }

   void traverse( TreeNode *root ){

      vi.push_back( root->val );

      if( root->left == NULL && root->right == NULL ){
        string s;
        for( int i : vi ) s += "->" + to_string( i );
        vs.push_back( s.substr( 2, -1 ) );
      }else{
        if( root->left ) traverse( root->left );
        if( root->right ) traverse( root->right );
      }

      vi.pop_back();
   }

   vector< string > vs;
   vector< int > vi;
};
</code></pre>
<p>Runtime: 8 ms</p>

<h3><a name="303" class="anchor" href="#303"></a>#303 Range Sum Query - Immutable (Easy)</h3>
<p>Precompute suffix sum array, then sumRange( i, j ) = suffixSum( j ) - suffixSum( i - 1 ).</p>
<pre><code>class NumArray {
public:
   NumArray(vector< int > &nums) {
      for( int i = 0; i < nums.size(); ++i )
        v.push_back( v[ i ] + nums[ i ] );
   }

   int sumRange(int i, int j) {
      return  v[ j + 1 ] - v[ i ];
   }

   vector< int > v{ 0 };
};
</code></pre>
<p>Runtime: 596 ms</p>

<h3><a name="28" class="anchor" href="#28"></a>#28 Implement strStr() (Easy)</h3>
<p>Compare by brute force.</p>
<pre><code>class Solution {
public:
   int strStr(string haystack, string needle) {

      int lenH( haystack.length() );
      int lenN( needle.length() );

      if( lenN == 0 ) return 0;
      if( lenH < lenN ) return -1;

      for( int i = 0; i < lenH - lenN + 1; ++i ){
        for( int j = 0; ; ++j ){
          if( haystack[ i + j ] != needle[ j ] ) break;
          if( j == lenN - 1 ) return i;
        }
      }

      return -1;
   }
};
</code></pre>
<p>Runtime: 4 ms</p>

<h3><a name="7" class="anchor" href="#7"></a>#7 Reverse Integer (Easy)</h3>
<p>Mind tricky inputs like INT_MAX, INT_MIN.</p>
<pre><code>class Solution {
public:
   int reverse(int x) {

      if( x == 1 << 31 ) return 0;
      if( x < 0 ) return -reverse( -x );

      long long y( 0LL );

      while( x ){
        y = y * 10LL + x % 10;
        x /= 10;
      }

      return y <= 0x7fffffffLL ? ( int )y : 0;
   }
};
</code></pre>
<p>Runtime: 8 ms</p>

<h3><a name="125" class="anchor" href="#125"></a>#125 Valid Palindrome (Easy)</h3>
<p>Extract alphanumerics and check palindrome.</p>
<pre><code>class Solution {
public:
   bool isPalindrome(string s) {

      string t;
      int len( 0 );

      for( char ch : s ){
        if( ch >= '0' && ch <= '9'
          || ch >= 'a' && ch <= 'z'
          || ch >= 'A' && ch <= 'Z' ){
          t += ch > 'Z' ? ( char )( ch - 32 ) : ch;
          ++len;
        }
      }

      for( int i = 0; i < len >> 1; ++i ){
        if( t[ i ] != t[ len - i - 1 ] ) return false;
      }

      return true;
   }
};
</code></pre>
<p>Runtime: 16 ms</p>

<h3><a name="6" class="anchor" href="#6"></a>#6 ZigZag Conversion (Easy)</h3>
<p>Simple simulation.</p>
<pre><code>class Solution {
public:
   string convert(string s, int numRows) {

      if( s.empty() || numRows < 2 ) return s;

      vector< string > vs( numRows, "" );
      int len( s.length() ), loop( numRows - 1 << 1 );
      string result;

      for( int i = 0, j = 0; i < len; ++i ){
        j = i % loop;
        if( j >= numRows ) j = ( numRows - 1 << 1 ) - j;
        vs[ j ] += s[ i ];
      }

      for( string str : vs ) result += str;

      return result;
   }
};
</code></pre>
<p>Runtime: 48 ms</p>

<h3><a name="204" class="anchor" href="#204"></a>#Count Primes (Easy)</h3>
<p>"Sift" non-primes out using known primes. Mind int range overflow.</p>
<pre><code>class Solution {
public:
   int countPrimes(int n) {

      if( n < 2 ) return 0;

      vector< bool > prime( n, true );
      int result( 0 );

      for( int i = 2; i < n; ++i ){
        if( !prime[ i ] ) continue;
        ++result;
        if( i > 46340 ) continue;
        for( int j = i * i; j < n; j += i ){
          prime[ j ] = false;
        }
      }

      return result;
   }
};
</code></pre>
<p>Runtime: 312 ms</p>

<h3><a name="228" class="anchor" href="#228"></a>#228 Summary Ranges (Easy)</h3>
<p>Simple iteration. Append an end symbol to simplify situation.</p>
<pre><code>class Solution {
public:
   vector<string> summaryRanges(vector< int >& nums) {

      if( nums.empty() ) return vector< string >();

      vector< string > result;
      int nNums( nums.size() );
      int head( 0 ), tail( 0 );

      nums.push_back( nums[ nNums++ - 1 ] );

      for( int i = 1; i < nNums; tail = i++ ){
        if( nums[ i ] != nums[ i - 1 ] + 1 ){
          if( tail - head )
              result.push_back( to_string( nums[ head ] )
                + "->" + to_string( nums[ tail ] ) );
          else
              result.push_back( to_string( nums[ head ] ) );
          head = i;
        }
      }

      return result;
   }
};
</code></pre>
<p>Runtime: 4 ms</p>

<h3><a name="278" class="anchor" href="#278"></a>#278 First Bad Version (Easy)</h3>
<p>Binary search. Mind int range overflow when computing middle.</p>
<pre><code>bool isBadVersion(int version);

class Solution {
public:
   int firstBadVersion(int n) {

      int lower( 1 ), upper( n ), middle;

      while( upper - lower ){
        middle = lower + ( upper - lower >> 1 );
        if( isBadVersion( middle ) )
          upper = middle;
        else
          lower = middle + 1;
      }

      return isBadVersion( upper ) ? upper : 0;
   }
};
</code></pre>
<p>Runtime: 0 ms</p>

<h3><a name="155" class="anchor" href="#155"></a>#155 Min Stack (Easy)</h3>
<p>Use 2 stacks. One for normal use, the other to store mins.</p>
<pre><code>class MinStack {
public:
   void push(int x) {
      if( b.empty() || x <= b.top() ) b.push( x );
      a.push( x );
   }

   void pop() {
      if( b.top() == a.top() ) b.pop();
      a.pop();
   }

   int top() {
      return a.top();
   }

   int getMin() {
      return b.top();
   }

   stack< int > a, b;
};
</code></pre>
<p>Runtime: 28 ms</p>

<h3><a name="168" class="anchor" href="#168"></a>#168 Excel Sheet Column Title (Easy)</h3>
<p>A new type of number with a numeral base of 26.</p>
<pre><code>class Solution {
public:
   string convertToTitle(int n) {

      string result;

      do{
        result = ( char )( --n % 26 + 'A' ) + result;
      }while( n /= 26 );

      return result;
   }
};
</code></pre>
<p>Runtime: 0 ms</p>

<h3><a name="189" class="anchor" href="#189"></a>#189 Rotate Array (Easy)</h3>
<p>Reverse first part, reverse second part, then reverse whole.<br>
Note that k might be greater than size of nums.</p>
<pre><code>class Solution {
public:
   void rotate(vector< int >& nums, int k) {
      if( nums.empty() || ( k %= nums.size() ) < 1 ) return;
      reverse( nums, 0, nums.size() - k - 1 );
      reverse( nums, nums.size() - k, nums.size() - 1 );
      reverse( nums, 0, nums.size() - 1 );
   }

   void reverse( vector< int > &nums, int a, int b ){
      for( int i = 0; i < b - a + 1 >> 1; ++i ){
        auto tmp( nums[ a + i ] );
        nums[ a + i ] = nums[ b - i ];
        nums[ b - i ] = tmp;
      }
   }
};
</code></pre>
<p>Runtime: 4 ms</p>

<h3><a name="165" class="anchor" href="#165"></a>#165 Compare Version Numbers(Easy)</h3>
<p>Use std::istringstream to ease string manipulation.</p>
<pre><code>class Solution {
public:
   int compareVersion(string version1, string version2) {

      for( char &ch : version1 ) ch == '.' ? ch = ' ' : 0;
      for( char &ch : version2 ) ch == '.' ? ch = ' ' : 0;

      int a( 0 ), b( 0 );
      bool getA, getB;
      istringstream iss1( version1 );
      istringstream iss2( version2 );

      while( true ){
        a = b = 0;
        getA = iss1 >> a ? true : false;
        getB = iss2 >> b ? true : false;
        if( !getA && !getB ) return 0;
        if( a != b ) return a > b ? 1 : -1;
      }
   }
};
</code></pre>
<p>Runtime: 0 ms</p>

<h3><a name="8" class="anchor" href="#8"></a>#8 String to Integer (Easy)</h3>
<p>Simple state machine.</p>
<pre><code>class Solution {
public:
   int myAtoi(string str) {

      bool positive( true );
      bool starting( true );
      long long result( 0 );

      for( char ch : str ){
        if( starting ){
          if( ch == ' ' || ch == '\t' )  continue;
          if( ch == '+' || ch == '-' || ch >= '0' && ch <= '9' ){
              if( ch == '-' ) positive = false;
              else if( ch != '+' ) result = ch - '0';
              starting = false;
              continue;
          }
          return 0;
        }else{
          if( ch < '0' || ch > '9' ) break;
          result = result * 10 + ( ch - '0' );
          if( positive && result > 0x7fffffffLL ) return 0x7fffffff;
          if( !positive && result > 0x80000000LL ) return 0x80000000;
        }
      }

      return positive ? ( int )result : ( int )( -result );
   }
};
</code></pre>
<p>Runtime: 8 ms</p>

<h3><a name="136" class="anchor" href="#136"></a>#136 Single Number (Medium)</h3>
<p>Idea similar to qsort. Choose a standard and make left part less than or equal to standard and right part greater than standard. The answer is in the part with odd number of elements.</p>
<pre><code>class Solution {
public:
   int singleNumber(vector< int >& nums) {

      if( nums.empty() ) return 0;

      return find( nums, 0, nums.size() - 1 );
   }

   int find( vector< int > &nums, int l, int r ){

      if( r == l ) return nums[ l ];

      int i( l ), j( r );
      int m( nums[ l + rand() % ( r - l + 1 ) ] );

      while( i < j ){
        while( nums[ i ] <= m ) ++i;
        while( nums[ j ] > m ) --j;
        if( i < j ){
          auto tmp( nums[ i ] );
          nums[ i ] = nums[ j ];
          nums[ j ] = tmp;
        }
      }

      if( i <= r && ( r - i + 1 & 1 ) )
        return find( nums, i, r );
      else
        return find( nums, l, j );
   }
};
</code></pre>
<p>Runtime: 0 ms</p>
<p>(Discussion) XOR! Genius!</p>
<pre><code>class Solution {
public:
   int singleNumber(vector< int >& nums) {

      int result( 0 );

      for( int i : nums ) result ^= i;

      return result;
   }
};
</code></pre>

<h3><a name="260" class="anchor" href="#260"></a>#260 Single Number III (Medium)</h3>
<p>XOR all numbers. Use a bit set of the result to classify all numbers into two parts. The answer is the XOR of each part.</p>
<pre><code>class Solution {
public:
   vector< int > singleNumber(vector< int >& nums) {

      int all( 0 ), first( 0 ), second( 0 );

      for( int i : nums ) all ^= i; all &= -all;
      for( int i : nums ) i & all ? first ^= i : second ^= i;

      return vector< int >{ first, second };
   }
};
</code></pre>
<p>Runtime: 0 ms</p>

<h3><a name="122" class="anchor" href="#122"></a>#122 Best Time to Buy and Sell Stock II (Medium)</h3>
<p>If price today is higher than yesterday, "bought" yesterday and sell today.</p>
<pre><code>class Solution {
public:
   int maxProfit(vector< int >& prices) {

      int result( 0 ), yesterday( 0x7fffffff );

      for( int today : prices ){
        result += today > yesterday ? today - yesterday : 0;
        yesterday = today;
      }

      return result;
   }
};
</code></pre>
<p>Runtime: 12 ms</p>

<h3><a name="238" class="anchor" href="#238"></a>#238 Product of Array Except Self (Medium)</h3>
<p>Use output to store prefix product and nums to store suffix product, then combine them together.</p>
<pre><code>class Solution {
public:
   vector< int > productExceptSelf(vector< int >& nums) {

      vector< int > output( nums.size(), 1 );

      for( int i = 1; i < nums.size(); ++i ){
        output[ i ] = output[ i - 1] * nums[ i - 1 ];
      }

      for( int i = nums.size() - 2; i >= 0; --i ){
        nums[ i ] *= nums[ i + 1 ];
        output[ i ] *= nums[ i + 1 ];
      }

      return output;
   }
};
</code></pre>
<p>Runtime: 60 ms</p>

<h3><a name="144" class="anchor" href="#144"></a>#144 Binary Tree Preorder Traversal (Medium)</h3>
<p>Use stack to solve it iteratively.</p>
<pre><code>class Solution {
public:
   vector< int > preorderTraversal(TreeNode* root) {

      if( root == NULL ) return vector< int >();

      vector< int > result;
      stack< TreeNode * > mstack;
      TreeNode *pNode;

      mstack.push( root );

      while( !mstack.empty() ){
        pNode = mstack.top();
        mstack.pop();
        result.push_back( pNode->val );
        if( pNode->right ) mstack.push( pNode->right );
        if( pNode->left ) mstack.push( pNode->left );
      }

      return result;
   }

};
</code></pre>
<p>Runtime: 0 ms</p>

<h3><a name="319" class="anchor" href="#319"></a>#319 Bulb Switcher (Medium)</h3>
<p>Lights at positions of perfect square will be on.</p>
<pre><code>class Solution {
public:
   int bulbSwitch(int n) {
      return ( int )sqrt( n + 0. );
   }
};
</code></pre>
<p>Runtime: 0 ms</p>

<h3><a name="94" class="anchor" href="#94"></a>#94 Binary Tree Inorder Traversal (Medium)</h3>
<p>Use stack to solve it iteratively. Add a flag to indicate inorder.</p>
<pre><code>class Solution {
public:
   vector< int > inorderTraversal(TreeNode* root) {

      if( root == NULL ) return vector< int >();

      vector< int > result;
      stack< pair< TreeNode *, bool > > mstack;
      bool inorder;

      mstack.push( make_pair( root, false ) );

      while( !mstack.empty() ){
        root = mstack.top().first;
        inorder = mstack.top().second;
        mstack.pop();
        if( inorder ){ result.push_back( root->val ); continue; }
        if( root->right ) mstack.push( make_pair( root->right, false ) );
        mstack.push( make_pair( root, true ) );
        if( root->left ) mstack.push( make_pair( root->left, false ) );
      }

      return result;
   }
};
</code></pre>
<p>Runtime: 0 ms</p>

<h3><a name="268" class="anchor" href="#268"></a>#268 Missing Number (Medium)</h3>
<p>All Hail XOR!!</p>
<pre><code>class Solution {
public:
   int missingNumber(vector< int >& nums) {

      int result( 0 );

      for( int i = 0; i <= nums.size(); ++i ) result ^= i;
      for( int i : nums ) result ^= i;

      return result;
   }
};
</code></pre>
<p>Runtime: 36 ms</p>

<h3><a name="318" class="anchor" href="#318"></a>#318 Maximum Product of Word Lengths (Medium)</h3>
<p>Use bitset to indicate letter usage. Compare by brute force.</p>
<pre><code>class Solution {
public:
   int maxProduct(vector<string>& words) {

      int hash( 0 ), result( 0 );
      int nWords( words.size() );
      vector< pair< int, int > > vp;

      for( const string &str : words ){
        hash = 0;
        for( const char &ch : str ) hash |= 1 << ch - 'a';
        vp.push_back( make_pair( hash, str.length() ) );
      }

      for( int i = 0; i < nWords - 1; ++i ){
        for( int j = i + 1; j < nWords; ++j ){
          if( vp[ i ].first & vp[ j ].first != 0 ) continue;
          result = max( result, vp[ i ].second * vp[ j ].second );
        }
      }

      return result;
   }
};
</code></pre>
<p>Runtime: 148 ms</p>

<h3><a name="" class="anchor" href="#"></a># (Medium)</h3>
<p>Fast pointer walks twice as fast as slow pointer. There is a loop if fast one meets slow one before it meets end.</p>
<pre><code>class Solution {
public:
   bool hasCycle(ListNode *head) {

      if( head == NULL ) return false;

      ListNode *slow( head ), *fast( head->next );

      while( fast && slow != fast ){
        slow = slow->next;
        fast = fast->next;
        if( fast == NULL ) return false;
        fast = fast->next;
      }

      return fast != NULL;
   }
};
</code></pre>
<p>Runtime: 12 ms</p>

<h3><a name="137" class="anchor" href="#137"></a>#137 Single Number II (Medium)</h3>
<p>Can be solved similarly to #136.</p>
<p>(Discussion)Crazy XOR!!</p>
<pre><code>class Solution {
public:
   int singleNumber(vector< int >& nums) {

      int ones( 0 ), twos( 0 );

      for( int x : nums ){
        ones ^= x & ~twos;
        twos ^= x & ~ones;
      }

      return ones;
   }
};
</code></pre>
<p>Runtime: 12 ms</p>

<h3><a name="116" class="anchor" href="#116"></a>#116 Populating Next Right Pointers in Each Node (Medium)</h3>
<p>Next of a left child is its parent's right child. Next of a right child is its parent's next node's left child. So we should populate the tree from right to left.</p>
<pre><code>class Solution {
public:
   void connect(TreeLinkNode *root) {
      traverse( root, NULL, RIGHT );
   }

   void traverse( TreeLinkNode *root, TreeLinkNode *parent, int flag ){

      if( root == NULL ) return;
      if( parent != NULL ){
        if( flag == LEFT ){
          root->next = parent->right;
        }else if( parent->next != NULL ){
          root->next = parent->next->left;
        }else{
          root->next = NULL;
        }
      }else{
        root->next = NULL;
      }

      traverse( root->right, root, RIGHT );
      traverse( root->left, root, LEFT );
   }

   static const int LEFT = 0;
   static const int RIGHT = 1;
};
</code></pre>
<p>Runtime: 24 ms</p>

<h3><a name="108" class="anchor" href="#108"></a>#108 Convert Sorted Array to Binary Search Tree (Medium)</h3>
<p>Recursively build tree using first half for left subtree and the other half for right subtree.</p>
<pre><code>class Solution {
public:
   TreeNode* sortedArrayToBST(vector< int >& nums) {
      return buildTree( nums, 0, nums.size() - 1 );
   }

   TreeNode* buildTree( vector< int > &nums, int l, int r ){

      if( l > r ) return NULL;

      int m( r + l + 1 >> 1 );
      TreeNode *root = new TreeNode( nums[ m ] );
      root->left = buildTree( nums, l, m - 1 );
      root->right = buildTree( nums, m + 1, r );

      return root;
   }
};
</code></pre>
<p>Runtime: 16 ms</p>

<h3><a name="53" class="anchor" href="#53"></a>#53 Maximum Subarray (Medium)</h3>
<p>Greedy strategy. Add current number to sum. Set sum to zero if it is less than zero.</p>
<pre><code>class Solution {
public:
   int maxSubArray(vector< int >& nums) {

      int result( 1 << 31 ), sum( 0 );

      for( int i : nums ){
        sum += i;
        result = max( result, sum );
        sum < 0 ? sum = 0 : 0;
      }

      return result;
   }
};
</code></pre>
<p>Runtime: 12 ms</p>

<h3><a name="153" class="anchor" href="#153"></a>#153 Find Minimum in Rotated Sorted Array (Medium)</h3>
<p>Binary search.</p>
<pre><code>class Solution {
public:
   int findMin(vector< int >& nums) {

      int lower( 0 ), upper( nums.size() - 1 ), middle;

      while( upper - lower ){
        middle = lower + ( upper - lower >> 1 );
        if( nums[ middle ] <= nums[ upper ] )
          upper = middle;
        else
          lower = middle + 1;
      }

      return nums[ upper ];
   }
};
</code></pre>
<p>Runtime: 4 ms</p>

<h3><a name="22" class="anchor" href="#22"></a>#22 Generate Parentheses (Medium)</h3>
<p>Recursively generate.</p>
<pre><code>class Solution {
public:
   vector<string> generateParenthesis(int n) {

      result.clear();
      generate( "", 0, n );

      return result;
   }

   void generate( string str, int m, int n ){
      if( !n ){ result.push_back( str + string( m, ')' ) ); return; }
      if( m ) generate( str + ")", m - 1, n );
      generate( str + "(", m + 1, n - 1 );
   }

   vector< string > result;
};
</code></pre>
<p>Runtime: 0 ms</p>

<h3><a name="62" class="anchor" href="#62"></a>#62 Unique Paths (Medium)</h3>
<p>Since grid(i,j) can be reached from grid(i-1,j) or grid(i,j-1), thus f[i,j] = f[i-1,j] + f[i,j-1]. Can use only an 1*n or m*1 array.</p>
<pre><code>class Solution {
public:
   int uniquePaths(int m, int n) {

      vector< int > vi( n, 1 );

      for( int i = 1; i < m; ++i ){
        for( int j = 1; j < n; ++j ){
          vi[ j ] += vi[ j - 1 ];
        }
      }

      return vi[ n - 1 ];
   }
};
</code></pre>
<p>Runtime: 0 ms</p>

<h3><a name="89" class="anchor" href="#89"></a>#89 Gray Code (Medium)</h3>
<p>First half is symmetric to second half except that LSB of first half is 0 while second half is 1.</p>
<pre><code>class Solution {
public:
   vector< int > grayCode(int n) {

      vector< int > vi{ 0 };

      for( int i = 0; i < n; ++i ){
        for( int j = vi.size() - 1; j >=0; --j ){
          vi.push_back( 1 << i | vi[ j ] );
        }
      }

      return vi;
   }
};
</code></pre>
<p>Runtime: 8 ms</p>

<h3><a name="230" class="anchor" href="#230"></a>#230 Kth Smallest Element in a BST (Medium)</h3>
<p>Recursively count number of nodes of tree and find kth smallest element.</p>
<pre><code>class Solution {
public:
   int kthSmallest(TreeNode* root, int k) {

      int nNodes;

      return kthAndNNodes( root, k, nNodes );
   }

   int kthAndNNodes( TreeNode *root, int k, int &nNodes ){

      if( root == NULL ) return 0;

      int nLNodes( 0 ), nRNodes( 0 ), result;

      result = kthAndNNodes( root->left, k, nLNodes );
      nNodes = nLNodes;
      if( k <= nNodes ) return result;

      nNodes += 1;
      if( k <= nNodes ) return root->val;

      result = kthAndNNodes( root->right, k - nNodes, nRNodes );
      nNodes += nRNodes;
      return result;
   }
};
</code></pre>
<p>Runtime: 0 ms</p>

<h3><a name="309" class="anchor" href="#309"></a>#309 Best Time to Buy and Sell Stock with Cooldown (Medium)</h3>
<p>DP on state machine:<br>
State A: can buy (goto B) or rest (goto A):   A[i] = max( A[i-1], C[i-1] ).<br>
State B: can sell (goto C) or rest (goto B): B[i] = max( B[i-1], A[i-1] - today's price ).<br>
State C: can rest (goto A) only: C[i] = max( C[i-1], B[i-1] + today's price ).
</p>
<pre><code>class Solution {
public:
   int maxProfit(vector< int >& prices) {

      int nPrices( prices.size() );
      vector< int > a( nPrices + 1, 0 );
      vector< int > b( nPrices + 1, 1 << 31 );
      vector< int > c( nPrices + 1, 1 << 31 );

      for( int i = 1; i <= nPrices; ++i ){
        a[ i ] = max( a[ i - 1 ], c[ i - 1 ] );
        b[ i ] = max( b[ i - 1 ], a[ i - 1 ] - prices[ i - 1 ] );
        c[ i ] = max( c[ i - 1 ], b[ i - 1 ] + prices[ i - 1 ] );
      }

      return max( a[ nPrices ], c[ nPrices ] );
   }
};
</code></pre>
<p>Runtime: 0 ms</p>

<h3><a name="46" class="anchor" href="#46"></a>#46 Permutations (Medium)</h3>
<p>Permutations of n numbers can be generated by inserting nth number into permutations of n-1 numbers.</p>
<pre><code>class Solution {
public:
   vector< vector< int > > permute(vector< int >& nums) {

      N = nums.size();
      vi.clear();
      vi.push_back( 0 );
      result.clear();
      generatePermutations();

      for( auto &i : result )
        for( auto &j: i )
          j = nums[ j ];

      return result;
   }

   void generatePermutations(){

      if( vi.size() == N ){
        result.push_back( vi );
        return;
      }

      vi.push_back( vi.size() );
      generatePermutations();
      for( int i = vi.size() - 1; i; --i ){
        swap( vi[ i ], vi[ i - 1 ] );
        generatePermutations();
      }
      for( int i = 0; i < vi.size() - 1; ++i )
        vi[ i ] = vi[ i + 1 ];
      vi.pop_back();
   }

   void swap( int &a, int &b ){
      auto c = a; a = b; b = c;
   }

   int N;
   vector< int > vi;
   vector< vector< int > > result;
};
</code></pre>
<p>Runtime: 16 ms</p>

<h3><a name="96" class="anchor" href="#96"></a>#96 Unique Binary Search Trees (Medium)</h3>
<p>Let F[n] denote the number of different BSTs that store 1..n, and number of trees rooted at ith number is F[i-1] (number of left subtrees) times F[n-i] (number of right subtrees).<br>
Thus, F[n] = F[0]*F[n-1] + F[1]*F[n-2] +...+ F[n-1]*F[0], where F[0] = 1.</p>
<pre><code>class Solution {
public:
   int numTrees(int n) {

      vector< int > vi{ 1 };

      for( int i = 1; i <= n; ++i ){
        vi.push_back( 0 );
        for( int j = 0; j < i; ++j ){
          vi[ i ] += vi[ j ] * vi[ i - j - 1 ];
        }
      }

      return vi.back();
   }
};
</code></pre>
<p>Runtime: 0 ms</p>

<h3><a name="35" class="anchor" href="#35"></a>#35 Search Insert Position (Medium)</h3>
<p>Simple binary search. Mind edge case.</p>
<pre><code>class Solution {
public:
   int searchInsert(vector< int >& nums, int target) {

      if( target > nums.back() ) return nums.size();

      int lower( 0 ), upper( nums.size() - 1 ), middle;

      while( upper - lower ){
        middle = lower + ( upper - lower >> 1 );
        if( nums[ middle ] < target )
          lower = middle + 1;
        else
          upper = middle;
      }

      return upper;
   }
};
</code></pre>
<p>Runtime: 8 ms</p>

<h3><a name="121" class="anchor" href="#121"></a>#121 Best Time to Buy and Sell Stock (Medium)</h3>
<p>Record the lowest price before today and calculate profit you can make if you sell today. Maximize the profit.</p>
<pre><code>class Solution {
public:
   int maxProfit(vector< int >& prices) {

      int minBefore( 1 << 30 ), result( 0 );

      for( int today : prices ){
        result = max( result, today - minBefore );
        minBefore = min( minBefore, today );
      }

      return result;
   }
};
</code></pre>
<p>Runtime: 12 ms</p>

<h3><a name="24" class="anchor" href="#24"></a>#24 Swap Nodes in Pairs (Medium)</h3>
<p>Linked list manipulation.</p>
<pre><code>class Solution {
public:
   ListNode* swapPairs(ListNode* head) {

      ListNode dummy( 0 ); dummy.next = head;

      for( auto pNode = &dummy; pNode; pNode = pNode->next->next ){
        if( !pNode->next || !pNode->next->next ) break;
        auto pNN( pNode->next->next );
        pNode->next->next = pNN->next;
        pNN->next = pNode->next;
        pNode->next = pNN;
      }

      return dummy.next;
   }
};
</code></pre>
<p>Runtime: 4 ms</p>

<h3><a name="12" class="anchor" href="#12"></a>#12 Integer to Roman (Medium)</h3>
<p>Add "M" to make x less than 1000.<br>
For x within [100,1000): <br>
- if x >= 900, add "CM", x -= 900;<br>
- else if x >= 500, add "D", x -= 500;<br>
- else if x >= 400, add "CD", x -= 400;<br>
- else if x >= 100, add "C", x -= 100.<br>
Similarly for x within [10,100) and [1,10).</p>
<pre><code>class Solution {
public:
   string intToRoman(int num) {

      static const vector< pair< char, int > > vp{
        { 'I', 1 }, { 'V', 5 }, { 'X', 10 }, { 'L', 50 },
        { 'C', 100, }, { 'D', 500 },  { 'M', 1000 },
      };

      string result( num / 1000, 'M' ); num %= 1000;
      int size( 9 );

      while( num && ( size -= 2 ) ){
        if( num >= vp[ size - 1 ].second - vp[ size - 3 ].second ){
          num -= vp[ size - 1 ].second - vp[ size - 3 ].second;
          result += vp[ size - 3 ].first;
          result += vp[ size - 1 ].first;
        }else if( num >= vp[ size - 2 ].second ){
          num -= vp[ size - 2 ].second;
          result += vp[ size - 2 ].first;
        }else if( num >= vp[ size - 2 ].second - vp[ size - 3 ].second ){
          num -= vp[ size - 2 ].second - vp[ size - 3 ].second;
          result += vp[ size - 3 ].first;
          result += vp[ size - 2 ].first;
        }
        while( num >= vp[ size - 3 ].second ){
          num -= vp[ size - 3 ].second;
          result += vp[ size - 3 ].first;
        }
      }

      return result;
   }
};
</code></pre>
<p>Runtime: 36 ms</p>
<p>(Discussion) Use a table!<br>
<pre><code>public static String intToRoman(int num) {
   String M[]{"", "M", "MM", "MMM"};
   String C[]{"", "C", "CC", "CCC", "CD", "D", "DC", "DCC", "DCCC", "CM"};
   String X[]{"", "X", "XX", "XXX", "XL", "L", "LX", "LXX", "LXXX", "XC"};
   String I[]{"", "I", "II", "III", "IV", "V", "VI", "VII", "VIII", "IX"};
   return M[num/1000] + C[(num%1000)/100] + X[(num%100)/10] + I[num%10];
}
</code></pre>

<h3><a name="75" class="anchor" href="#75"></a>#75 Sort Colors (Medium)</h3>
<p>Simple counting.</p>
<pre><code>class Solution {
public:
   void sortColors(vector< int >& nums) {

       int count[]{ 0, 0, 0, };

       for( int &num : nums ) ++count[ num ];
       for( int i = 0, j = 0; i < 3; ++i ){
          while( count[ i ]-- ) nums[ j++ ] = i;
       }
   }
};
</code></pre>
<p>Runtime: 4 ms</p>

<h3><a name="64" class="anchor" href="#64"></a>#64 Minimum Path Sum (Medium)</h3>
<p>DP: F[i,j] = min( F[i-1,j], F[i,j-1] ).</p>
<pre><code>class Solution {
public:
   int minPathSum(vector< vector< int > >& grid) {

       int m( grid.size() ), n( grid[ 0 ].size() ), tmp;

       for( int i = 1; i < m; ++i ) grid[ i ][ 0 ] += grid[ i - 1 ][ 0 ];
       for( int i = 1; i < n; ++i ) grid[ 0 ][ i ] += grid[ 0 ][ i - 1 ];
       for( int i = 1; i < m; ++i ) for( int j = 1; j < n; ++j )
          grid[ i ][ j ] += min( grid[ i - 1 ][ j ], grid[ i ][ j - 1 ] );

       return grid[ m - 1 ][ n - 1 ];
   }
};
</code></pre>
<p>Runtime: 28 ms</p>

<h3><a name="48" class="anchor" href="#48"></a>#48 Rotate Image (Medium)</h3>
<p>Flip along middle vertical, then flip along topright-bottomleft diagonal.</p>
<pre><code>class Solution {
public:
   void rotate(vector< vector< int > >& matrix) {

       int n( matrix.size() );

       for( int i = 0; i < n; ++i ) for( int j = 0; j < n >> 1; ++j )
          swap( matrix[ i ][ j ], matrix[ i ][ n - j - 1 ] );
       for( int i = 0; i < n; ++i ) for( int j = 0; j < n - i - 1; ++j )
          swap( matrix[ i ][ j ], matrix[ n - j - 1 ][ n - i - 1 ]);
   }
};
</code></pre>
<p>Runtime: 4 ms</p>

<h3><a name="59" class="anchor" href="#59"></a>#59 Spiral Matrix II (Medium)</h3>
<p>Simple simulation.</p>
<pre><code>class Solution {
public:
    vector< vector< int > > generateMatrix(int n) {

       static const int dx[]{ 0, 1, 0, -1 };
       static const int dy[]{ 1, 0, -1, 0 };

       int step( n ), x( 0 ), y( -1 ), k( 1 );
       vector< vector< int > > result( n, vector< int >( n, 0 ) );

       while( step ){
          for( int i = 0; i < 4; ++i ){
              for( int j = 0; j < step; ++j )
                  result[ x += dx[ i ] ][ y += dy[ i ] ] = k++;
              if( ( i & 1 ) == 0 && --step == 0 ) break;
          }
       }

       return result;
   }
};
</code></pre>
<p>Runtime: 4 ms</p>

<h3><a name="11" class="anchor" href="#11"></a>#11 Container With Most Water (Medium)</h3>
<p>Assume the answer is formed by line i and j, we can be sure that H[i] > H[k] where k > j, and H[j] > H[k] where k < i, so we can shrink left and right borders to cover the answer situation.</p>
<pre><code>class Solution {
public:
   int maxArea(vector< int >& height) {

       int water( 0 );

       for( int i = 0, j = height.size() - 1; i < j; ){
          water = max( water, min( height[ i ], height[ j ] ) * ( j - i ) );
          height[ i ] < height[ j ] ? ++i : --j;
       }

       return water;
   }
};
</code></pre>
<p>Runtime: 24 ms</p>

<h3><a name="216" class="anchor" href="#216"></a>#216 Combination Sum III (Medium)</h3>
<p>Recursively generate.</p>
<pre><code>class Solution {
public:
   vector< vector< int > > combinationSum3(int k, int n) {

       N = n;
       K = k;
       v.clear();
       result.clear();
       generate( 0, 0, 0 );

       return result;
   }

   void generate( int num, int sum, int last ){

       if( num == K || sum == N ){
          if( num == K && sum == N ) result.push_back( v );
          return ;
       }

       for( int i = last + 1; i <= N - sum && i <= 9; ++i ){
          v.push_back( i );
          generate( num + 1, sum + i, i );
          v.pop_back();
       }
   }

   int N, K;
   vector< int > v;
   vector< vector< int > > result;
};
</code></pre>
<p>Runtime: 0 ms</p>

<h3><a name="74" class="anchor" href="#74"></a>#74 Search a 2D Matrix (Medium)</h3>
<p>Treat the matrix as array and use binary search.</p>
<pre><code>class Solution {
public:
    bool searchMatrix(vector< vector< int > >& matrix, int target) {

        int M( matrix.size() ), N( matrix[ 0 ].size() );
        int lower( 0 ), upper( M * N - 1 ), middle, i, j;

        while( upper - lower ){
            middle = lower + ( upper - lower >> 1 );
            if( matrix[ middle / N ][ middle % N ] >= target )
                upper = middle;
            else
                lower = middle + 1;
        }

        return matrix[ upper / N ][ upper % N ] == target;
    }
};
</code></pre>
<p>Runtime: 16 ms</p>

<h3><a name="289" class="anchor" href="#289"></a>#289 Game of Life (Medium)</h3>
<p>Simple simulation. Use second LSB to record new state to solve it in-place.</p>
<pre><code>class Solution {
public:
    void gameOfLife(vector< vector< int > >& board) {

        if( board.empty() || board[ 0 ].empty() ) return;

        static const int dx[]{ -1, -1, -1, 0, 1, 1, 1, 0 };
        static const int dy[]{ -1, 0, 1, 1, 1, 0, -1, -1 };

        int M( board.size() ), N( board[ 0 ].size() ), x, y;

        for( int i = 0; i < M; ++i ){
            for( int j = 0; j < N; ++j ){
                int lives( 0 );
                for( int k = 0; k < 8; ++k ){
                    x = i + dx[ k ]; y = j + dy[ k ] ;
                    if( x >= 0 && x < M && y >= 0 && y < N )
                        lives += board[ x ][ y ] & 1;
                }
                if( lives == 2 )
                    board[ i ][ j ] |= board[ i ][ j ] << 1;
                else if( lives == 3 )
                    board[ i ][ j ] |= 2;
            }
        }

        for( auto &i : board ) for( auto &j : i ) j >>= 1;
    }
};
</code></pre>
<p>Runtime: 0 ms</p>

<h3><a name="77" class="anchor" href="#77"></a>#77 Combinations (Medium)</h3>
<p>Recursively generate.</p>
<pre><code>class Solution {
public:
    vector< vector< int > > combine(int n, int k) {

        N = n; K = k;
        v.clear();
        vv.clear();
        generate( 0, 0 );

        return vv;
    }

    void generate( int num, int last ){

        if( num == K ){ vv.push_back( v ); return; }

        for( int i = last + 1; i <= N; ++i ){
            v.push_back( i );
            generate( num + 1, i );
            v.pop_back();
        }
    }

    int N, K;
    vector< int > v;
    vector< vector< int > > vv;
};
</code></pre>
<p>Runtime: 12 ms</p>

<h3><a name="162" class="anchor" href="#162"></a>#162 Find Peak Element (Medium)</h3>
<p>Ternary search.</p>
<pre><code>class Solution {
public:
    int findPeakElement(vector< int >& nums) {

        int lower( 0 ), upper( nums.size() - 1 );
        int first, second, result;

        while( upper - lower > 2 ){
            first = lower + ( upper - lower ) / 3;
            second = upper - first + lower;
            nums[ first ] < nums[ second ] ? lower = first : upper = second;
        }

        result = lower;
        if( upper - lower > 0 ) result =
            nums[ result ] > nums[ lower + 1 ] ? result : lower + 1;
        if( upper - lower > 1 ) result =
            nums[ result ] > nums[ lower + 2 ] ? result : lower + 2;

        return result;
    }
};
</code></pre>
<p>Runtime: 8 ms</p>

<h3><a name="73" class="anchor" href="#73"></a>#73 Set Matrix Zeroes (Medium)</h3>
<p>The idea is to find a row containing zero, and use it to mark columns to be set to zeroes.</p>
<pre><code>class Solution {
public:
    void setZeroes(vector< vector< int > >& matrix) {

        int zeroRow( -1 );
        int M( matrix.size() ), N( matrix[ 0 ].size() );

        for( int i = 0; i < M; ++i )
            for( int j = 0; j < N; ++j )
                if( matrix[ i ][ j ] == 0 ){ zeroRow = i; i = M; break; }

        if( zeroRow == -1 ) return;

        for( int i = 0; i < M; ++i )
            for( int j = 0; j < N; ++j )
                if( matrix[ i ][ j ] == 0 )
                    matrix[ zeroRow ][ j ] = 0;

        for( int i = 0; i < M; ++i ){
            if( i == zeroRow ) continue;
            for( int j = 0; j < N; ++j ){
                if( matrix[ i ][ j ] ) continue;
                for( int &k : matrix[ i ] ) k = 0;
                break;
            }
        }

        for( int j = 0; j < N; ++j ){
            if( matrix[ zeroRow ][ j ] ) continue;
            for( int i = 0; i < M; ++i )
                matrix[ i ][ j ] = 0;
        }

        for( int &i : matrix[ zeroRow ] ) i = 0;
    }
};
</code></pre>
<p>Runtime: 88 ms</p>

<h3><a name="300" class="anchor" href="#300"></a>#300 Longest Increasing Subsequence (Medium)</h3>
<p>Maintain a ascending list of numbers and use binary search to insert new number.</p>
<pre><code>class Solution {
public:
    int lengthOfLIS(vector< int >& nums) {

        vector< int > v{ 1 << 31 };

        for( int num : nums ) insert( v, num );

        return v.size() - 1;
    }

    void insert( vector< int > &v, int x ){

        if( x > v.back() ){ v.push_back( x ); return; }

        int lower( 0 ), upper( v.size() - 1 ), middle;

        while( upper - lower ){
            middle = lower + ( upper - lower >> 1 );
            v[ middle ] >= x ? upper = middle : lower = middle + 1;
        }

        v[ upper ] = x;
    }
};
</code></pre>
<p>Runtime: 4 ms</p>

<h3><a name="284" class="anchor" href="#284"></a>#284 Peeking Iterator (Medium)</h3>
<p>Create a copy of this iterator and use it to call next().</p>
<pre><code>class PeekingIterator : public Iterator {
public:
    PeekingIterator(const vector< int >& nums) : Iterator(nums) {
    }

    int peek() {
        Iterator iterator( *this );
        return iterator.next();
    }

    int next() {
        return Iterator::next();
    }

    bool hasNext() const {
        return Iterator::hasNext();
    }
};
</code></pre>
<p>Runtime: 4 ms</p>

<h3><a name="173" class="anchor" href="#173"></a>#173 Binary Search Tree Iterator (Medium)</h3>
<p>Use a stack to implement pre-order traversal.</p>
<pre><code>class BSTIterator {
public:
    BSTIterator(TreeNode *root) {
        if( root ) vp.push( make_pair( root, false ) );
    }

    /** @return whether we have a next smallest number */
    bool hasNext() {
        return !vp.empty();
    }

    /** @return the next smallest number */
    int next() {

        auto top( vp.top() ); vp.pop();

        while( !top.second ){
            if( top.first->right ) vp.push( make_pair( top.first->right, false ) );
            vp.push( make_pair( top.first, true ) );
            if( top.first->left ) vp.push( make_pair( top.first->left, false ) );
            top = vp.top(); vp.pop();
        }

        return top.first->val;
    }

    stack< pair< TreeNode *, bool > > vp;
};
</code></pre>
<p>Runtime: 32 ms</p>

<h3><a name="240" class="anchor" href="#240"></a>#240 Search a 2D Matrix II (Medium)</h3>
<p>Perform binary search twice.</p>
<pre><code>class Solution {
public:
    bool searchMatrix(vector< vector< int > >& matrix, int target) {

        int m( 0 ), M( matrix.size() );
        int n( -1 ), N( matrix[ 0 ].size() );
        int lower, upper, mid;

        while( ++n < N ){
            lower = 0; upper = M - 1;
            while( upper - lower ){
                mid = lower + ( upper - lower + 1 >> 1 );
                matrix[ mid ][ n ] > target ? ( upper = mid - 1 ) : ( lower = mid );
            }
            if( matrix[ m = upper ][ n ] == target ) return true;

            lower = n; upper = N - 1;
            while( upper - lower ){
                mid = lower + ( upper - lower + 1 >> 1 );
                matrix[ m ][ mid ] > target ? ( upper = mid - 1 ) : ( lower = mid );
            }
            if( matrix[ m ][ n = upper ] == target ) return true;
        }
    }
};
</code></pre>
<p>Runtime: 360 ms</p>
<p>(Discussion) Different solution. Not necessarily faster.</p>
<pre><code>class Solution {
public:
    bool searchMatrix(vector< vector< int > >& matrix, int target) {

        int M( matrix.size() ), m( 0 );
        int N( matrix[ 0 ].size() ), n( N - 1 );

        while( m < M && n >= 0 ){
            if( matrix[ m ][ n ] == target ) return true;
            matrix[ m ][ n ] > target ? --n : ++m;
        }

        return false;
    }
};
</code></pre>
<p>Runtime: 360 ms</p>

<h3><a name="199" class="anchor" href="#199"></a>#199 Binary Tree Right Side View (Medium)</h3>
<p>Traverse right subtree first then left subtree. Record first met node of each layer.</p>
<pre><code>class Solution {
public:
    vector< int > rightSideView(TreeNode* root) {

        v.clear();
        if( root ) traverse( root, 1 );

        return v;
    }

    void traverse( TreeNode *root, int depth ){
        if( depth > v.size() ) v.push_back( root->val );
        if( root->right ) traverse( root->right, depth + 1 );
        if( root->left ) traverse( root->left, depth + 1 );
    }

    vector< int > v;
};
</code></pre>
<p>Runtime: 4 ms</p>

<h3><a name="274" class="anchor" href="#274"></a>#274 H-Index (Medium)</h3>
<p>Sort citations and perform binary search.</p>
<pre><code>class Solution {
public:
    int hIndex(vector< int >& citations) {

        if( citations.empty() ) return 0;

        sort( citations.begin(), citations.end() );

        int nCitations( citations.size() );
        int lower( 0 ), upper( citations.back() ), mid;

        while( upper - lower ){
            mid = lower + ( upper - lower + 1 >> 1 );
            if( nCitations - find( citations, mid ) >= mid )
                lower = mid;
            else
                upper = mid - 1;
        }

        return upper;
    }

    int find( vector< int > &v, int x ){
        int lower( 0 ), upper( v.size() - 1 ), mid;
        while( upper - lower ){
            mid = lower + ( upper - lower >> 1 );
            v[ mid ] < x ? lower = mid + 1 : upper = mid;
        }
        return upper;
    }
};
</code></pre>
<p>Runtime: 4 ms</p>
<p>(Discussion) Citations greater that n can be treated as n.</p>
<pre><code>class Solution {
public:
    int hIndex(vector< int >& citations) {

        if( citations.empty() ) return 0;

        int N( citations.size() );
        vector< int > v( N + 1, 0 );

        for( int i : citations ) i > N ? ++v[ N ] : ++v[ i ];
        for( int i = N, j = 0; i >= 0; --i )
            if( ( j += v[ i ] ) >= i ) return i;
    }
};
</code></pre>
<p>Runtime: 4 ms</p>

<h3><a name="275" class="anchor" href="#275"></a>#275 H-Index II (Medium)</h3>
<p>Binary search.</p>
<pre><code>class Solution {
public:
    int hIndex(vector< int >& citations) {

        if( citations.empty() ) return 0;
        if( citations.back() == 0 ) return 0;

        int nCitations( citations.size() );
        int lower( 1 ), upper( nCitations ), mid;

        while( upper - lower ){
            mid = lower + ( upper - lower + 1 >> 1 );
            if( mid <= citations[ nCitations - mid ] )
                lower = mid;
            else
                upper = mid - 1;
        }

        return upper;
    }
};
</code></pre>
<p>Runtime: 12 ms</p>

<h3><a name="80" class="anchor" href="#80"></a>#80 Remove Duplicates from Sorted Array II (Medium)</h3>
<p>If the current number is equal to the third number from the current one, do not add it to result.</p>
<pre><code>class Solution {
public:
    int removeDuplicates(vector< int >& nums) {

        int nNums( nums.size() ), j( 0 );

        for( int i = 0; i < nNums; ++i ){
            if( i + 2 < nNums && nums[ i ] == nums[ i + 2 ] ) continue;
            nums[ j++ ] = nums[ i ];
        }

        return j;
    }
};
</code></pre>
<p>Runtime: 20 ms</p>

<h3><a name="200" class="anchor" href="#200"></a>#200 Number of Islands (Medium)</h3>
<p></p>
<pre><code>class Solution {
public:
    int numIslands(vector< vector<char>>& grid) {

        if( grid.empty() || grid[ 0 ].empty() ) return 0;

        static const int dx[]{ -1, 0, 1, 0 };
        static const int dy[]{ 0, 1, 0, -1 };

        int M( grid.size() );
        int N( grid[ 0 ].size() );
        int result( 0 );

        for( int i = 0; i < M; ++i ){
            for( int j = 0; j < N; ++j ){
                if( grid[ i ][ j ] == '0' ) continue;
                ++result; grid[ i ][ j ] = '0';
                mqueue.push( make_pair( i, j ) );
                while( !mqueue.empty() ){
                    for( int k = 0; k < 4; ++k ){
                        int x( mqueue.front().first + dx[ k ] );
                        int y( mqueue.front().second + dy[ k ] );
                        if( x < 0 || x >= M || y < 0 || y >= N ) continue;
                        if( grid[ x ][ y ] == '0' ) continue;
                        grid[ x ][ y ] = '0';
                        mqueue.push( make_pair( x, y ) );
                    }
                    mqueue.pop();
                }
            }
        }

        return result;
    }

    queue< pair< int, int > > mqueue;
};
</code></pre>
<p>Runtime: 16 ms</p>

<h3><a name="241" class="anchor" href="#241"></a>#241 Different Ways to Add Parentheses (Medium)</h3>
<p>DFS.</p>
<pre><code>[ugly code]
</code></pre>
<p>Runtime: 4 ms</p>

<h3><a name="142" class="anchor" href="#142"></a>#142 Linked List Cycle II (Medium)</h3>
<p>Fast pointer walks twice as fast as slow pointer. When they meet, let one of them point to head then they walk at same speed. The entry is where they meet.</p>
<pre><code>class Solution {
public:
    ListNode *detectCycle(ListNode *head) {

        ListNode dummy( 0 ); dummy.next = head;
        ListNode *slow( &dummy ), *fast( &dummy );

        while( fast == &dummy || fast && slow != fast ){
            slow = slow->next;
            fast = fast->next;
            if( fast == NULL ) return NULL;
            fast = fast->next;
        }

        if( !fast ) return NULL;

        slow = &dummy;

        while( slow != fast ){
            slow = slow->next;
            fast = fast->next;
        }

        return fast;
    }
};
</code></pre>
<p>Runtime: 12 ms</p>

<h3><a name="129" class="anchor" href="#129"></a>#129 Sum Root to Leaf Numbers (Medium)</h3>
<p>DFS.</p>
<pre><code>class Solution {
public:
    int sumNumbers(TreeNode* root) {

        if( !root ) return 0;
        result = 0;
        traverse( root, 0 );

        return result;
    }
    <!--  -->
    void traverse( TreeNode *root, int a ){
        a = a * 10 + root->val;
        if( !root->left && !root->right ){ result += a; return; }
        if( root->left ) traverse( root->left, a );
        if( root->right ) traverse( root->right, a );
    }

    int result;
};
</code></pre>
<p>Runtime: 4 ms</p>

<h3><a name="81" class="anchor" href="#81"></a>#81 Search in Rotated Sorted Array II (Medium)</h3>
<p>Worst case time complexity: O(n).</p>
<pre><code>class Solution {
public:
    bool search(vector< int >& nums, int target ) {

        int lower( 0 ), upper( nums.size() - 1 ), mid;

        while( upper - lower ){
            mid = lower + ( upper - lower >> 1 );
            if( nums[ mid ] == nums[ upper ] ) --upper;
            else if( nums[ mid ] < nums[ upper ] ){
                target > nums[ mid ] && target <= nums[ upper ] ?
                    ( lower = mid + 1 ) : ( upper = mid );
            }else{
                target > nums[ mid ] || target <= nums[ upper ] ?
                    ( lower = mid + 1 ) : ( upper = mid );
            }
        }

        return nums[ upper ] == target;
    }
};
</code></pre>
<p>Runtime: 8 ms</p>

<h3><a name="215" class="anchor" href="#215"></a>#215 Kth Largest Element in an Array (Medium)</h3>
<p>Idea of partition in qsort. Or use std::nth_element.</p>
<pre><code>class Solution {
public:
    int findKthLargest(vector< int >& nums, int k) {
        return find( nums, k, 0, nums.size() - 1 );
    }

    int find( vector< int > &nums, int k, int l, int r ){

        if( r == l ) return nums[ l ];

        int m( nums[ l + rand() % ( r - l + 1 ) ] );
        int i( l - 1 ), j( r + 1 );

        for( int k = l; k < j; ){
            if( nums[ k ] > m ) nums[ ++i ] = nums[ k++ ];
            else if( nums[ k ] < m ){ --j; swap( nums[ k ], nums[ j ] ); }
            else ++k;
        }

        if( i - l + 1 >= k )
            return find( nums, k, l, i );
        else if( k > j - l )
            return find( nums, k - j + l, j, r );
        else
            return m;
    }
};
</code></pre>
<p>Runtime: 12 ms</p>

<h3><a name="279" class="anchor" href="#279"></a>#279 Perfect Squares (Medium)</h3>
<p>Recursively search for solutions with least number of squares that sum to n.</p>
<pre><code>class Solution {
public:
    int numSquares(int n) {

        for( int i = 1; ; ++i )
            if( helper( i, n ) )
                return i;
    }

    bool helper( int a, int s ){

        int r( sqrt( s + 0. ) );

        if( a == 1 ) return s == r * r ? true : false;

        for( int i = r; r >= 1; --r )
            if( helper( a - 1, s - r * r ) )
                return true;

        return false;
    }
};
</code></pre>
<p>Runtime: 4 ms</p>

<h3><a name="114" class="anchor" href="#114"></a>#114 Flatten Binary Tree to Linked List (Medium)</h3>
<p>Recursively flatten the left subtree and right subtree, connect right subtree to tail of left subtree and make left subtree into right, finally return tail of whole tree.</p>
<pre><code>class Solution {
public:
    void flatten(TreeNode* root) {
        if( root ) helper( root );
    }

    TreeNode* helper( TreeNode* root ){

        TreeNode* tail( root );

        if( root->left ){
            tail = helper( root->left );
            tail->right = root->right;
            root->right = root->left;
            root->left = NULL;
        }
        if( tail->right )
            tail = helper( tail->right );

        return tail;
    }
};
</code></pre>
<p>Runtime: 8 ms</p>

<h3><a name="313" class="anchor" href="#313"></a>#313 Super Ugly Number (Medium)</h3>
<p>Use an array to record the next ugly number to multiply with to produce a new ugly number.</p>
<pre><code>class Solution {
public:
    int nthSuperUglyNumber(int n, vector< int >& primes) {

        int nPrimes( primes.size() );
        vector< int > ugly( n, 0x7fffffff );
        vector< int > next( nPrimes, 0 );

        ugly[ 0 ] = 1;

        for( int i = 1; i < n; ++i ){
            for( int j = 0; j < nPrimes; ++j )
                ugly[ i ] = min( ugly[ i ], primes[ j ] * ugly[ next[ j ] ] );
            for( int j = 0; j < nPrimes; ++j )
                next[ j ] += ugly[ i ] == primes[ j ] * ugly[ next[ j ] ];
        }

        return ugly[ n - 1 ];
    }
};
</code></pre>
<p>Runtime: 140 ms</p>

<h3><a name="78" class="anchor" href="#78"></a>#78 Subsets (Medium)</h3>
<p>Sort the numbers. Iterate a variable from 0 to 2^{# of numbers} and use its bitsets to indicate seletion of numbers.</p>
<pre><code>class Solution {
public:
    vector< vector< int > > subsets(vector< int >& nums) {

        int nNums( nums.size() );
        vector< vector< int > > vv;
        vector< int > v;

        sort( nums.begin(), nums.end() );

        for( int i = 0; i < 1 << nNums; ++i ){
            v.clear();
            for( int j = 0; j < nNums; ++j )
                if( 1 << j & i ) v.push_back( nums[ j ] );
            vv.push_back( v );
        }

        return vv;
    }
};
</code></pre>
<p>Runtime: 8 ms</p>

<h3><a name="39" class="anchor" href="#39"></a>#39 Combination Sum (Medium)</h3>
<p>Sort the numbers. DFS for all combinations.</p>
<pre><code>class Solution {
public:
    vector< vector< int > > combinationSum(vector< int >& candidates, int target) {

        sort( candidates.begin(), candidates.end() );
        v.clear(); vv.clear();
        generate( candidates, 0, target );

        return vv;
    }

    void generate( vector< int >& nums, int a, int sum ){

        if( sum == 0 ){ vv.push_back( v ); return; }
        if( a == nums.size() || sum < nums[ a ] ) return;

        generate( nums, a + 1, sum );
        v.push_back( nums[ a ] );
        generate( nums, a, sum - nums[ a ] );
        v.pop_back();
    }

    vector< int > v;
    vector< vector< int > > vv;
};
</code></pre>
<p>Runtime: 16 ms</p>

<h3><a name="109" class="anchor" href="#109"></a>#109 Convert Sorted List to Binary Search Tree (Medium)</h3>
<p>Find middle node and create root then recursively build left and right subtrees.</p>
<pre><code>class Solution {
public:
    TreeNode* sortedListToBST(ListNode* head) {

        if( !head ) return NULL;

        auto slow( head ), fast( head );

        while( true ){
            fast = fast->next;
            if( !fast || !fast->next ) break;
            fast = fast->next;
            if( !fast || !fast->next ) break;
            slow = slow->next;
        }

        fast = slow->next;
        slow->next = NULL;

        TreeNode* root;

        if( fast ){
            root = new TreeNode( fast->val );
            root->left = sortedListToBST( head );
            root->right = sortedListToBST( fast->next );
        }else{
            root = new TreeNode( head->val );
        }

        return root;
    }
};
</code></pre>
<p>Runtime: 28 ms</p>

<h3><a name="90" class="anchor" href="#90"></a>#90 Subsets II (Medium)</h3>
<p>DFS for all combinations.</p>
<pre><code>class Solution {
public:
    vector< vector< int > > subsetsWithDup(vector< int >& nums) {

        v.clear();
        vv.clear();
        m.clear();
        for( int num : nums )
            m.find( num ) == m.end() ?
                m[ num ] = 1 : m[ num ] += 1;
        ite = m.begin();
        generate( nums );

        return vv;
    }

    void generate( vector< int >& nums ){

        if( ite == m.end() ){ vv.push_back( v ); return; }

        ++ite; generate( nums ); --ite;
        for( int i = ite->second; i > 0; --i ){
            v.push_back( ite->first );
            ++ite; generate( nums ); --ite;
        }
        for( int i = ite->second; i > 0; --i )
            v.pop_back();
    }

    vector< int > v;
    vector< vector< int > > vv;
    map< int, int > m;
    map< int, int >::iterator ite;
};
</code></pre>
<p>Runtime: 12 ms</p>

<h3><a name="213" class="anchor" href="#213"></a>#213 House Robber II (Medium)</h3>
<p>Assume the first house is robbed or not and do DP as in #109.</p>
<pre><code>class Solution {
public:
    int rob(vector< int >& nums) {

        if( nums.empty() ) return 0;
        if( nums.size() == 1 ) return nums.back();

        int result1, result2;
        int nNums( nums.size() );
        vector< int > a( nNums );
        vector< int > b( nNums );

        a[ 0 ] = nums[ 0 ];
        b[ 0 ] = 1 << 31;

        for( int i = 1; i < nNums; ++i ){
            a[ i ] = max( a[ i - 1 ], b[ i - 1 ] + nums[ i ] );
            b[ i ] = max( a[ i - 1 ], b[ i - 1 ] );
        }

        result1 = b.back();

        a[ 0 ] = 1 << 31;
        b[ 0 ] = 0;

        for( int i = 1; i < nNums; ++i ){
            a[ i ] = max( a[ i - 1 ], b[ i - 1 ] + nums[ i ] );
            b[ i ] = max( a[ i - 1 ], b[ i - 1 ] );
        }

        result2 = max( a.back(), b.back() );

        return max( result1, result2 );
    }
};
</code></pre>
<p>Runtime: 0 ms</p>

<h3><a name="120" class="anchor" href="#120"></a>#120 Triangle (Medium)</h3>
<p>Simple DP. Let F[i,j] denote minimum points can be gained arriving at position(i, j), then we have:<br>
F[i, j] = min( F[i-1, j-1], F[i-1, j] ) + point[i, j].</p>
<pre><code>class Solution {
public:
    int minimumTotal(vector< vector< int > >& triangle) {

        int n( triangle.size() ), result( 1 << 30 );

        for( int i = 1; i < n; ++i ){
            triangle[ i ].front() += triangle[ i - 1 ].front();
            triangle[ i ].back() += triangle[ i - 1 ].back();
            for( int j = 1; j < i; ++j )
                triangle[ i ][ j ] += min(
                    triangle[ i - 1 ][ j - 1 ],
                    triangle[ i - 1 ][ j ]
                );
        }

        for( int i : triangle.back() ) result = min( result, i );

        return result;
    }
};
</code></pre>
<p>Runtime: 16 ms</p>

<h3><a name="95" class="anchor" href="#95"></a>#95 Unique Binary Search Trees II (Medium)</h3>
<p>Generate using DP.</p>
<pre><code>class Solution {
public:
    vector<TreeNode*> generateTrees(int n) {

        if( !n ) return vector< TreeNode* >();

        vector< TreeNode* > result;
        vector< int > start{ -1 };
        vector< int > count{ 1 };

        for( int m = 1; m <= n; ++m ){
            start.push_back( result.size() );
            count.push_back( 0 );
            for( int root = 1; root <= m; ++root ){
                for( int i = 0; i < count[ root - 1 ]; ++i )
                for( int j = 0; j < count[ m - root ]; ++j ){
                    TreeNode* rt( new TreeNode( root ) );
                    if( start[ root - 1 ] >= 0 ) rt->left = clone( result[ start[ root - 1 ] + i ], 0 );
                    if( start[ m - root ] >= 0 ) rt->right = clone( result[ start[ m - root ] + j ], root );
                    result.push_back( rt );
                    ++count.back();
                }
            }
        }

        return vector< TreeNode* >( result.begin() + start[ n ], result.end() );
    }

private:
    TreeNode* clone( TreeNode* root, int add ){
        TreeNode* root2 = new TreeNode( root->val + add );
        if( root->left ) root2->left = clone( root->left, add );
        if( root->right ) root2->right = clone( root->right, add );
        return root2;
    }
};
</code></pre>
<p>Runtime: 24 ms</p>

<h3><a name="63" class="anchor" href="#63"></a>#63 Unique Paths II (Medium)</h3>
<p>Same as #62, except that the grid with obstacle should be set to 0.</p>
<pre><code>class Solution {
public:
    int uniquePathsWithObstacles(vector< vector< int > >& obstacleGrid) {

        int M( obstacleGrid.size() );
        int N( obstacleGrid[ 0 ].size() );
        vector< vector< int > >& f( obstacleGrid );

        if( f[ 0 ][ 0 ] == 1 ) return 0;
        f[ 0 ][ 0 ] = 1;

        for( int i = 0; i < M; ++i )
        for( int j = i == 0; j < N; ++j ){
            if( f[ i ][ j ] == 1 ){ f[ i ][ j ] = 0; continue; }
            if( i > 0 ) f[ i ][ j ] += f[ i - 1 ][ j ];
            if( j > 0 ) f[ i ][ j ] += f[ i ][ j - 1 ];
        }

        return f.back().back();
    }
};
</code></pre>
<p>Runtime: 8 ms</p>

<h3><a name="201" class="anchor" href="#201"></a>#201 Bitwise AND of Numbers Range (Medium)</h3>
<p>The result shares the same suffix with n and m in binary representation.</p>
<pre><code>class Solution {
public:
    int rangeBitwiseAnd(int m, int n) {

        int result( 0xffffffff ), shift( 0 );

        while( m && n - m > 1 ){
            m >>= 1;
            n >>= 1;
            ++shift;
        }

        return m ? ( m & n ) << shift : 0;
    }
};
</code></pre>
<p>Runtime: 68 ms</p>

<h3><a name="86" class="anchor" href="#86"></a>#86 Partition List (Medium)</h3>
<p>Simple linked list operations.</p>
<pre><code>class Solution {
public:
    ListNode* partition(ListNode* head, int x) {

        ListNode headA( 0 ), *tailA( &headA );
        ListNode headB( 0 ), *tailB( &headB );

        for( auto ptr = head; ptr; ptr = ptr->next )
            ptr->val < x ? tailA = tailA->next = ptr : tailB = tailB->next = ptr;

        tailA->next = headB.next;
        tailB->next = NULL;

        return headA.next;
    }
};
</code></pre>
<p>Runtime: 8 ms</p>

<h3><a name="34" class="anchor" href="#34"></a>#34 Search for a Range (Medium)</h3>
<p>Binary search twice.</p>
<pre><code>class Solution {
public:
    vector< int > searchRange(vector< int >& nums, int target) {

        vector< int > result;
        int lower( 0 ), upper( nums.size() - 1 ), mid;

        while( upper - lower ){
            mid = lower + ( upper - lower >> 1 );
            nums[ mid ] < target ? ( lower = mid + 1 ) : ( upper = mid );
        }

        if( nums[ upper ] != target ) return vector< int >{ -1, -1 };
        result.push_back( upper );
        lower = 0; upper = nums.size() - 1;

        while( upper - lower ){
            mid = lower + ( upper - lower + 1 >> 1 );
            nums[ mid ] > target ? ( upper = mid - 1 ) : ( lower = mid );
        }

        result.push_back( upper );
        return result;
    }
};
</code></pre>
<p>Runtime: 12 ms</p>

<h3><a name="147" class="anchor" href="#147"></a>#147 Insertion Sort List (Medium)</h3>
<p>Sort recursively.</p>
<pre><code>class Solution {
public:
    ListNode* insertionSortList(ListNode* head) {

        if( !head ) return NULL;

        ListNode dummy( 0 ); dummy.next = head;
        helper( &dummy );

        return dummy.next;
    }

private:
    void helper( ListNode* head ){
        if( head->next ) helper( head->next );
        insert( head );
    }

    void insert( ListNode* head ){

        if( !head->next || !head->next->next ) return;

        auto nxt( head->next );
        auto ptr( head->next );

        while( ptr->next && ptr->next->val < nxt->val ) ptr = ptr->next;
        if( ptr == nxt ) return;

        head->next = nxt->next;
        nxt->next = ptr->next;
        ptr->next = nxt;
    }
};
</code></pre>
<p>Runtime: 80 ms</p>

<h3><a name="106" class="anchor" href="#106"></a>#106 Construct Binary Tree from Inorder and Postorder Traversal (Medium)</h3>
<p>Recursively build tree.</p>
<pre><code>class Solution {
public:
    TreeNode* buildTree(vector< int >& inorder, vector< int >& postorder) {

        if( inorder.empty() ) return NULL;

        this->inorder = inorder;
        this->postorder = postorder;

        return build( 0, inorder.size() - 1, 0, postorder.size() - 1 );
    }

    TreeNode* build( int a, int b, int c, int d ){

        if( a == b ) return new TreeNode( inorder[ a ] );

        TreeNode *root = new TreeNode( postorder[ d ] );

        int m; for( m = a; inorder[ m ] != postorder[ d ]; ++m );
        if( m > a ) root->left = build( a, m - 1, c, c - 1 + m - a );
        if( m < b ) root->right = build( m + 1, b, c + m - a, d - 1 );

        return root;
    }

    vector< int > inorder;
    vector< int > postorder;
};
</code></pre>
<p>Runtime: 48 ms</p>

<h3><a name="16" class="anchor" href="#16"></a>#16 3Sum Closest (Medium)</h3>
<p>Loop for first element, shrink range of second and third elements to make sum closer to target.</p>
<pre><code>class Solution {
public:
    int threeSumClosest(vector< int >& nums, int target) {

        int N( nums.size() );
        int result( 0x7fffffff );

        sort( nums.begin(), nums.end() );

        for( int i = 0; i < N - 2; ++i ){
            int j( i + 1 ), k( N - 1 ), M( target - nums[ i ] );
            while( j < k ){
                if( abs( nums[ j ] + nums[ k ] - M ) < abs( result ) )
                    result = nums[ j ] + nums[ k ] - M;
                if( result == 0 ) return target;
                M - nums[ j ] - nums[ k ] > 0 ? ++j : --k;
            }
        }

        return target + result;
    }
};
</code></pre>
<p>Runtime: 16 ms</p>

<h3><a name="236" class="anchor" href="#236"></a>#236 Lowest Common Ancestor of a Binary Tree (Medium)</h3>
<p>During traversal the first root whose tree contains v and w is LCA.</p>
<pre><code>class Solution {
public:
    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {

        this->p = p;
        this->q = q;
        isFound = false;
        helper( root );

        return result;
    }

    int helper( TreeNode* root ){

        if( !root ) return 0;

        int count{
            ( root == p ) + ( root == q )
            + helper( root->left )
            + helper( root->right )
        };

        if( count == 2 && !isFound ){
            isFound = true;
            result = root;
        }

        return count;
    }

    bool isFound;
    TreeNode *p, *q, *result;
};
</code></pre>
<p>Runtime: 24 ms</p>

<h3><a name="103" class="anchor" href="#103"></a>#103 Binary Tree Zigzag Level Order Traversal (Medium)</h3>
<p>Search and print in layers. Print order corresponds to parity of layer.</p>
<pre><code>typedef pair< TreeNode*, int > PTI;

class Solution {
public:
    vector< vector< int > > zigzagLevelOrder(TreeNode* root) {

        if( !root ) return vector< vector< int > >();

        int depth( 0 ), lastSize( 0 );
        vector< int > v;
        vector< PTI > q;
        vector< vector< int > > vv;

        q.push_back( PTI( root, 0 ) );

        while( q.size() - lastSize ){

            int start( depth & 1 ? q.size() - 1 : lastSize );
            int end( depth & 1 ? lastSize - 1 : q.size() );
            int step( depth & 1 ? -1 : 1 );

            for( int i = start; i != end; i += step )
                v.push_back( q[ i ].first->val );

            start = lastSize; end = lastSize = q.size();

            for( int i = start; i != end; ++i ){
                auto p( q[ i ].first );
                if( p->left ) q.push_back( PTI( p->left, depth + 1 ) );
                if( p->right ) q.push_back( PTI( p->right, depth + 1 ) );
            }

            vv.push_back( v );
            v.clear();
            ++depth;
        }

        return vv;
    }
};
</code></pre>
<p>Runtime: 4 ms</p>

<h3><a name="55" class="anchor" href="#55"></a>#55 Jump Game (Medium)</h3>
<p>Record the maximal index so for can be jumped to. Return false if current index is less then the max index.</p>
<pre><code>class Solution {
public:
    bool canJump(vector< int >& nums) {

        int N( nums.size() ), M( 0 );

        for( int i = 0; i < N; ++i ){
            if( i > M ) return false;
            M = max( M, nums[ i ] + i );
        }

        return true;
    }
};
</code></pre>
<p>Runtime: 16 ms</p>

<h3><a name="50" class="anchor" href="#50"></a>#50 Pow( x, n ) (Medium)</h3>
<p>Use binary optimization.</p>
<pre><code>class Solution {
public:
    double myPow(double x, int n) {

        if( n == 1 << 31 ) return myPow( x * x, n >> 1 );
        if( n < 0 ) return 1. / myPow( x, -n );

        double result( 1. );

        while( n ){
            if( n & 1 ) result *= x;
            x *= x;
            n >>= 1;
        }

        return result;
    }
};
</code></pre>
<p>Runtime: 4 ms</p>

<h3><a name="105" class="anchor" href="#105"></a>#105 Construct Binary Tree from Preorder and Inorder Traversal (Medium)</h3>
<p>Recursively build tree.</p>
<pre><code>class Solution {
public:
    TreeNode* buildTree(vector< int >& preorder, vector< int >& inorder) {

        if( inorder.empty() ) return NULL;

        this->inorder = inorder;
        this->preorder = preorder;

        return build( 0, inorder.size() - 1, 0, preorder.size() - 1 );
    }

    TreeNode* build( int a, int b, int c, int d ){

        if( a == b ) return new TreeNode( inorder[ a ] );

        TreeNode *root = new TreeNode( preorder[ c ] );

        int m; for( m = a; inorder[ m ] != preorder[ c ]; ++m );
        if( m > a ) root->left = build( a, m - 1, c + 1, c + m - a );
        if( m < b ) root->right = build( m + 1, b, c + 1 + m - a, d );

        return root;
    }

    vector< int > inorder;
    vector< int > preorder;
};
</code></pre>
<p>Runtime: 48 ms</p>

<h3><a name="113" class="anchor" href="#113"></a>#113 Path Sum II (Medium)</h3>
<p>DFS for all path.</p>
<pre><code>class Solution {
public:
    vector< vector< int > > pathSum(TreeNode* root, int sum) {

        if( !root ) return vector< vector< int > >();

        vi.clear();
        vvi.clear();
        helper( root, sum );

        return vvi;
    }

    void helper( TreeNode* root, int sum ){

        vi.push_back( root->val );

        if( !root->left && !root->right ){
            if( sum == root->val ) vvi.push_back( vi );
            vi.pop_back();
            return;
        }
        if( root->left ) helper( root->left, sum - root->val );
        if( root->right ) helper( root->right, sum - root->val );
        vi.pop_back();
    }

    vector< int > vi;
    vector< vector< int > > vvi;
};
</code></pre>
<p>Runtime: 12 ms</p>

<h3><a name="131" class="anchor" href="#131"></a>#131 Palindrome Partitioning (Medium)</h3>
<p>DFS for all ways of partitioning.</p>
<pre><code>class Solution {
public:
    vector< vector<string>> partition(string s) {

        length = s.length();
        vs.clear();
        vvs.clear();
        helper( s, 0 );

        return vvs;
    }

private:
    void helper( const string &s, int a ){

        if( a == length ){ vvs.push_back( vs ); return; }

        for( int i = a; i < length; ++i )
            if( isPalindrome( s.substr( a, i - a + 1 ) ) ){
                vs.push_back( s.substr( a, i - a + 1 ) );
                helper( s, i + 1 );
                vs.pop_back();
            }
    }

    bool isPalindrome( const string &s ){

        int length( s.length() );

        for( int i = 0; i < length >> 1; ++i )
            if( s[ i ] != s[ length - i - 1 ] )
                return false;

        return true;
    }

    int length;
    vector< string > vs;
    vector< vector< string > > vvs;
};
</code></pre>
<p>Runtime: 20 ms</p>

<h3><a name="17" class="anchor" href="#17"></a>#17 Letter Combination of a Phone Number (Medium)</h3>
<p>DFS for all combinations.</p>
<pre><code>class Solution {
public:
    vector<string> letterCombinations(string digits) {

        if( digits.empty() ) return vector< string >();

        s = "";
        vs.clear();
        helper( digits, 0 );

        return vs;
    }

private:
    void helper( string &digits, int a ){

        if( a == digits.length() ){ vs.push_back( s ); return; }

        for( char ch : d2l[ digits[ a ] - '0' ] ){
            s.push_back( ch );
            helper( digits, a + 1 );
            s.pop_back();
        }
    }

    const vector< vector< char > > d2l{
        {}, {}, { 'a', 'b', 'c' }, { 'd', 'e', 'f' }, { 'g', 'h', 'i' },
        { 'j', 'k', 'l' }, { 'm', 'n', 'o' }, { 'p', 'q', 'r', 's' },
        { 't', 'u', 'v' }, { 'w', 'x', 'y', 'z' }
    };

    string s;
    vector< string > vs;
};
</code></pre>
<p>Runtime: 0 ms</p>

<h3><a name="47" class="anchor" href="#47"></a>#47 Permutations II (Medium)</h3>
<p>Sort nums first. Insert the new number into previously generated permutations to prodece new permutations. Should not insert to positions prior to its previous appearance.</p>
<pre><code>class Solution {
public:
    vector< vector< int > > permuteUnique( vector< int >& nums) {

        sort( nums.begin(), nums.end() );
        vi.clear();
        vvi.clear();
        vi.push_back( nums.front() );
        helper( nums, 1 );

        return vvi;
    }

    void helper( vector< int > &nums, int a ){

        if( a == nums.size() ){
            vvi.push_back( vi );
            return;
        }

        vi.push_back( nums[ a ] );
        helper( nums, a + 1 );
        int i; for( i = a; i > 0; --i ){
            if( vi[ i ] == vi[ i - 1 ] ) break;
            swap( vi[ i ], vi[ i - 1 ] );
            helper( nums, a + 1 );
        }
        for( ; i < a; ++i )
            vi[ i ] = vi[ i + 1 ];
        vi.pop_back();
    }

    vector< int > vi;
    vector< vector< int > > vvi;
};
</code></pre>
<p>Runtime: 32 ms</p>

<h3><a name="92" class="anchor" href="#92"></a>#92 Reverse Linked List II (Medium)</h3>
<p>Linked list manipulation.</p>
<pre><code>class Solution {
public:
    ListNode* reverseBetween(ListNode* head, int m, int n) {

        if( m == n ) return head;

        ListNode dummy( 0 ); dummy.next = head;
        ListNode *ptrA( &dummy ), *ptrB( &dummy );

        for( int i = 0; i < m - 1; ++i, ptrA = ptrA->next );
        for( int j = 0; j < n + 1; ++j, ptrB = ptrB->next );

        ListNode *pre( ptrA ), *cur( pre->next ), *nxt( cur->next );

        for( cur->next = pre; nxt != ptrB; cur->next = pre ){
            pre = cur; cur = nxt; nxt = nxt->next;
        }

        ptrA->next->next = ptrB;
        ptrA->next = cur;

        return dummy.next;
    }
};
</code></pre>
<p>Runtime: 4 ms</p>

<h3><a name="134" class="anchor" href="#134"></a>#134 Gas Station (Medium)</h3>
<p>First simulate regardless of negative amount of gas. The station where the car has least amount of gas is the starting station.</p>
<pre><code>class Solution {
public:
    int canCompleteCircuit(vector< int >& gas, vector< int >& cost) {

        int start, minGas( 0x7fffffff );
        int sumGas( 0 ), sumCost( 0 );

        for( int i = 0; i < gas.size(); ++i ){
            sumGas += gas[ i ];
            sumCost += cost[ i ];
            if( minGas > sumGas - sumCost ){
                minGas = sumGas - sumCost;
                start = i + 1;
            }
        }

        return sumGas < sumCost ? -1 : start == gas.size() ? 0 : start;
    }
};
</code></pre>
<p>Runtime: 0 ms</p>

<h3><a name="40" class="anchor" href="#40"></a>#40 Combination Sum II (Medium)</h3>
<p>DFS for all combinations.</p>
<pre><code>class Solution {
public:
    vector< vector< int > > combinationSum2(vector< int >& candidates, int target) {

        vi.clear();
        vvi.clear();
        sort( candidates.begin(), candidates.end() );
        helper( candidates, 0, target );

        return vvi;
    }

    void helper( vector< int > &nums, int a, int sum ){

        if( !sum || a == nums.size() ){
            if( !sum ) vvi.push_back( vi );
            return;
        }

        int b; for( b = a; b < nums.size() && nums[ b ] == nums[ a ]; ++b );
        int c; for( c = 1; c <= b - a && nums[ a ] * c <= sum; ++c ){
            vi.push_back( nums[ a ] );
            helper( nums, b, sum - nums[ a ] * c );
        }
        while( --c ) vi.pop_back();
        helper( nums, b, sum );
    }

    vector< int > vi;
    vector< vector< int > > vvi;
};
</code></pre>
<p>Runtime: 16 ms</p>

<h3><a name="82" class="anchor" href="#82"></a>#82 Remove Duplicates from Sorted List iI (Medium)</h3>
<p>Add a dummy head to simplify operation.</p>
<pre><code>class Solution {
public:
    ListNode* deleteDuplicates(ListNode* head) {

        ListNode dummy( 0 ); dummy.next = head;
        ListNode *ptr( &dummy );

        while( ptr->next && ptr->next->next ){
            if( ptr->next->val != ptr->next->next->val ){
                ptr = ptr->next;
                continue;
            }

            int val( ptr->next->val );
            while( ptr->next && ptr->next->val == val ){
                auto nnxt( ptr->next->next );
                delete ptr->next;
                ptr->next = nnxt;
            }
        }

        return dummy.next;
    }
};
</code></pre>
<p>Runtime: 8 ms</p>

<h3><a name="49" class="anchor" href="#49"></a>#49 Group Anagrams (Medium)</h3>
<p>Hash function accounts for word length and letter components.</p>
<pre><code>class Solution {
public:
    vector< vector< string > > groupAnagrams( vector< string >& strs) {

        map< pair< int, int >, int > umap;
        vector< vector< string > > vvs;

        for( auto &s : strs ){
            auto hashVal( s2pii( s ) );
            if( umap.find( hashVal ) != umap.end() )
                vvs[ umap[ hashVal ] ].push_back( s );
            else{
                umap[ hashVal ] = vvs.size();
                vvs.push_back( vector< string >{ s } );
            }
        }

        for( auto &vs : vvs ) sort( vs.begin(), vs.end() );

        return vvs;
    }

    pair< int, int > s2pii( const string &s ){

        int tmp1( 0 ), tmp2( 1 );

        for( const char &ch : s ){
            tmp1 |= 1 << ( ch - 'a' );
            tmp2 *= ch - 'a' + 2;
        }

        return make_pair( tmp1, tmp2 );
    }
};
</code></pre>
<p>Runtime: 68 ms</p>

<h3><a name="31" class="anchor" href="#31"></a>#31 Nextr Permutation (Medium)</h3>
<p>Locate the rightmost number we can augment and swap it with the smallest number that is greater that it behind and sort the whole following part.</p>
<pre><code>class Solution {
public:
    void nextPermutation(vector<int>& nums) {

        int i; for( i = nums.size() - 2; i >= 0; --i )
            if( nums[ i ] < nums[ i + 1 ] ) break;

        if( i >= 0 ){
            int k( i + 1 );
            for( int j = k; j < nums.size(); ++j )
                if( nums[ j ] > nums[ i ] && nums[ j ] < nums[ k ] ) k = j;
            swap( nums[ i ], nums[ k ] );
        }

        sort( nums.begin() + i + 1, nums.end() );
    }
};
</code></pre>
<p>Runtime: 12 ms</p>

<h3><a name="209" class="anchor" href="#209"></a>#209 Minimum Size Subarray Sum (Medium)</h3>
<p>Scan the array of numbers. When it comes a new number, add it to sum and try to subtract earliest numbers in the sum.</p>
<pre><code>class Solution {
public:
    int minSubArrayLen(int s, vector<int>& nums) {

        int result( 0x7fffffff );
        int sum( 0 );

        for( int i = 0, j = 0; j < nums.size(); ++j ){
            sum += nums[ j ];
            while( sum - nums[ i ] >= s ) sum -= nums[ i++ ];
            if( sum >= s ) result = min( result, j - i + 1 );
        }

        return result == 0x7fffffff ? 0 : result;
    }
};
</code></pre>
<p>Runtime: 4 ms</p>

<h3><a name="264" class="anchor" href="#264"></a>#Ugly Number II (Medium)</h3>
<p></p>
<pre><code>class Solution {
public:
    int nthUglyNumber(int n) {

        vector< int > ugly( n, 0x7fffffff );
        vector< int > next{ 0, 0, 0 };
        vector< int > primes{ 2, 3, 5 };

        ugly[ 0 ] = 1;

        for( int i = 1; i < n; ++i ){
            for( int j = 0; j < 3; ++j ) ugly[ i ] = min( ugly[ i ], ugly[ next[ j ] ] * primes[ j ] );
            for( int j = 0; j < 3; ++j ) next[ j ] += ugly[ i ] == ugly[ next[ j ] ] * primes[ j ] ? 1 : 0;
        }

        return ugly.back();
    }
};
</code></pre>
<p>Runtime: 32 ms</p>

<h3><a name="297" class="anchor" href="#297"></a>#297 Serialize and Deserialize Binary Tree (Medium)</h3>
<p>Use std::queue.</p>
<pre><code>class Codec {
public:

    // Encodes a tree to a single string.
    string serialize(TreeNode* root) {

        queue< TreeNode * > mqueue;
        string result;

        mqueue.push( root );

        while( !mqueue.empty() ){
            auto pNode( mqueue.front() ); mqueue.pop();
            if( pNode == NULL ){ result += "# "; continue; }
            result += to_string( pNode->val ) + " ";
            mqueue.push( pNode->left ? pNode->left : NULL );
            mqueue.push( pNode->right ? pNode->right : NULL );
        }

        while( result.back() == ' ' || result.back() == '#' )
            result.pop_back();

        return result;
    }

    // Decodes your encoded data to tree.
    TreeNode* deserialize(string data) {

        TreeNode *root;
        queue< TreeNode * > mqueue, mqueue2;
        istringstream iss( data );
        string s;
        int i;

        while( true ){
            while( iss >> i ) mqueue.push( new TreeNode( i ) );
            iss.clear(); if( !( iss >> s ) ) break;
            mqueue.push( NULL );
        }

        if( mqueue.empty() ) return NULL;

        root = mqueue.front();
        mqueue.pop();
        mqueue2.push( root );

        while( !mqueue.empty() ){
            auto pNode( mqueue2.front() ); mqueue2.pop();
            pNode->left = mqueue.front(); mqueue.pop();
            if( mqueue.empty() ) break;
            pNode->right = mqueue.front(); mqueue.pop();
            if( pNode->left ) mqueue2.push( pNode->left );
            if( pNode->right ) mqueue2.push( pNode->right );
        }

        return root;
    }
};
</code></pre>
<p>Runtime: 48 ms</p>

<h3><a name="326" class="anchor" href="#326"></a>#326 Power of Three (Medium)</h3>
<p>1162261467 can be divided by power of 3.</p>
<pre><code>class Solution {
public:
    bool isPowerOfThree(int n) {
        return n > 0 && 1162261467 % n == 0;
    }
};
</code></pre>
<p>Runtime: 124 ms</p>

<h3><a name="382" class="anchor" href="#382"></a>#382 Linked List Random Node (Medium)</h3>
<p>Reservoir sampling.<br>
Iterate on the linked list. For the ith node, uniformly sample in [1, i], say a. If a == i, set expected result to the current node value.</p>
<pre><code>
class Solution {
public:
    Solution(ListNode* head) {
        this->head = head;
		g = default_random_engine();
		u = uniform_int_distribution<int>(0, INT_MAX);
    }

    int getRandom() {
        if (head == nullptr) {
			return 0;
		}

		int result = head->val;
		int count = 1;

		for (auto ptr = head; ptr != nullptr; ptr = ptr->next, ++count) {
			if (u(g) % count == 0) {
				result = ptr->val;
			}
		}

		return result;
    }
private:
	ListNode *head;
	default_random_engine g;
	uniform_int_distribution<int> u;
};
</code></pre>
<p>Runtime: 116 ms</p>

<h3><a name="347" class="anchor" href="#347"></a>#347 Top K Frequent Elements (Medium)</h3>
<p>Count all element occurence and use a priority queue to preserve top K frequent elements.</p>
<pre><code>
struct cmp {
	typedef pair<int, int> PII; // first->num, second->freq
	bool operator()(const PII &a, const PII &b) {
		return a.second > b.second;
	}
};

class Solution {
public:
    vector<int> topKFrequent(vector<int>& nums, int k) {
		unordered_map<int, int> count;
        priority_queue<int, vector<pair<int, int>>, cmp> pq;
		vector<int> result;

		for (int i : nums) {
			++count[i];
		}

		for (auto e : count) {
			pq.push(make_pair(e.first, e.second));
			if (pq.size() > k) {
				pq.pop();
			}
		}

		while (!pq.empty()) {
			result.push_back(pq.top().first);
			pq.pop();
		}

		return result;
    }
};
</code></pre>
<p>Runtime: 33 ms</p>

<h3><a name="378" class="anchor" href="#378"></a>#378 Kth Smallest Element in a Sorted Matrix (Medium)</h3>
<p>Use a small first priority queue to maintain smallest elements.<br>
Initially push matrix[0][0] into pq. Each time pop top element in pq and push its right and bottom element into pq.<br>
The Kth element being popped is the answer.<br>
*Note that every element is pushed at most once.</p>
<pre><code>struct cmp{
	typedef pair<int, int> PII;
	bool operator()(const PII &a, const PII &b) {
		return a.second > b.second;
	}
};

class Solution {
public:
    int kthSmallest(vector<vector<int>>& matrix, int k) {
		typedef pair<int, int> PII;
        priority_queue<PII, vector<PII>, cmp> pq;
		unordered_set<int> checked;
		int n = matrix.size();
		int discarded = 0;

		pq.push(make_pair(0, matrix[0][0]));
		checked.insert(0);

		while (discarded < k - 1) {
			int pos = pq.top().first; pq.pop();
			int i = pos >> 16;
			int j = pos & 0xffff;

			if (i < n - 1 && checked.find((i + 1) << 16 | j) == checked.end()) {
				checked.insert((i + 1) << 16 | j);
				pq.push(make_pair((i + 1) << 16 | j, matrix[i + 1][j]));
			}
			if (j < n - 1 && checked.find(i << 16 | (j + 1)) == checked.end()) {
				checked.insert(i << 16 | (j + 1));
				pq.push(make_pair(i << 16 | (j + 1), matrix[i][j + 1]));
			}
			++discarded;
		}

		return pq.top().second;
    }
};
</code></pre>
<p>Runtime: 202 ms</p>

<h3><a name="328" class="anchor" href="#328"></a>#328 Odd Even Linked List (Medium)</h3>
<p>Build odd node list and even node list, and finally concatenate them.</p>
<pre><code>
class Solution {
public:
    ListNode* oddEvenList(ListNode* head) {
        ListNode odd(0), *oddTail;
		ListNode even(0), *evenTail;

		oddTail = &odd;
		evenTail = &even;

		int flag = 0;
		for (auto ptr = head; ptr != nullptr; ptr = ptr->next) {
			if (flag == 0) {
				oddTail = oddTail->next = ptr;
			} else {
				evenTail = evenTail->next = ptr;
			}
			flag = 1 - flag;
		}

		oddTail->next = even.next;
		evenTail->next = nullptr;

		return odd.next;
    }
};
</code></pre>
<p>Runtime: 23 ms</p>

<h3><a name="377" class="anchor" href="#377"></a>#377 Combination Sum IV (Medium)</h3>
<p>Combination sum of N is:<br>
combination sum of N-1 (by appending a 1 at the front, if 1 is in the given array)<br>
+ combination sum of N-2 (by appending a 2 at the front, if 1 is in the given array)<br>
+ ...
+ 1 (N itself, is N is in the given array).</p>
<pre><code>class Solution {
public:
    int combinationSum4(vector<int>& nums, int target) {
        vector<int> dp(target + 1, 0);
        int size = nums.size();

        dp[0] = 1;
        sort(nums.begin(), nums.end());

		for (int i = 1; i <= target; ++i) {
			for (int j = 0; j < size && nums[j] <= i; ++j) {
				dp[i] += dp[i - nums[j]];
			}
		}

		return dp[target];
    }
};
</code></pre>
<p>Runtime: 0 ms</p>

<h3><a name="436" class="anchor" href="#436"></a>#436 Find Right Interval (Medium)</h3>
<p>Sort by start and for each interval I binary search for start >= I's end.<br>
*Here I used map.</p>
<pre><code>
class Solution {
public:
    vector<int> findRightInterval(vector<Interval>& intervals) {
		typedef pair<int, int> endId;
		map<int, endId> start;
		vector<int> result;
		int size = intervals.size();

		for (int i = 0; i < size; ++i) {
			start[intervals[i].start] = make_pair(intervals[i].end, i);
		}

		for (auto &interval : intervals) {
			auto ite = start.lower_bound(interval.end);
			result.push_back(ite == start.end() ? -1 : ite->second.second);
		}

		return result;
    }
};
</code></pre>
<p>Runtime: 202 ms</p>

<h3><a name="337" class="anchor" href="#337"></a>#337 House Robber III (Medium)</h3>
<p>DP on tree.<br>
Max rob current = rob current + max not rob children<br>
Max not rob current = max(max rob children, max not rob children)</p>
<pre><code>
class Solution {
public:
    int rob(TreeNode* root) {
        int rob = 0, nrob = 0;

		helper(root, rob, nrob);

		return max(rob, nrob);
    }
private:
	void helper(TreeNode *root, int &rob, int &nrob) {
		if (root == nullptr) {
			rob = nrob = 0;
			return;
		}

		int lrob, lnrob, rrob, rnrob;

		helper(root->left, lrob, lnrob);
		helper(root->right, rrob, rnrob);
		rob = lnrob + rnrob + root->val;
		nrob = max(lrob, lnrob) + max(rrob, rnrob);
	}
};
</code></pre>
<p>Runtime: 13 ms</p>

<h3><a name="394" class="anchor" href="#394"></a>#394 Decode String (Medium)</h3>
<p>Idea: use a stack to store the strings to be replicated.</p>
<pre><code>
class Solution {
public:
	string decodeString(string s) {
		stack<string> ss;
		stack<int> sk;
		int k = 0;

		ss.push("");
		for (char ch : s) {
			if (ch == '[') {
				sk.push(k);
				ss.push("");
				k = 0;
			} else if (ch == ']') {
				string tmp;
				for (int i = 0; i < sk.top(); ++i) {
					tmp += ss.top();
				}
				sk.pop();
				ss.pop();
				ss.top() += tmp;
			} else if (ch >= '0' && ch <= '9') {
				k = k * 10 + (ch - '0');
			} else {
				ss.top() += ch;
			}
		}

		return ss.top();
	}
};
</code></pre>
<p>Runtime: 0 ms</p>

<h3><a name="404" class="anchor" href="#404"></a>#404 Sum of Left Leaves (Medium)</h3>
<p>Traverse the tree. If current node is a left leaf, add its value to result.</p>
<pre><code>class Solution {
public:
    int sumOfLeftLeaves(TreeNode* root) {
        if (root == nullptr) {
            return 0;
        } else {
            int result = 0;

            helper(root, 1, result);

            return result;
        }
    }
private:
    void helper(TreeNode *root, int flag, int &result) {
        if (root == nullptr) {
            return;
        } else if (root->left == nullptr && root->right == nullptr) {
            if (flag == 0) {
                result += root->val;
            }
            return;
        }

        if (root->left) {
            helper(root->left, 0, result);
        }
        if (root->right) {
            helper(root->right, 1, result);
        }
    }
};
</code></pre>
<p>Runtime: 3 ms</p>

<h3><a name="423" class="anchor" href="#423"></a>#423 Reconstruct Original Digits from English (Medium)</h3>
<p>Use unique character in the word to figure out word counts.</p>
<pre><code>
class Solution {
public:
    string originalDigits(string s) {
        vector<int> input(26, 0);
        vector<int> count(10, 0);
        string result;

        for (char ch : s) {
            input[ch - 'a'] += 1;
        }

        // zero
        count[0] = input['z' - 'a'];
        for (int i = 0; i < count[0]; ++i) {
            input['z' - 'a'] -= 1;
            input['e' - 'a'] -= 1;
            input['r' - 'a'] -= 1;
            input['o' - 'a'] -= 1;
        }

        // two
        count[2] = input['w' - 'a'];
        for (int i = 0; i < count[2]; ++i) {
            input['t' - 'a'] -= 1;
            input['w' - 'a'] -= 1;
            input['o' - 'a'] -= 1;
        }

        // six
        count[6] = input['x' - 'a'];
        for (int i = 0; i < count[6]; ++i) {
            input['s' - 'a'] -= 1;
            input['i' - 'a'] -= 1;
            input['x' - 'a'] -= 1;
        }

        // four
        count[4] = input['u' - 'a'];
        for (int i = 0; i < count[4]; ++i) {
            input['f' - 'a'] -= 1;
            input['o' - 'a'] -= 1;
            input['u' - 'a'] -= 1;
            input['r' - 'a'] -= 1;
        }

        // three
        count[3] = input['r' - 'a'];
        for (int i = 0; i < count[3]; ++i) {
            input['t' - 'a'] -= 1;
            input['h' - 'a'] -= 1;
            input['r' - 'a'] -= 1;
            input['e' - 'a'] -= 1;
            input['e' - 'a'] -= 1;
        }

        // one
        count[1] = input['o' - 'a'];
        for (int i = 0; i < count[1]; ++i) {
            input['o' - 'a'] -= 1;
            input['n' - 'a'] -= 1;
            input['e' - 'a'] -= 1;
        }

        // five
        count[5] = input['f' - 'a'];
        for (int i = 0; i < count[5]; ++i) {
            input['f' - 'a'] -= 1;
            input['i' - 'a'] -= 1;
            input['v' - 'a'] -= 1;
            input['e' - 'a'] -= 1;
        }

        // seven
        count[7] = input['v' - 'a'];
        for (int i = 0; i < count[7]; ++i) {
            input['s' - 'a'] -= 1;
            input['e' - 'a'] -= 1;
            input['v' - 'a'] -= 1;
            input['e' - 'a'] -= 1;
            input['n' - 'a'] -= 1;
        }

        // eight
        count[8] = input['g' - 'a'];
        for (int i = 0; i < count[8]; ++i) {
            input['e' - 'a'] -= 1;
            input['i' - 'a'] -= 1;
            input['g' - 'a'] -= 1;
            input['h' - 'a'] -= 1;
            input['t' - 'a'] -= 1;
        }

        // nine
        count[9] = input['i' - 'a'];
        for (int i = 0; i < count[9]; ++i) {
            input['n' - 'a'] -= 1;
            input['i' - 'a'] -= 1;
            input['n' - 'a'] -= 1;
            input['e' - 'a'] -= 1;
        }

        for (int i = 0; i < 10; ++i) {
            result += string(count[i], (char)('0' + i));
        }

        return result;
    }
};
</code></pre>
<p>Runtime: 26 ms</p>

<h3><a name="424" class="anchor" href="#424"></a>#424 Longest Repeating Character Replacement (Medium)</h3>
<p>Sliding window.<br>
i moves first. MaxCount is the max number of same character in [i, j]. If (j-i+1) - maxCount > k, move j ahead.<p>
<pre><code>class Solution {
public:
    int characterReplacement(string s, int k) {
        int size = s.length();
		int count[26] = {0};
		int maxCount = 0;
		int result = 0;

		for (int i = 0, j = 0; i < size; ++i) {
			count[s[i] - 'A'] += 1;
			maxCount = max(maxCount, count[s[i] - 'A']);
			if (i - j + 1 - maxCount > k) {
				count[s[j++] - 'A'] -= 1;
			}
			result = max(result, i - j + 1);
		}

		return result;
    }
};
</code></pre>
<p>Runtime: 9 ms</p>

<h3><a name="399" class="anchor" href="#399"></a>#399 Evaluate Division (Medium)</h3>
<p>Build graph and search.</p>
<pre><code>struct Node {
	Node(const string &str, double val) : str(str), val(val) {}

	string str;
	double val;
};

struct Graph {
	void addEdge(const string &a, const string &b, double val) {
	    if (graph.find(a) == graph.end()) {
	        graph[a] = vector<Node>();
	    }
		graph[a].push_back(Node(b, val));
		if (graph.find(b) == graph.end()) {
		    graph[b] = vector<Node>();
		}
		graph[b].push_back(Node(a, 1. / val));
	}

	unordered_map<string, vector<Node>> graph;
};

class Solution {
public:
    vector<double> calcEquation(vector<pair<string, string>> equations,
			vector<double>& values, vector<pair<string, string>> queries) {
		int size = equations.size();
		vector<double> result;
		unordered_set<string> visited;
		Graph graph;

		for (int i = 0; i < size; ++i) {
			graph.addEdge(equations[i].first, equations[i].second, values[i]);
			graph.addEdge(equations[i].second, equations[i].first, 1. / values[i]);
		}

		for (auto &e : queries) {
			double tmp = -1.;
			if (graph.graph.find(e.first) != graph.graph.end()
			        && graph.graph.find(e.second) != graph.graph.end()) {
    			helper(e.first, e.second, 1., tmp, graph, visited);
			}
			result.push_back(tmp);
		}

		return result;
    }
private:
	void helper(const string &s, const string &d, double now, double &res, Graph &graph, unordered_set<string> &visited) {
		if (s == d) {
			res = now;
			return;
		}

		visited.insert(s);
		for (auto &e : graph.graph[s]) {
			if (visited.find(e.str) == visited.end()) {
				helper(e.str, d, now * e.val, res, graph, visited);
			}
			if (res != -1.) {
				break;
			}
		}
		visited.erase(s);
	}
};
</code></pre>
<p>Runtime: 0 ms</p>

<h3><a name="386" class="anchor" href="#386"></a>#386 Lexicographical Numbers (Medium)</h3>
<p>In-order traverse the prefix tree and construct the result array.</p>
<pre><code>class Solution {
public:
    vector<int> lexicalOrder(int n) {
        vector<int> result;

        helper(0, n, result);

        return result;
    }
private:
	void helper(int prefix, int n, vector<int> &result) {
		if (prefix > 0 && prefix <= n) {
			result.push_back(prefix);
		}

		for (int i = 0; i < 10; ++i) {
			if (prefix + i == 0) {
				continue;
			} else if (prefix * 10 + i <= n) {
				helper(prefix * 10 + i, n, result);
			} else {
				break;
			}
		}
	}
};
</code></pre>
<p>Runtime: 0 ms</p>

<h3><a name="334" class="anchor" href="#334"></a>#334 Increasing Triplet Subsequence (Medium)</h3>
<p>LIS. Returen once LIS is longer than 3.</p>
<pre><code>class Solution {
public:
    bool increasingTriplet(vector<int>& nums) {
        vector<int> v;

        for (int i : nums) {
            if (v.empty()) {
                v.push_back(i);
            } else if (i <= v[0]) {
                v[0] = i;
            } else if (v.size() > 1 && i <= v[1]) {
                v[1] = i;
            } else if (i > v.back()) {
                v.push_back(i);
            }
            if (v.size() == 3) {
                return true;
            }
        }

        return false;
    }
};
</code></pre>
<p>Runtime: 0 ms</p>

<h3><a name="367" class="anchor" href="#367"></a>#367 Valid Perfect Square (Medium)</h3>
<p>Binary search for sqrt(num).</p>
<pre><code>class Solution {
public:
    bool isPerfectSquare(int num) {
        int lower = 0;
        int upper = 46341;

        while (lower != upper) {
            int mid = lower + (upper - lower >> 1);

            if (mid * mid < num) {
                lower = mid + 1;
            } else {
                upper = mid;
            }
        }

        return upper * upper == num;
    }
};
</code></pre>
<p>Runtime: 0 ms</p>

<h3><a name="341" class="anchor" href="#341"></a>#341 Flatten Nested List Iterator (Medium)</h3>
<p>Use a stack to hold NestedInteger. Unpack top element if it is a list.</p>
<pre><code>
class NestedIterator {
public:
    NestedIterator(vector<NestedInteger> &nestedList) {
        for (auto ite = nestedList.rbegin(); ite != nestedList.rend(); ++ite) {
			s.push(*ite);
		}
    }

    int next() {
		int result = s.top().getInteger(); s.pop();

		return result;
    }

    bool hasNext() {
		while (!s.empty() && !s.top().isInteger()) {
			vector<NestedInteger> v = s.top().getList(); s.pop();

			for (auto ite = v.rbegin(); ite != v.rend(); ++ite) {
				s.push(*ite);
			}
		}

        return !s.empty();
    }
private:
	stack<NestedInteger> s;
};
</code></pre>
<p>Runtime: 49 ms</p>

<h3><a name="416" class="anchor" href="#416"></a>#416 Partition Equal Subset Sum (Medium)</h3>
<p>Dynamic Programming.</p>
<pre><code>class Solution {
public:
    bool canPartition(vector<int>& nums) {
        int sum = 0;

		for (int i : nums) {
			sum += i;
		}

		if (sum == 0 || sum & 1) {
			return false;
		}

		vector<bool> dp((sum >>= 1) + 1, false);

		dp[0] = true;
		for (int i : nums) {
			for (int j = sum; j >= i; --j) {
				dp[j] = dp[j] || dp[j - i];
			}
		}

		return dp[sum];
    }
};
</code></pre>
<p>Runtime: 899 ms</p>

<h3><a name="398" class="anchor" href="#398"></a>#398 Random Pick Index (Medium)</h3>
<p>Reservoir sampling.</p>
<pre><code>class Solution {
public:
    Solution(vector<int> nums) {
        this->nums = nums;
		u = uniform_int_distribution<int>(0, INT_MAX);
    }

    int pick(int target) {
        int result = 0;
		int count = 0;
		int size = nums.size();

		for (int i = 0; i < size; ++i) {
			if (nums[i] == target) {
				count += 1;
				if (u(g) % count == 0) {
					result = i;
				}
			}
		}

		return result;
    }
private:
	vector<int> nums;
	default_random_engine g;
	uniform_int_distribution<int> u;
};
</code></pre>
<p>Runtime: 159 ms</p>

<h3><a name="435" class="anchor" href="#435"></a>#435 Non-overlapping Intervals (Medium)</h3>
<p>Greedy.<br>
Sort all intervals about start position. Iterate on all intervals, discard the one with bigger end if there is conflict.</p>
<pre><code>
class Solution {
public:
    int eraseOverlapIntervals(vector<Interval>& intervals) {
		stack<Interval> s;
		int size = intervals.size();
		int result = 0;

        sort(intervals.begin(), intervals.end(), cmp);

		for (auto &interval : intervals) {
		    int con = false;
			while (!s.empty() && interval.start < s.top().end) {
				if (interval.end > s.top().end) {
					result += 1;
					con = true;
					break;
				} else {
					result += 1;
					s.pop();
				}
			}
			if (con) continue;
			s.push(interval);
		}

		return result;
    }
private:
	static bool cmp(const Interval &a, const Interval &b) {
		return (a.start == b.start ? (a.end < b.end) : a.start < b.start);
	}
};
</code></pre>
<p>Runtime: 26 ms</p>

<h3><a name="393" class="anchor" href="#393"></a>#393 UTF-8 Validation (Medium)</h3>
<p>Simply test each case.</p>
<pre><code>class Solution {
public:
    bool validUtf8(vector<int>& data) {
        int size = data.size();

		for (int i = 0; i < size; ++i) {
			if ((data[i] & 0x80) == 0) {
				// one-byte character
			} else if ((data[i] & 0xe0) == 0xc0) {
				// two-byte character
				if (i + 1 >= size) return false;
				if ((data[i + 1] & 0xc0) != 0x80) return false;
				i += 1;
			} else if ((data[i] & 0xf0) == 0xe0) {
			    // three-byte character
				if (i + 2 >= size) return false;
				if ((data[i + 1] & 0xc0) != 0x80) return false;
				if ((data[i + 2] & 0xc0) != 0x80) return false;
				i += 2;
			} else if ((data[i] & 0xf8) == 0xf0) {
			    // four-byte character
				if (i + 3 >= size) return false;
				if ((data[i + 1] & 0xc0) != 0x80) return false;
				if ((data[i + 2] & 0xc0) != 0x80) return false;
				if ((data[i + 3] & 0xc0) != 0x80) return false;
				i += 3;
			} else {
				return false;
			}
		}

		return true;
    }
};
</code></pre>
<p>Runtime: 19 ms</p>

<h3><a name="331" class="anchor" href="#331"></a>#331 Verify Preorder Serialization of a Binary Tree (Medium)</h3>
<p>Use a stack to consume the tree.<br>
Keep reducing subtrees of the form [num, #, #] with a [#].</p>
<pre><code>class Solution {
public:
    bool isValidSerialization(string preorder) {
        stringstream ss(preorder);
		string str;
		vector<bool> v;

		while (getline(ss, str, ',')) {
			v.push_back(str == "#" ? false : true);

			while (v.size() >= 3 && !v.back() && !v[v.size() - 2]) {
				v.pop_back(); v.pop_back();
				if (!v.back()) return false;
				v.pop_back(); v.push_back(false);
			}
		}

		return v.size() == 1 && !v.back();
    }
};
</code></pre>
<p>Runtime: 13 ms</p>
<p>Simplified with a count.</p>
<pre><code>class Solution {
public:
    bool isValidSerialization(string preorder) {
        stringstream ss(preorder);
		string str;
		int need = 1;

		while (getline(ss, str, ',')) {
		    if (need == 0) return false;
			need += (str == "#" ? -1 : 1);
		}

		return need == 0;
    }
};
</code></pre>
<p>Runtime: 13 ms</p>

<h3><a name="395" class="anchor" href="#395"></a>#395 Longest Substring with At Least K Repeating Characters (Medium)</h3>
<p>Count occurrence of each character. Use that with less than K occurrence to split the input string and handle parts recursively.</p>
<pre><code>class Solution {
public:
    int longestSubstring(string s, int k) {
		int result;

        helper(s, k, result);

		return result;
    }
private:
	void helper(const string &s, int k, int &result) {
		int count[26] = {0};
		char split = '\0';

		for (auto ch : s) {
			count[ch - 'a'] += 1;
		}

		for (int i = 0; i < 26; ++i) {
			if (count[i] && count[i] < k) {
				split = (char)('a' + i);
				break;
			}
		}

		if (split == '\0') {
			result = max(result, (int)s.length());
			return;
		}

		stringstream ss(s);
		string part;

		while (getline(ss, part, split)) {
			helper(part, k, result);
		}
	}
};
</code></pre>
<p>Runtime: 6 ms</p>

<h3><a name="376" class="anchor" href="#376"></a>#376 Wiggle Subsequence (Medium)</h3>
<p>If the next number conflicts the wiggle condition, replace current number with the next number.</p>
<pre><code>
class Solution {
public:
    int wiggleMaxLength(vector<int>& nums) {
		return max(helper(nums, INT_MAX), helper(nums, INT_MIN));
    }
private:
	int helper(vector<int> &nums, int pre) {
		if (nums.empty()) {
			return 0;
		}

		int result = 0;
		int flag = (pre == INT_MIN ? 0 : 1);

		for (auto i : nums) {
			if (flag == 0 && i > pre || flag == 1 && i < pre) {
				result += 1;
				flag = 1 - flag;
			}
			pre = i;
		}

		return result;
	}
};
</code></pre>
<p>Runtime: 0 ms</p>

<h3><a name="375" class="anchor" href="#375"></a>#375 Guess Number Higher or Lower (Medium)</h3>
<p>Recursive search with memorization.<br>
To figure out the minimum cost of guessing a number within [i, j], denoted as f[i, j]<br>
f[i, j] = min{ max{ f[i, k-1], f[k + 1, j] } + k }, where i <= k <= j.</p>
<pre><code>class Solution {
public:
    int getMoneyAmount(int n) {
        vector<vector<int>> memory(n + 1, vector<int>(n + 1, -1));

		return helper(1, n, memory);
    }
private:
	int helper(int s, int e, vector<vector<int>> &memory) {
		if (s >= e) {
			return 0;
		} else if (memory[s][e] != -1) {
			return memory[s][e];
		}

		int minCost = INT_MAX;

		for (int i = s; i <= e; ++i) {
			minCost = min(
				minCost,
				i + max(helper(s, i - 1, memory), helper(i + 1, e, memory))
			);
		}

		return memory[s][e] = minCost;
	}
};
</code></pre>
<p>Runtime: 99 ms</p>

<h3><a name="" class="anchor" href="#"></a># (Medium)</h3>
<p></p>
<pre><code>
</code></pre>
<p>Runtime: 0 ms</p>

<h3><a name="" class="anchor" href="#"></a># (Medium)</h3>
<p></p>
<pre><code>
</code></pre>
<p>Runtime: 0 ms</p>

<h3><a name="" class="anchor" href="#"></a># (Medium)</h3>
<p></p>
<pre><code>
</code></pre>
<p>Runtime: 0 ms</p>

<h3><a name="" class="anchor" href="#"></a># (Medium)</h3>
<p></p>
<pre><code>
</code></pre>
<p>Runtime: 0 ms</p>

<h3><a name="" class="anchor" href="#"></a># (Medium)</h3>
<p></p>
<pre><code>
</code></pre>
<p>Runtime: 0 ms</p>

<h3><a name="" class="anchor" href="#"></a># (Medium)</h3>
<p></p>
<pre><code>
</code></pre>
<p>Runtime: 0 ms</p>

    </section>
   </div>

   <!-- FOOTER  -->
   <div id="footer_wrap" class="outer">
    <footer class="inner">
      <p class="copyright">Liang's LeetCode Solutions maintained by <a href="https://github.com/itoupeter">itoupeter</a></p>
      <p>Published with <a href="http://pages.github.com">GitHub Pages</a></p>
    </footer>
   </div>



  </body>
</html>
