<!DOCTYPE html>
<html>

  <head>
    <meta charset='utf-8'>
    <meta http-equiv="X-UA-Compatible" content="chrome=1">
    <meta name="description" content="Blogtest : PL&#39;s Blog Test">

    <link rel="stylesheet" type="text/css" media="screen" href="stylesheets/stylesheet.css">

    <title>Liang's LeetCode Solutions</title>
  </head>

  <body>

    <!-- HEADER -->
    <div id="header_wrap" class="outer">
        <header class="inner">
<!--         
          <a id="forkme_banner" href="https://github.com/itoupeter/blogtest">View on GitHub</a>
 -->
          <h1 id="project_title">My LeetCode Solutions</h1>
          <h2 id="project_tagline">Problems Solved: 25</h2>
          <h2 id="project_tagline">Use Ctrl+F to find solution:)</h2>
<!-- 
            <section id="downloads">
              <a class="zip_download_link" href="https://github.com/itoupeter/blogtest/zipball/master">Download this project as a .zip file</a>
              <a class="tar_download_link" href="https://github.com/itoupeter/blogtest/tarball/master">Download this project as a tar.gz file</a>
            </section>
 -->            
        </header>
    </div>

    <!-- MAIN CONTENT -->
    <div id="main_content_wrap" class="outer">
      <section id="main_content" class="inner">
      
<h3><a name="292" class="anchor" href="#292"><span class="octicon octicon-link"></span></a>#292 Nim Game (Easy)</h3>
<p>Determine if n can be exactly divided by 4. If yes, you lose, else you win.</p>
<pre><code>class Solution {
public:
    bool canWinNim(int n) {
        return n & 3;
    }
};
</code></pre>
<p>Runtime: 0 ms</p>
      
<h3><a name="258" class="anchor" href="#258"></a>#258 Add Digits (Easy)</h3>
<p>There are 10 possible results. If num is 0, print 0. Else if num can be exactly divided by 9, print 9. Else print the remainder.</p>
<pre><code>class Solution {
public:
    int addDigits(int num) {
        return ( num - 1 ) % 9 + 1;
    }
};
</code></pre>
<p>Runtime: 8 ms</p>
      
<h3><a name="104" class="anchor" href="#104"></a>#104 Maximum Depth of Binary Tree (Easy)</h3>
<p>Recursively find maximum depth of subtrees of the current node, return the larger one incremented by 1.</p>
<pre><code>class Solution {
public:
    int maxDepth(TreeNode* root) {
        return root? max( maxDepth( root->left ), maxDepth( root->right ) ) + 1 : 0;
    }
};
</code></pre>
<p>Runtime: 8 ms</p>
      
<h3><a name="237" class="anchor" href="#237"></a>#237 Delete Node in a Linked List (Easy)</h3>
<p>Instead of delete the given node, replace it by its next node and delete the next node.</p>
<pre><code>class Solution {
public:
    void deleteNode(ListNode* node) {
        
        ListNode *nextNode( node->next );
        ListNode *nextNextNode( nextNode->next );
        
        node->val = nextNode->val;
        node->next = nextNextNode;
        
        delete nextNode;
    }
};
</code></pre>
<p>Runtime: 20 ms</p>
      
<h3><a name="283" class="anchor" href="#283"></a>#283 Move Zeroes (Easy)</h3>
<p>Suppose we already have a "sorted" sequence in the form [num,...,num,0,...,0] and here comes a:<br>
I) zero: simply add it to the tail<br>
II) non-zero: add it to the tail and swap it with the first zero in the original sequence<br>
Run the algorithm above with original sequence empty.</p>
<pre><code>class Solution {
public:
    void moveZeroes(vector<int>& nums) {

        int nNums( nums.size() );
        int nZeros( 0 );

        for( int i = 0; i < nNums; ++i ){
            if( nums[ i ] == 0 ){
                ++nZeros;
            }else if( nZeros > 0 && i - nZeros >= 0 ){
                swap( nums[ i ], nums[ i - nZeros ] );
            }
        }
    }

    void swap( int &a, int &b ){
        a ^= b ^= a ^= b;
    }
};
</code></pre>
<p>Runtime: 20 ms</p>
      
<h3><a name="100" class="anchor" href="#100"></a>#100 Same Tree (Easy)</h3>
<p>Compare current node, then subtrees recursively. Mind null pointer error.</p>
<pre><code>class Solution {
public:
    bool isSameTree(TreeNode* p, TreeNode* q) {
        if( p == NULL && q == NULL ) return true;
        if( p == NULL && q != NULL ) return false;
        if( p != NULL && q == NULL ) return false;
        if( p->val != q->val ) return false;
        if( !isSameTree( p->left, q->left ) ) return false;
        if( !isSameTree( p->right, q->right ) ) return false;
        return true;
    }
};
</code></pre>
<p>Runtime: 0 ms</p>
      
<h3><a name="226" class="anchor" href="#226"></a>#226 Invert Binary Tree (Easy)</h3>
<p>Recursively swap left subtree and right subtree.</p>
<pre><code>class Solution {
public:
    TreeNode* invertTree(TreeNode* root) {
        
        if( root == NULL ) return NULL;
        
        TreeNode *tmp( root->left );
        root->left = root->right;
        root->right = tmp;
        
        invertTree( root->left );
        invertTree( root->right );
        
        return root;
    }
};
</code></pre>
<p>Runtime: 0 ms</p>
      
<h3><a name="242" class="anchor" href="#242"></a>#242 Valid Anagram (Easy)</h3>
<p>Simply compare occurrence of letters in each word.</p>
<pre><code>class Solution {
public:
    bool isAnagram(string s, string t) {
        
        if( s.length() != t.length() ) return false;
        
        int len( s.length() );
        int count[ 26 ];
        
        memset( count, 0, sizeof count );
        
        for( int i = 0; i < len; ++i ){
            ++count[ s[ i ] - ( int )'a' ];
            --count[ t[ i ] - ( int )'a' ];
        }
        
        for( int i = 0; i < 26; ++i ){
            if( count[ i ] ) return false;
        }
        
        return true;
    }
};
</code></pre>
<p>Runtime: 12 ms</p>
      
<h3><a name="217" class="anchor" href="#217"></a>#217 Contains Duplicate (Easy)</h3>
<p>Use std::unordered_set.</p>
<pre><code>class Solution {
public:
    bool containsDuplicate(vector<int>& nums) {
        
        unordered_set< int > uset;
        
        for( int num : nums ){
            
            if( uset.find( num ) != uset.end() )
                return true;
            else
                uset.insert( num );
        }
        
        return false;
    }
};
</code></pre>
<p>Runtime: 48 ms</p>
<p>Runtime (using std::set): 104 ms</p>
      
<h3><a name="171" class="anchor" href="#171"></a>#171 Excel Sheet Column Number (Easy)</h3>
<p>A new type of number with numerical base 26.</p>
<pre><code>class Solution {
public:
    int titleToNumber(string s) {
        
        int len( s.length() );
        int result( 0 );
        
        for( int i = 0; i < len; ++i ){
            if( i ) result *= 26;
            result += s[ i ] - ( int )'A' + 1;
        }
        
        return result;
    }
};
</code></pre>
<p>Runtime: 8 ms</p>
      
<h3><a name="169" class="anchor" href="#169"></a>#169 Majority Element (Easy)</h3>
<p>Since we are given the condition "majority element always exists", its number of occurrence is greater than that of other numbers. Subtract the number of occurrence of the currently expected ME by number of occurrence of other numbers.</p>
<pre><code>class Solution {
public:
    int majorityElement(vector<int>& nums) {

        int majorCount( 0 );
        int majorNum( 0 );
    
        for( int num : nums ){
            if( majorCount == 0 ){
                ++majorCount;
                majorNum = num;
            }else if( majorNum == num ){
                ++majorCount;
            }else{
                --majorCount;
            }
        }
        
        return majorNum;
    }
};
</code></pre>
<p>Runtime: 20 ms</p>
      
<h3><a name="235" class="anchor" href="#235"></a>#235 Lowest Common Ancestor of a Binary Search Tree (Easy)</h3>
<p>Since the given tree is a BST, value of LCA must be between values of p and q.</p>
<pre><code>class Solution {
public:
    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {

        if( p->val > q->val ){
            TreeNode *tmp( p );
            p = q;
            q = tmp;
        }

        if( root == p || root == q )
            return root;
        else if( root->val > p->val && root->val <= q->val ) 
            return root;
        else if( q->val < root->val ) 
            return lowestCommonAncestor( root->left, p, q );
        else
            return lowestCommonAncestor( root->right, p, q );
    }

};
</code></pre>
<p>Runtime: 44 ms</p>
      
<h3><a name="191" class="anchor" href="#191"></a>#191 Number of 1 Bits (Easy)</h3>
<p>Simple counting.</p>
<pre><code>class Solution {
public:
    int hammingWeight(uint32_t n) {
        n = ( n & 0x55555555U ) + ( n >> 1 & 0x55555555U );
        n = ( n & 0x33333333U ) + ( n >> 2 & 0x33333333U );
        n = ( n & 0x0f0f0f0fU ) + ( n >> 4 & 0x0f0f0f0fU );
        n = ( n & 0x00ff00ffU ) + ( n >> 8 & 0x00ff00ffU );
        n = ( n & 0x0000ffffU ) + ( n >> 16 & 0x0000ffffU );
        return ( int )n;
    }
};
</code></pre>
<p>Runtime: 4 ms</p>
      
<h3><a name="13" class="anchor" href="#13"></a>#13 Roman to Integer (Easy)</h3>
<p>If a digit is less than its following digit, subtract it from result, else add it to result.</p>
<pre><code>class Solution {
public:
    int romanToInt(string s) {
        
        static const int r2d[ 26 ]{
            0, 0, 100, 500, 0, 0, 0, 0, 1, 0, 0, 50, 1000, 
            0, 0, 0, 0, 0, 0, 0, 0, 5, 0, 10, 0, 0, 
        };

        int result( r2d[ s[ 0 ] - ( int )'A'] );
        int pre( result ), cur( 0 );
        int len( s.length() );

        for( int i = 1; i < len; ++i ){
            cur = r2d[ s[ i ] - ( int )'A' ];
            if( cur > pre ) result -= pre << 1;
            result += cur;
            pre = cur;
        }

        return result;
    }
};
</code></pre>
<p>Runtime: 36 ms</p>
      
<h3><a name="206" class="anchor" href="#206"></a>#206 Reverse Linked List (Easy)</h3>
<p>Use a vector. OK I am cheating.</p>
<pre><code>class Solution {
public:
    ListNode* reverseList(ListNode* head) {

        if( head == NULL ) return NULL;

        vector< ListNode * > nodes;

        for( ListNode *pNode = head; pNode != NULL; pNode = pNode->next ){
            nodes.push_back( pNode );
        }

        for( int i = nodes.size() - 1; i > 0; --i ){
            nodes[ i ]->next = nodes[ i - 1 ];
        }

        nodes[ 0 ]->next = NULL;

        return nodes.back();
    }
};
</code></pre>
<p>Runtime: 8 ms</p>
      
<h3><a name="70" class="anchor" href="#70"></a>#70 Climbing Stairs (Easy)</h3>
<p>Number of ways to reach nth step can be added up by:<br>
number of ways to reach (n-1)th step (climb 1 step from here) and<br>
number of ways to reach (n-2)th step (clime 2 steps from here).</p>
<pre><code>class Solution {
public:
    int climbStairs(int n) {
        
        vector< int > v( 2, 1 );
        
        for( int i = 2; i <= n; ++i ){
            v.push_back( v[ i - 1 ] + v[ i - 2 ] );
        }
        
        return v[ n ];
    }
};
</code></pre>
<p>Runtime: 0 ms</p>
      
<h3><a name="83" class="anchor" href="#83"></a>#83 Remove Duplicates from Sorted List (Easy)</h3>
<p>If next node has same value as current node, delete next node (and release memory).</p>
<pre><code>class Solution {
public:
    ListNode* deleteDuplicates(ListNode* head) {
        
        for( ListNode *cur = head; cur != NULL; ){
            
            ListNode *nxt( cur->next );
            
            if( nxt == NULL ) break;
            if( nxt->val == cur->val ){
                cur->next = nxt->next;
                delete nxt;
            }else{
                cur = nxt;
            }
        }
        
        return head;
    }
};
</code></pre>
<p>Runtime: 16 ms</p>
      
<h3><a name="263" class="anchor" href="#263"></a>#263 Ugly Number (Easy)</h3>
<p>Divide the number by 2, 3, and 5 repeatedly. If 1 is left, the number is ugly.</p>
<pre><code>class Solution {
public:
    bool isUgly(int num) {

        if( num <= 0 ) return false;

        while( num % 2 == 0 ) num /= 2;
        while( num % 3 == 0 ) num /= 3;
        while( num % 5 == 0 ) num /= 5;

        return num == 1;
    }
};
</code></pre>
<p>Runtime: 4 ms</p>
      
<h3><a name="202" class="anchor" href="#202"></a>#202 Happy Number (Easy)</h3>
<p>Use std::unordered_set to check if a cycle exists.</p>
<pre><code>class Solution {
public:
    bool isHappy(int n) {

        if( n <= 0 ) return false;

        unordered_set< int > uset;

        while( n != 1 ){
            if( uset.find( n ) != uset.end() )
                return false;
            else{
                uset.insert( n );
                n = nextN( n );
            }
        }
        
        return true;
    }

    int nextN( int n ){
    
        int result( 0 ), tmp;

        while( n ){
            tmp = n % 10;
            n /= 10;
            result += tmp * tmp;
        }

        return result;
    }
};
</code></pre>
<p>Runtime: 4 ms</p>
      
<h3><a name="21" class="anchor" href="#21"></a>#21 Merge Two Sorted Lists (Easy)</h3>
<p>Repeatedly take the larger head node of the lists.</p>
<pre><code>class Solution {
public:
    ListNode* mergeTwoLists(ListNode* l1, ListNode* l2) {

        if( l1 == NULL )
            return l2;
        else if( l2 == NULL )
            return l1;

        ListNode head( 0 ), *tail( &head );
        
        for( ; l1 != NULL && l2 != NULL; tail = tail->next ){

            if( l1->val < l2->val ){
                tail->next = l1;
                l1 = l1->next;
            }else{
                tail->next = l2;
                l2 = l2->next;
            }
        }

        if( l1 == NULL )
            tail->next = l2;
        else
            tail->next = l1;

        return head.next;
    }
};
</code></pre>
<p>Runtime: 12 ms</p>
      
<h3><a name="232" class="anchor" href="#232"></a>#232 Implement Queue using Stacks (Easy)</h3>
<p>Take advantage of 2 stacks to get access to both head and tail.</p>
<pre><code>class Queue {
public:
    // Push element x to the back of queue.
    void push(int x) {
        while( !b.empty() ){ a.push( b.top() ); b.pop(); }
        a.push( x );
    }

    // Removes the element from in front of queue.
    void pop(void) {
        while( !a.empty() ){ b.push( a.top() ); a.pop(); }
        b.pop();
    }

    // Get the front element.
    int peek(void) {
        while( !a.empty() ){ b.push( a.top() ); a.pop(); }
        return b.top();
    }

    // Return whether the queue is empty.
    bool empty(void) {
        return a.empty() && b.empty();
    }

    stack< int > a, b;
};
</code></pre>
<p>Runtime: 0 ms</p>
      
<h3><a name="231" class="anchor" href="#231"></a>#231 Power of 2 (Easy)</h3>
<p>In binary representation, (n & -n) is the rightmost 1 of n. Use it to cancel the rightmost 1 of n (by XOR) and n will be 0 if it is power of 2.</p>
<pre><code>class Solution {
public:
    bool isPowerOfTwo(int n) {
        return n > 0 && ( n & -n ^ n ) == 0;
    }
};
</code></pre>
<p>Runtime: 4 ms</p>
      
<h3><a name="110" class="anchor" href="#110"></a>#110 Balanced Binary Tree (Easy)</h3>
<p>Recursively compare depths of subtrees.</p>
<pre><code>class Solution {
public:
    bool isBalanced(TreeNode* root) {
        
        int depth( 0 );
        
        return isBalancedAndGetDepth( root, depth );
    }
    
    bool isBalancedAndGetDepth( TreeNode *root, int &depth ){
        
        if( root == NULL ) return true;
        
        int lDepth( 0 ), rDepth( 0 );
        
        if( !isBalancedAndGetDepth( root->left, lDepth ) ) return false;
        if( !isBalancedAndGetDepth( root->right, rDepth ) ) return false;
        if( lDepth - rDepth > 1 || lDepth - rDepth < -1 ) return false;
        depth = lDepth > rDepth ? lDepth + 1 : rDepth + 1;
        
        return true;
    }
};
</code></pre>
<p>Runtime: 20 ms</p>
      
<h3><a name="101" class="anchor" href="#101"></a>#101 Symmetric Tree (Easy)</h3>
<p>For a symmetric tree, its right subtree is a mirror of its left subtree.<br>
For two mirrored trees A and B, A's right subtree is a mirror of B's left subtree, and A's left subtree is a mirror of B's right subtree.</p>
<pre><code>class Solution {
public:
    bool isSymmetric(TreeNode* root) {
        return root == NULL || isMirror( root->left, root->right );
    }
    
    bool isMirror( TreeNode *left, TreeNode *right ){
        if( left == NULL && right == NULL ) return true;
        if( left != NULL && right == NULL ) return false;
        if( left == NULL && right != NULL ) return false;
        
        return left->val == right->val
            && isMirror( left->left, right->right )
            && isMirror( left->right, right->left );
    }
};
</code></pre>
<p>Runtime: 4 ms</p>
      
<h3><a name="27" class="anchor" href="#27"></a>#27 Remove Element (Easy)</h3>
<p>Just remove element.</p>
<pre><code>class Solution {
public:
    int removeElement(vector<int>& nums, int val) {
        
        int len( nums.size() );
        
        for( int i = 0; i < len; ++i ){
            if( nums[ i ] != val ) continue;
            while( i < len && nums[ len - 1 ] == val ) --len;
            if( i < len ) nums[ i ] = nums[ --len ];
        }
        
        return len;
    }
};
</code></pre>
<p>Runtime: 4 ms</p>

      </section>
    </div>

    <!-- FOOTER  -->
    <div id="footer_wrap" class="outer">
      <footer class="inner">
        <p class="copyright">Liang's LeetCode Solutions maintained by <a href="https://github.com/itoupeter">itoupeter</a></p>
        <p>Published with <a href="http://pages.github.com">GitHub Pages</a></p>
      </footer>
    </div>

    

  </body>
</html>
