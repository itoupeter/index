<!DOCTYPE html>
<html>

  <head>
    <meta charset='utf-8'>
    <meta http-equiv="X-UA-Compatible" content="chrome=1">
    <meta name="description" content="Blogtest : PL&#39;s Blog Test">

    <link rel="stylesheet" type="text/css" media="screen" href="stylesheets/stylesheet.css">

    <title>Liang's LeetCode Solutions</title>
  </head>

  <body>

    <!-- HEADER -->
    <div id="header_wrap" class="outer">
        <header class="inner">
<!--         
          <a id="forkme_banner" href="https://github.com/itoupeter/blogtest">View on GitHub</a>
 -->
          <h1 id="project_title">My LeetCode Solutions</h1>
          <h2 id="project_tagline">Problems Solved: 60</h2>
          <h2 id="project_tagline">Use Ctrl+F to find solution:)</h2>
<!-- 
            <section id="downloads">
              <a class="zip_download_link" href="https://github.com/itoupeter/blogtest/zipball/master">Download this project as a .zip file</a>
              <a class="tar_download_link" href="https://github.com/itoupeter/blogtest/tarball/master">Download this project as a tar.gz file</a>
            </section>
 -->            
        </header>
    </div>

    <!-- MAIN CONTENT -->
    <div id="main_content_wrap" class="outer">
      <section id="main_content" class="inner">
      
<h3><a name="292" class="anchor" href="#292"><span class="octicon octicon-link"></span></a>#292 Nim Game (Easy)</h3>
<p>Determine if n can be exactly divided by 4. If yes, you lose, else you win.</p>
<pre><code>class Solution {
public:
    bool canWinNim(int n) {
        return n & 3;
    }
};
</code></pre>
<p>Runtime: 0 ms</p>
      
<h3><a name="258" class="anchor" href="#258"></a>#258 Add Digits (Easy)</h3>
<p>There are 10 possible results. If num is 0, print 0. Else if num can be exactly divided by 9, print 9. Else print the remainder.</p>
<pre><code>class Solution {
public:
    int addDigits(int num) {
        return ( num - 1 ) % 9 + 1;
    }
};
</code></pre>
<p>Runtime: 8 ms</p>
      
<h3><a name="104" class="anchor" href="#104"></a>#104 Maximum Depth of Binary Tree (Easy)</h3>
<p>Recursively find maximum depth of subtrees of the current node, return the larger one incremented by 1.</p>
<pre><code>class Solution {
public:
    int maxDepth(TreeNode* root) {
        return root? max( maxDepth( root->left ), maxDepth( root->right ) ) + 1 : 0;
    }
};
</code></pre>
<p>Runtime: 8 ms</p>
      
<h3><a name="237" class="anchor" href="#237"></a>#237 Delete Node in a Linked List (Easy)</h3>
<p>Instead of delete the given node, replace it by its next node and delete the next node.</p>
<pre><code>class Solution {
public:
    void deleteNode(ListNode* node) {
        
        ListNode *nextNode( node->next );
        ListNode *nextNextNode( nextNode->next );
        
        node->val = nextNode->val;
        node->next = nextNextNode;
        
        delete nextNode;
    }
};
</code></pre>
<p>Runtime: 20 ms</p>
      
<h3><a name="283" class="anchor" href="#283"></a>#283 Move Zeroes (Easy)</h3>
<p>Suppose we already have a "sorted" sequence in the form [num,...,num,0,...,0] and here comes a:<br>
I) zero: simply add it to the tail<br>
II) non-zero: add it to the tail and swap it with the first zero in the original sequence<br>
Run the algorithm above with original sequence empty.</p>
<pre><code>class Solution {
public:
    void moveZeroes(vector<int>& nums) {

        int nNums( nums.size() );
        int nZeros( 0 );

        for( int i = 0; i < nNums; ++i ){
            if( nums[ i ] == 0 ){
                ++nZeros;
            }else if( nZeros > 0 && i - nZeros >= 0 ){
                swap( nums[ i ], nums[ i - nZeros ] );
            }
        }
    }

    void swap( int &a, int &b ){
        a ^= b ^= a ^= b;
    }
};
</code></pre>
<p>Runtime: 20 ms</p>
      
<h3><a name="100" class="anchor" href="#100"></a>#100 Same Tree (Easy)</h3>
<p>Compare current node, then subtrees recursively. Mind null pointer error.</p>
<pre><code>class Solution {
public:
    bool isSameTree(TreeNode* p, TreeNode* q) {
        if( p == NULL && q == NULL ) return true;
        if( p == NULL && q != NULL ) return false;
        if( p != NULL && q == NULL ) return false;
        if( p->val != q->val ) return false;
        if( !isSameTree( p->left, q->left ) ) return false;
        if( !isSameTree( p->right, q->right ) ) return false;
        return true;
    }
};
</code></pre>
<p>Runtime: 0 ms</p>
      
<h3><a name="226" class="anchor" href="#226"></a>#226 Invert Binary Tree (Easy)</h3>
<p>Recursively swap left subtree and right subtree.</p>
<pre><code>class Solution {
public:
    TreeNode* invertTree(TreeNode* root) {
        
        if( root == NULL ) return NULL;
        
        TreeNode *tmp( root->left );
        root->left = root->right;
        root->right = tmp;
        
        invertTree( root->left );
        invertTree( root->right );
        
        return root;
    }
};
</code></pre>
<p>Runtime: 0 ms</p>
      
<h3><a name="242" class="anchor" href="#242"></a>#242 Valid Anagram (Easy)</h3>
<p>Simply compare occurrence of letters in each word.</p>
<pre><code>class Solution {
public:
    bool isAnagram(string s, string t) {
        
        if( s.length() != t.length() ) return false;
        
        int len( s.length() );
        int count[ 26 ];
        
        memset( count, 0, sizeof count );
        
        for( int i = 0; i < len; ++i ){
            ++count[ s[ i ] - ( int )'a' ];
            --count[ t[ i ] - ( int )'a' ];
        }
        
        for( int i = 0; i < 26; ++i ){
            if( count[ i ] ) return false;
        }
        
        return true;
    }
};
</code></pre>
<p>Runtime: 12 ms</p>
      
<h3><a name="217" class="anchor" href="#217"></a>#217 Contains Duplicate (Easy)</h3>
<p>Use std::unordered_set.</p>
<pre><code>class Solution {
public:
    bool containsDuplicate(vector<int>& nums) {
        
        unordered_set< int > uset;
        
        for( int num : nums ){
            
            if( uset.find( num ) != uset.end() )
                return true;
            else
                uset.insert( num );
        }
        
        return false;
    }
};
</code></pre>
<p>Runtime: 48 ms</p>
<p>Runtime (using std::set): 104 ms</p>
      
<h3><a name="171" class="anchor" href="#171"></a>#171 Excel Sheet Column Number (Easy)</h3>
<p>A new type of number with numerical base 26.</p>
<pre><code>class Solution {
public:
    int titleToNumber(string s) {
        
        int len( s.length() );
        int result( 0 );
        
        for( int i = 0; i < len; ++i ){
            if( i ) result *= 26;
            result += s[ i ] - ( int )'A' + 1;
        }
        
        return result;
    }
};
</code></pre>
<p>Runtime: 8 ms</p>
      
<h3><a name="169" class="anchor" href="#169"></a>#169 Majority Element (Easy)</h3>
<p>Since we are given the condition "majority element always exists", its number of occurrence is greater than that of other numbers. Subtract the number of occurrence of the currently expected ME by number of occurrence of other numbers.</p>
<pre><code>class Solution {
public:
    int majorityElement(vector<int>& nums) {

        int majorCount( 0 );
        int majorNum( 0 );
    
        for( int num : nums ){
            if( majorCount == 0 ){
                ++majorCount;
                majorNum = num;
            }else if( majorNum == num ){
                ++majorCount;
            }else{
                --majorCount;
            }
        }
        
        return majorNum;
    }
};
</code></pre>
<p>Runtime: 20 ms</p>
      
<h3><a name="235" class="anchor" href="#235"></a>#235 Lowest Common Ancestor of a Binary Search Tree (Easy)</h3>
<p>Since the given tree is a BST, value of LCA must be between values of p and q.</p>
<pre><code>class Solution {
public:
    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {

        if( p->val > q->val ){
            TreeNode *tmp( p );
            p = q;
            q = tmp;
        }

        if( root == p || root == q )
            return root;
        else if( root->val > p->val && root->val <= q->val ) 
            return root;
        else if( q->val < root->val ) 
            return lowestCommonAncestor( root->left, p, q );
        else
            return lowestCommonAncestor( root->right, p, q );
    }

};
</code></pre>
<p>Runtime: 44 ms</p>
      
<h3><a name="191" class="anchor" href="#191"></a>#191 Number of 1 Bits (Easy)</h3>
<p>Simple counting.</p>
<pre><code>class Solution {
public:
    int hammingWeight(uint32_t n) {
        n = ( n & 0x55555555U ) + ( n >> 1 & 0x55555555U );
        n = ( n & 0x33333333U ) + ( n >> 2 & 0x33333333U );
        n = ( n & 0x0f0f0f0fU ) + ( n >> 4 & 0x0f0f0f0fU );
        n = ( n & 0x00ff00ffU ) + ( n >> 8 & 0x00ff00ffU );
        n = ( n & 0x0000ffffU ) + ( n >> 16 & 0x0000ffffU );
        return ( int )n;
    }
};
</code></pre>
<p>Runtime: 4 ms</p>
      
<h3><a name="13" class="anchor" href="#13"></a>#13 Roman to Integer (Easy)</h3>
<p>If a digit is less than its following digit, subtract it from result, else add it to result.</p>
<pre><code>class Solution {
public:
    int romanToInt(string s) {
        
        static const int r2d[ 26 ]{
            0, 0, 100, 500, 0, 0, 0, 0, 1, 0, 0, 50, 1000, 
            0, 0, 0, 0, 0, 0, 0, 0, 5, 0, 10, 0, 0, 
        };

        int result( r2d[ s[ 0 ] - ( int )'A'] );
        int pre( result ), cur( 0 );
        int len( s.length() );

        for( int i = 1; i < len; ++i ){
            cur = r2d[ s[ i ] - ( int )'A' ];
            if( cur > pre ) result -= pre << 1;
            result += cur;
            pre = cur;
        }

        return result;
    }
};
</code></pre>
<p>Runtime: 36 ms</p>
      
<h3><a name="206" class="anchor" href="#206"></a>#206 Reverse Linked List (Easy)</h3>
<p>Use a vector. OK I am cheating.</p>
<pre><code>class Solution {
public:
    ListNode* reverseList(ListNode* head) {

        if( head == NULL ) return NULL;

        vector< ListNode * > nodes;

        for( ListNode *pNode = head; pNode != NULL; pNode = pNode->next ){
            nodes.push_back( pNode );
        }

        for( int i = nodes.size() - 1; i > 0; --i ){
            nodes[ i ]->next = nodes[ i - 1 ];
        }

        nodes[ 0 ]->next = NULL;

        return nodes.back();
    }
};
</code></pre>
<p>Runtime: 8 ms</p>
      
<h3><a name="70" class="anchor" href="#70"></a>#70 Climbing Stairs (Easy)</h3>
<p>Number of ways to reach nth step can be added up by:<br>
number of ways to reach (n-1)th step (climb 1 step from here) and<br>
number of ways to reach (n-2)th step (climb 2 steps from here).</p>
<pre><code>class Solution {
public:
    int climbStairs(int n) {
        
        vector< int > v( 2, 1 );
        
        for( int i = 2; i <= n; ++i ){
            v.push_back( v[ i - 1 ] + v[ i - 2 ] );
        }
        
        return v[ n ];
    }
};
</code></pre>
<p>Runtime: 0 ms</p>
      
<h3><a name="83" class="anchor" href="#83"></a>#83 Remove Duplicates from Sorted List (Easy)</h3>
<p>If next node has same value as current node, delete next node (and release memory).</p>
<pre><code>class Solution {
public:
    ListNode* deleteDuplicates(ListNode* head) {
        
        for( ListNode *cur = head; cur != NULL; ){
            
            ListNode *nxt( cur->next );
            
            if( nxt == NULL ) break;
            if( nxt->val == cur->val ){
                cur->next = nxt->next;
                delete nxt;
            }else{
                cur = nxt;
            }
        }
        
        return head;
    }
};
</code></pre>
<p>Runtime: 16 ms</p>
      
<h3><a name="263" class="anchor" href="#263"></a>#263 Ugly Number (Easy)</h3>
<p>Divide the number by 2, 3, and 5 repeatedly. If 1 is left, the number is ugly.</p>
<pre><code>class Solution {
public:
    bool isUgly(int num) {

        if( num <= 0 ) return false;

        while( num % 2 == 0 ) num /= 2;
        while( num % 3 == 0 ) num /= 3;
        while( num % 5 == 0 ) num /= 5;

        return num == 1;
    }
};
</code></pre>
<p>Runtime: 4 ms</p>
      
<h3><a name="202" class="anchor" href="#202"></a>#202 Happy Number (Easy)</h3>
<p>Use std::unordered_set to check if a cycle exists.</p>
<pre><code>class Solution {
public:
    bool isHappy(int n) {

        if( n <= 0 ) return false;

        unordered_set< int > uset;

        while( n != 1 ){
            if( uset.find( n ) != uset.end() )
                return false;
            else{
                uset.insert( n );
                n = nextN( n );
            }
        }
        
        return true;
    }

    int nextN( int n ){
    
        int result( 0 ), tmp;

        while( n ){
            tmp = n % 10;
            n /= 10;
            result += tmp * tmp;
        }

        return result;
    }
};
</code></pre>
<p>Runtime: 4 ms</p>
      
<h3><a name="21" class="anchor" href="#21"></a>#21 Merge Two Sorted Lists (Easy)</h3>
<p>Repeatedly take the larger head node of the lists.</p>
<pre><code>class Solution {
public:
    ListNode* mergeTwoLists(ListNode* l1, ListNode* l2) {

        if( l1 == NULL )
            return l2;
        else if( l2 == NULL )
            return l1;

        ListNode head( 0 ), *tail( &head );
        
        for( ; l1 != NULL && l2 != NULL; tail = tail->next ){

            if( l1->val < l2->val ){
                tail->next = l1;
                l1 = l1->next;
            }else{
                tail->next = l2;
                l2 = l2->next;
            }
        }

        if( l1 == NULL )
            tail->next = l2;
        else
            tail->next = l1;

        return head.next;
    }
};
</code></pre>
<p>Runtime: 12 ms</p>
      
<h3><a name="232" class="anchor" href="#232"></a>#232 Implement Queue using Stacks (Easy)</h3>
<p>Take advantage of 2 stacks to get access to both head and tail.</p>
<pre><code>class Queue {
public:
    // Push element x to the back of queue.
    void push(int x) {
        while( !b.empty() ){ a.push( b.top() ); b.pop(); }
        a.push( x );
    }

    // Removes the element from in front of queue.
    void pop(void) {
        while( !a.empty() ){ b.push( a.top() ); a.pop(); }
        b.pop();
    }

    // Get the front element.
    int peek(void) {
        while( !a.empty() ){ b.push( a.top() ); a.pop(); }
        return b.top();
    }

    // Return whether the queue is empty.
    bool empty(void) {
        return a.empty() && b.empty();
    }

    stack< int > a, b;
};
</code></pre>
<p>Runtime: 0 ms</p>
      
<h3><a name="231" class="anchor" href="#231"></a>#231 Power of 2 (Easy)</h3>
<p>In binary representation, (n & -n) is the rightmost 1 of n. Use it to cancel the rightmost 1 of n (by XOR) and n will be 0 if it is a power of 2.</p>
<pre><code>class Solution {
public:
    bool isPowerOfTwo(int n) {
        return n > 0 && ( n & -n ^ n ) == 0;
    }
};
</code></pre>
<p>Runtime: 4 ms</p>
      
<h3><a name="110" class="anchor" href="#110"></a>#110 Balanced Binary Tree (Easy)</h3>
<p>Recursively compare depths of subtrees.</p>
<pre><code>class Solution {
public:
    bool isBalanced(TreeNode* root) {
        
        int depth( 0 );
        
        return isBalancedAndGetDepth( root, depth );
    }
    
    bool isBalancedAndGetDepth( TreeNode *root, int &depth ){
        
        if( root == NULL ) return true;
        
        int lDepth( 0 ), rDepth( 0 );
        
        if( !isBalancedAndGetDepth( root->left, lDepth ) ) return false;
        if( !isBalancedAndGetDepth( root->right, rDepth ) ) return false;
        if( lDepth - rDepth > 1 || lDepth - rDepth < -1 ) return false;
        depth = lDepth > rDepth ? lDepth + 1 : rDepth + 1;
        
        return true;
    }
};
</code></pre>
<p>Runtime: 20 ms</p>
      
<h3><a name="101" class="anchor" href="#101"></a>#101 Symmetric Tree (Easy)</h3>
<p>For a symmetric tree, its right subtree is a mirror of its left subtree.<br>
For two mirrored trees A and B, A's right subtree is a mirror of B's left subtree, and A's left subtree is a mirror of B's right subtree.</p>
<pre><code>class Solution {
public:
    bool isSymmetric(TreeNode* root) {
        return root == NULL || isMirror( root->left, root->right );
    }
    
    bool isMirror( TreeNode *left, TreeNode *right ){
        if( left == NULL && right == NULL ) return true;
        if( left != NULL && right == NULL ) return false;
        if( left == NULL && right != NULL ) return false;
        
        return left->val == right->val
            && isMirror( left->left, right->right )
            && isMirror( left->right, right->left );
    }
};
</code></pre>
<p>Runtime: 4 ms</p>
      
<h3><a name="27" class="anchor" href="#27"></a>#27 Remove Element (Easy)</h3>
<p>Just remove element.</p>
<pre><code>class Solution {
public:
    int removeElement(vector<int>& nums, int val) {
        
        int len( nums.size() );
        
        for( int i = 0; i < len; ++i ){
            if( nums[ i ] != val ) continue;
            while( i < len && nums[ len - 1 ] == val ) --len;
            if( i < len ) nums[ i ] = nums[ --len ];
        }
        
        return len;
    }
};
</code></pre>
<p>Runtime: 4 ms</p>
      
<h3><a name="107" class="anchor" href="#107"></a>#107 Binary Tree Level Order Traversal II (Easy)</h3>
<p>Use std::queue to implement BFS and use std::stack to print result in expected order.</p>
<pre><code>class Solution {
public:
    vector<vector<int>> levelOrderBottom(TreeNode* root) {

        if( root == NULL ) return vector< vector< int > >();

        vector< vector< int > > result;
        queue< pair< TreeNode *, int > > mqueue;
        stack< pair< TreeNode *, int > > mstack;

        mqueue.push( make_pair( root, 0 ) );
        
        while( !mqueue.empty() ){
            
            TreeNode *node( mqueue.front().first );
            int layer( mqueue.front().second );

            mstack.push( mqueue.front() );
            if( node->right != NULL ) mqueue.push( make_pair( node->right, layer + 1 ) );
            if( node->left != NULL ) mqueue.push( make_pair( node->left, layer + 1 ) );
            mqueue.pop();
        }

        while( !mstack.empty() ){
            
            vector< int > v;
            int maxLayer( mstack.top().second );

            while( !mstack.empty() && mstack.top().second == maxLayer ){
                v.push_back( mstack.top().first->val );
                mstack.pop();
            }

            result.push_back( v );
        }

        return result;
    }
};
</code></pre>
<p>Runtime: 8 ms</p>
      
<h3><a name="198" class="anchor" href="#198"></a>#198 House Robber (Easy)</h3>
<p>Dynamic Progromming<br>
a[i] is the maximum value I can get from previous i houses without robbing the ith house,<br>
b[i] is the maximum value I can get from previous i houses with robbing the ith house,<br>
Then we have:<br>
a[i+1] = max{ a[i], b[i] }, without robbing (i+1)th house,<br>
b[i+1] = a[i] + {value of (i+1)th house}, with robbing (i+1)th house.</p>
<pre><code>class Solution {
public:
    int rob(vector<int>& nums) {

        int nNums( nums.size() );
        vector< int > a( nNums + 1, 0 ), b( nNums + 1, 0 );

        for( int i = 0; i < nNums; ++i ){
            a[ i + 1 ] = max( a[ i ], b[ i ] );
            b[ i + 1 ] = a[ i ] + nums[ i ];
        }

        return max( a[ nNums ], b[ nNums ] );
    }
};
</code></pre>
<p>Runtime: 0 ms</p>
      
<h3><a name="26" class="anchor" href="#26"></a>#26 Remove Duplicates from Sorted Array (Easy)</h3>
<p>Iterate and remove duplicates.</p>
<pre><code>class Solution {
public:
    int removeDuplicates(vector<int>& nums) {
        
        if( nums.empty() ) return 0;
        
        int nNums( nums.size() ), result( 1 );
        
        for( int i = 1; i < nNums; ++i ){
            if( nums[ i ] != nums[ i - 1 ] ){
                nums[ result++ ] = nums[ i ];
            }
        }
        
        return result;
    }
};
</code></pre>
<p>Runtime: 32 ms</p>
      
<h3><a name="66" class="anchor" href="#66"></a>#66 Plus One (Easy)</h3>
<p>Simple iteration. Increment from least significant digit and break if no carry.</p>
<pre><code>class Solution {
public:
    vector<int> plusOne(vector<int>& digits) {
        
        vector< int > result;
        int nDigits( digits.size() );
        bool carry( true );
        
        for( int i = nDigits - 1; i >= 0; --i ){
            if( ++digits[ i ] > 9 ){
                digits[ i ] -= 10;
            }else{
                carry = false;
                break;
            }
        }
        
        if( carry ) result.push_back( 1 );
        result.insert( result.end(), digits.begin(), digits.end() );
            
        return result;
    }
};
</code></pre>
<p>Runtime: 4 ms</p>
      
<h3><a name="118" class="anchor" href="#118"></a>#118 Pascal's Triangle (Easy)</h3>
<p>a[i,1] = a[i,i] = 1<br>
a[i,j] = a[i-1,j-1] + a[i-1,j].</p>
<pre><code>class Solution {
public:
    vector<vector<int>> generate(int numRows) {
        
        if( numRows == 0 ) return vector< vector< int > >();
        
        vector< vector< int > > result{{1}};
        
        for( int i = 2; i <= numRows; ++i ){
            
            vector< int > v{1};
            
            for( int j = 1; j <= i - 2; ++j ){
                v.push_back( result[ i - 2 ][ j - 1 ] + result[ i - 2 ][ j ] );
            }
            
            v.push_back( 1 );
            result.push_back( v );
        }
        
        return result;
    }
};
</code></pre>
<p>Runtime: 0 ms</p>
      
<h3><a name="172" class="anchor" href="#172"></a>#172 Factorial Trailing Zeroes (Easy)</h3>
<p>Since trailing zeroes are produced by 2 and 5 (2*5=10) in n!'s factors and 5 appears less frequently, simply count number of occurrence of 5 in n!'s factors.</p>
<pre><code>class Solution {
public:
    int trailingZeroes(int n) {
        
        int result( 0 );
        long long N( n ), powerOf5( 5 );
        
        while( N >= powerOf5 ){
            result += ( int )( N / powerOf5 );
            powerOf5 *= 5LL;
        }
        
        return result;
    }
};
</code></pre>
<p>Runtime: 4 ms</p>
      
<h3><a name="119" class="anchor" href="#119"></a>#119 Pascal's Triangle II (Easy)</h3>
<p>Reverse order of calculation so that next row can be produced in place.</p>
<pre><code>class Solution {
public:
    vector<int> getRow(int rowIndex) {
        
        vector< int > result{ 1 };
        
        for( int i = 1; i <= rowIndex; ++i ){
            for( int j = i - 1; j > 0; --j ){
                result[ j ] += result[ j - 1 ];
            }
            result.push_back( 1 );
        }
        
        return result;
    }
};
</code></pre>
<p>Runtime: 0 ms</p>
      
<h3><a name="102" class="anchor" href="#102"></a>#102 Binary Tree Level Order Traversal (Easy)</h3>
<p>Use a queue to implement BFS.</p>
<pre><code>class Solution {
public:
    vector<vector<int>> levelOrder(TreeNode* root) {

        if( root == NULL ) return vector< vector< int > >();

        vector< vector< int > > result;
        vector< int > v;
        queue< pair< TreeNode *, int > > mqueue;
        int currentLevel( 0 );

        mqueue.push( make_pair( root, 0 ) );
                
        while( !mqueue.empty() ){

            TreeNode *node( mqueue.front().first );
            int nodeLevel( mqueue.front().second );

            if( nodeLevel != currentLevel ){
                result.push_back( v );
                v.clear();
                ++currentLevel;
            }
            
            v.push_back( node->val );

            if( node->left != NULL ){
                mqueue.push( make_pair( node->left, currentLevel + 1 ) );
            }
            if( node->right != NULL ){
                mqueue.push( make_pair( node->right, currentLevel + 1 ) );
            }
            
            mqueue.pop();
        }

        result.push_back( v );

        return result;
    }
};
</code></pre>
<p>Runtime: 8 ms</p>
      
<h3><a name="112" class="anchor" href="#112"></a>#112 Path Sum (Easy)</h3>
<p>If there's a path from current node to leaf summed to {Sum}, there's a path from its child node to leaf Summed to {Sum - value of current node}.</p>
<pre><code>class Solution {
public:
    bool hasPathSum(TreeNode* root, int sum) {
        
        if( root == NULL ) return false;
        if( root->left == NULL && root->right == NULL ){
            return root->val == sum;
        }else{
            sum -= root->val;
            if( root->left != NULL && hasPathSum( root->left, sum ) ) return true;
            if( root->right != NULL && hasPathSum( root->right, sum ) ) return true;
            return false;
        }
    }
};
</code></pre>
<p>Runtime: 12 ms</p>
      
<h3><a name="225" class="anchor" href="#225"></a>#225 Implement Stack using Queues (Easy)</h3>
<p>Take advantage of 2 queues to get access to both head and tail.</p>
<pre><code>class Stack {
public:
    // Push element x onto stack.
    void push(int x) {
        b.push( x );
    }

    // Removes the element on top of the stack.
    void pop() {
        if( !b.empty() ){
            while( b.size() > 1 ){ a.push( b.front() ); b.pop(); }
            b.pop();
        }else{
            while( !a.empty() ){ b.push( a.front() ); a.pop(); }
            pop();
        }
    }

    // Get the top element.
    int top() {
        if( !b.empty() ){
            while( b.size() > 1 ){ a.push( b.front() ); b.pop(); }
            return b.front();
        }else{
            while( !a.empty() ){ b.push( a.front() ); a.pop(); }
            return top();
        }
    }

    // Return whether the stack is empty.
    bool empty() {
        return a.empty() && b.empty();
    }

    queue< int > a, b;
};
</code></pre>
<p>Runtime: 0 ms</p>
      
<h3><a name="9" class="anchor" href="#9"></a>#9 Panlindrome Number (Easy)</h3>
<p>(Discussion) Reverse till half and compare.</p>
<pre><code>class Solution {
public:
    bool isPalindrome(int x) {
        
        if( x < 0 || x != 0 && x % 10 == 0 ) return false;
        
        int y( 0 );
        
        while( x >= y ){
            if( x == y || x / 10 == y ) return true;
            y = y * 10 + x % 10;
            x /= 10;
        }
        
        return false;
    }
};
</code></pre>
<p>Runtime: 80 ms</p>
      
<h3><a name="111" class="anchor" href="#111"></a>#111 Minimum Depth of Binary Tree (Easy)</h3>
<p>Recursively find min depth. Trim branches deeper than current min depth.</p>
<pre><code>class Solution {
public:
    int minDepth(TreeNode* root) {
        
        if( root == NULL ) return 0;
        
        result = 0x7fffffff;
        traverse( root, 1 );
        
        return result;
    }
    
    void traverse( TreeNode *root, int depth ){
        
        if( root->left == NULL && root->right == NULL )
            result = depth;
        else if( result <= depth )
            return;
        else{
            if( root->left != NULL ) traverse( root->left, depth + 1 );
            if( root->right != NULL ) traverse( root->right, depth + 1 );
        }
    }
    
    int result;
};
</code></pre>
<p>Runtime: 12 ms</p>
      
<h3><a name="160" class="anchor" href="#160"></a>#160 Intersection of Two Linked Lists (Easy)</h3>
<p>Calculate difference of length of the given lists D.<br>
Two pointers walk on the lists, with the pointer on longer list walked D steps in advance.<br>
The intersection is where they meet.</p>
<pre><code>class Solution {
public:
    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {
        
        ListNode *ptrA( headA ), *ptrB( headB );
        ListNode *tailA( NULL ), *tailB( NULL );
        int lenA( 0 ), lenB( 0 );
        
        for( ; ptrA != NULL; ptrA = ptrA->next ){
            if( ptrA->next == NULL ) tailA = ptrA;
            ++lenA;
        }
        
        for( ; ptrB != NULL; ptrB = ptrB->next ){
            if( ptrB->next == NULL ) tailB = ptrB;
            ++lenB;
        }
        
        if( tailA != tailB ) return NULL;
        
        if( lenA < lenB ){
            auto tmp1( lenA ); lenA = lenB; lenB = tmp1;
            auto tmp2( headA ); headA = headB; headB = tmp2;
        }
        
        ptrA = headA;
        ptrB = headB;
        
        for( int i = lenA - lenB; i > 0; ptrA = ptrA->next, --i );
        for( ; ptrA != ptrB; ptrA = ptrA->next, ptrB = ptrB->next );
        
        return ptrA;
    }
};
</code></pre>
<p>Runtime: 52 ms</p>
<p>(Discussion) Smart solution!</p>
<pre><code>class Solution {
public:
    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {
        ListNode *ptrA = headA, *ptrB = headB;
        while (ptrA != ptrB) { 
            ptrA = ptrA ? ptrA->next : headB;
            ptrB = ptrB ? ptrB->next : headA;
        }
        return ptrA;
    }
};
</code></pre>
      
<h3><a name="88" class="anchor" href="#88"></a>#88 Merge Sorted Array (Easy)</h3>
<p>Merge from tail, so that no extra memory is needed.</p>
<pre><code>class Solution {
public:
    void merge(vector<int>& nums1, int m, vector<int>& nums2, int n) {
        
        if( m == 0 ){ nums1 = nums2; return; }
        if( n == 0 ) return;
        
        nums1.resize( m + n );
        
        for( int i = m - 1, j = n - 1, k = m + n - 1; k >= 0; --k ){
            if( i < 0 ){ nums1[ k ] = nums2[ j-- ]; continue; }
            if( j < 0 ){ nums1[ k ] = nums1[ i-- ]; continue; }
            nums1[ k ] = nums1[ i ] > nums2[ j ] ? nums1[ i-- ] : nums2[ j-- ];
        }
    }
};
</code></pre>
<p>Runtime: 4 ms</p>
      
<h3><a name="190" class="anchor" href="#190"></a>#190 Reverse Bits (Easy)</h3>
<p>Simple bits manipulation.</p>
<pre><code>class Solution {
public:
    uint32_t reverseBits(uint32_t n) {

        n = ( n << 1 & 0xAAAAAAAAU ) | ( n >> 1 & 0x55555555U );
        n = ( n << 2 & 0xCCCCCCCCU ) | ( n >> 2 & 0x33333333U );
        n = ( n << 4 & 0xF0F0F0F0U ) | ( n >> 4 & 0x0F0F0F0FU );
        n = ( n << 8 & 0xFF00FF00U ) | ( n >> 8 & 0x00FF00FFU );
        n = ( n << 16 & 0xFFFF0000U ) | ( n >> 16 & 0x0000FFFFU );

        return n;
    }
};
</code></pre>
<p>Runtime: 4 ms</p>
      
<h3><a name="36" class="anchor" href="#36"></a>#36 Valid Sudoku (Easy)</h3>
<p>Simple counting.</p>
<pre><code>class Solution {
public:
    bool isValidSudoku(vector<vector<char>>& board) {

        vector< bool > flag;
        char tmp;

        for( int i = 0, jj, kk; i < 9; ++i ){

            flag.assign( 10, false );
            for( int j = 0; j < 9; ++j ){
                if( ( tmp = board[ i ][ j ] ) == '.' ) continue;
                if( flag[ tmp - '0' ] ) return false;
                flag[ tmp - '0' ] = true;
            }

            flag.assign( 10, false );
            for( int j = 0; j < 9; ++j ){
                if( ( tmp = board[ j ][ i ] ) == '.' ) continue;
                if( flag[ tmp - '0' ] ) return false;
                flag[ tmp - '0' ] = true;
            }

            jj = i / 3 * 3; kk = i % 3 * 3;
            flag.assign( 10, false );
            for( int j = 0; j < 3; ++j ){
                for( int k = 0; k < 3; ++k ){
                    if( ( tmp = board[ jj + j ][ kk + k ] ) == '.' ) continue;
                    if( flag[ tmp - '0' ] ) return false;
                    flag[ tmp - '0' ] = true;
                }
            }
        }

        return true;
    }
};
</code></pre>
<p>Runtime: 16 ms</p>
      
<h3><a name="223" class="anchor" href="#223"></a>#223 Rectangle Area (Easy)</h3>
<p>Use long long to avoid int overflow.</p>
<pre><code>class Solution {
public:
    int computeArea(int A, int B, int C, int D, int E, int F, int G, int H) {
        
        long long a( ( 0LL + C - A ) * ( 0LL + D - B ) );
        long long b( ( 0LL + G - E ) * ( 0LL + H - F ) );
        long long c( 0LL + min( C, G ) - max( A, E ) );
        long long d( 0LL + min( D, H ) - max( B, F ) );
        long long e( c > 0LL && d > 0LL ? c * d : 0LL );
        
        return ( int )( a + b - e );
    }
};
</code></pre>
<p>Runtime: 32 ms</p>
      
<h3><a name="219" class="anchor" href="#219"></a>#219 Contains Duplicate II (Easy)</h3>
<p>Use std::unordered_set.</p>
<pre><code>class Solution {
public:
    bool containsNearbyDuplicate(vector<int>& nums, int k) {
        
        if( k <= 0 ) return false;
        
        unordered_set< int > uset;
        int nNums( nums.size() );
        
        for( int i = 0; i < nNums; ++i ){
            if( uset.find( nums[ i ] ) != uset.end() ) return true;
            if( i - k >= 0 ) uset.erase( nums[ i - k ] );
            uset.insert( nums[ i ] );
        }
        
        return false;
    }
};
</code></pre>
<p>Runtime: 32 ms</p>
      
<h3><a name="58" class="anchor" href="#58"></a>#58 Length of Last Word (Easy)</h3>
<p>Simple counting.</p>
<pre><code>class Solution {
public:
    int lengthOfLastWord(string s) {
        
        int len( s.length() );
        int result( 0 );
        
        while( len > 0 && s[ len - 1 ] == ' ' ) --len;
        while( len > 0 && s[ len - 1 ] != ' ' ) --len, ++result;
        
        return result;
    }
};
</code></pre>
<p>Runtime: 4 ms</p>
      
<h3><a name="19" class="anchor" href="#19"></a>#19 Remove Nth Node From End of List (Easy)</h3>
<p>2 pointers walk along the list with fast one ahead of slow one by N steps. Delete slow one when fast one meets the end.</p>
<pre><code>class Solution {
public:
    ListNode* removeNthFromEnd(ListNode* head, int &n) {
        
        ListNode *fast( head ), *slow( head );
        
        for( int i = 0; i < n; ++i, fast = fast->next );
        
        if( !fast ){ 
            auto tmp( head ); 
            head = head->next; 
            delete tmp; 
            return head;
        }else{ 
            fast = fast->next;
            while( fast ){ slow = slow->next; fast = fast->next; }
            auto nxt( slow->next ); slow->next = nxt->next; delete nxt;
        }
        
        return head;
    }
};
</code></pre>
<p>Runtime: 4 ms</p>
      
<h3><a name="20" class="anchor" href="#20"></a>#20 Valid Parentheses (Easy)</h3>
<p>Use a stack. When it comes a right bracket, push into stack, or check if it makes a pair with the top element in stack.</p>
<pre><code>class Solution {
public:
    bool isValid(string s) {
    
        stack< int > mstack;
        unordered_map< char, int > umap{
            { '(', 0 }, { ')', 1 }, 
            { '{', 2 }, { '}', 3 }, 
            { '[', 4 }, { ']', 5 }, 
        };
        
        for( char ch : s ){
            int code( umap[ ch ] );
            if( code & 1 ){
                if( mstack.empty() ) return false;
                if( mstack.top() != code - 1 ) return false;
                mstack.pop();
            }else
                mstack.push( code );
        }
        
        return mstack.empty();
    }
};
</code></pre>
<p>Runtime: 0 ms</p>
      
<h3><a name="205" class="anchor" href="#205"></a>#205 Isomorphic Strings (Easy)</h3>
<p>Check 1-to-1 mapping.</p>
<pre><code>class Solution {
public:
    bool isIsomorphic(string s, string t) {
        
        char chmap[ 256 ]{ 0 };
        bool used[ 256 ]{ false };
        int len( s.length() );
        
        for( int i = 0; i < len; ++i ){
            if( chmap[ s[ i ] ] ){
                if( chmap[ s[ i ] ] != t[ i ] ) return false;
            }else{
                if( used[ t[ i ] ] ) return false;
                chmap[ s[ i ] ] = t[ i ];
                used[ t[ i ] ] = true;
            }
        }
        
        return true;
    }
};
</code></pre>
<p>Runtime: 36 ms</p>
<p>(Discussion) Smarter solution.</p>
<pre><code>class Solution {
public:
    bool isIsomorphic(string s, string t) {
        
        char stmap[ 512 ]{ 0 };
        int len( s.length() );
        
        for( int i = 0; i < len; ++i ){
            if( stmap[ s[ i ] ] != stmap[ t[ i ] + 256 ] return false;
            stmap[ s[ i ] ] = stmap[ t[ i ] + 256 ] = i + 1;
        }
        
        return true;
    }
};
</code></pre>
<p>Runtime: 8 ms</p>
      
<h3><a name="290" class="anchor" href="#290"></a>#290 Word Pattern (Easy)</h3>
<p>1-to-1 map, similar idea as #205.<br>
(Discussion) Use istringstream to read words from str.</p>
<pre><code>class Solution {
public:
    bool wordPattern(string pattern, string str) {

        unordered_map< char, int > pmap;
        unordered_map< string, int > smap;
        int head( 0 ), tail( 0 ), len( pattern.length() ), i;
        string word;

        for( i = 0; i < len && tail != -1; ++i ){
            tail = str.find( " ", head );
            word = str.substr( head, tail - head );
            head = tail + 1;

            auto ite1( pmap.find( pattern[ i ] ) );
            auto ite2( smap.find( word ) );

            if( ( ite1 == pmap.end() ) != ( ite2 == smap.end() ) ) 
                return false;
            if( ( ite1 != pmap.end() ) && ( ite2 != smap.end() ) 
                && ( ite1->second != ite2->second ) ) return false;

            pmap[ pattern[ i ] ] = smap[ word ] = i;
        }

        return i == len && tail == -1;
    }
};
</code></pre>
<p>Runtime: 0 ms</p>
      
<h3><a name="203" class="anchor" href="#203"></a>#203 Remove Linked List Elements (Easy)</h3>
<p>Use a dummy head node to simplify situation.</p>
<pre><code>class Solution {
public:
    ListNode* removeElements(ListNode* head, int val) {
        
        ListNode result( 0 ); result.next = head;
        
        for( auto ptr = &result; ptr->next; ){
            if( ptr->next->val == val ){
                auto tmp( ptr->next->next );
                delete ptr->next;
                ptr->next = tmp;
            }else
                ptr = ptr->next;
        }
        
        return result.next;
    }
};
</code></pre>
<p>Runtime: 32 ms</p>
      
<h3><a name="38" class="anchor" href="#38"></a>#38 Count and Say (Easy)</h3>
<p>Use std::stringstream to simplify string manipulation.</p>
<pre><code>class Solution {
public:
    string countAndSay(int n) {

        if( n <= 1 ) return string( "1" );

        stringstream ss;
        string s( "1" );

        while( --n ){

            char pre( '\0' );
            int preCount( 0 );

            for( char cur : s ){
                if( cur != pre ){ 
                    if( preCount ) ss << preCount << pre;
                    pre = cur; 
                    preCount = 1;
                }else
                    ++preCount;
            }

            if( preCount ) ss << preCount << pre;
            ss >> s; ss.clear(); ss.str( "" );
        }

        return s;
    }
};
</code></pre>
<p>Runtime: 4 ms</p>
      
<h3><a name="299" class="anchor" href="#299"></a>#299 Bulls and Cows (Easy)</h3>
<p>Simple counting. Use std::stringstream or std::to_string.</p>
<pre><code>class Solution {
public:
    string getHint(string secret, string guess) {

        stringstream ss;
        int nBulls( 0 ), nCows( 0 );
        int count[ 20 ]{ 0 };
        int len( secret.length() );

        for( int i = 0; i < len; ++i ){
            nBulls += secret[ i ] == guess[ i ] ? 1 : 0;
            ++count[ secret[ i ] - '0' ];
            ++count[ guess[ i ] - '0' + 10 ];
        }

        for( int i = 0; i < 10; ++i ){
            nCows += min( count[ i ], count[ i + 10 ] );
        }

        ss << nBulls << "A" << nCows - nBulls << "B";
        return ss.str();
    }
};
</code></pre>
<p>Runtime: 4 ms</p>
      
<h3><a name="14" class="anchor" href="#14"></a>#14 Longest Common Prefix (Easy)</h3>
<p>Simple counting.</p>
<pre><code>class Solution {
public:
    string longestCommonPrefix(vector<string>& strs) {
        
        if( strs.empty() ) return string( "" );
        
        int nStrs( strs.size() );
        int maxLen( strs[ 0 ].length() );
        
        for( int i = 1; i < nStrs; ++i ){
            int len( strs[ i ].length() ), j;
            for( j = 0; j < len && j < maxLen; ++j )
                if( strs[ 0 ][ j ] != strs[ i ][ j ] ) break;
            maxLen = j;
        }
        
        return strs[ 0 ].substr( 0, maxLen );
    }
};
</code></pre>
<p>Runtime: 4 ms</p>
      
<h3><a name="67" class="anchor" href="#67"></a>#67 Add Binary (Easy)</h3>
<p>Split digits into vector and add.</p>
<pre><code>class Solution {
public:
    string addBinary(string a, string b) {

        vector< int > va, vb;
        string result;

        split( a, va ); 
        split( b, vb );

        int lenA( va.size() );
        int lenB( vb.size() );

        if( lenA < lenB ){
            va.swap( vb );
            lenA = lenB;
        }
        vb.resize( lenA );
        va.push_back( 0 );

        for( int i = 0; i < lenA; ++i ){
            va[ i + 1 ] += va[ i ] + vb[ i ] >> 1;
            result = ( va[ i ] + vb[ i ] & 1 ? '1' : '0' ) + result;
        }

        return va.back() ? '1' + result : result;
    }

    void split( const string &s, vector< int > &v ){
        for( int i = s.length() - 1; i >= 0; --i ){
            v.push_back( s[ i ] - '0' );
        }
    }
};
</code></pre>
<p>Runtime: 8 ms</p>
(Discussion) More concise code!</p>
<pre><code>class Solution {
public:
    string addBinary(string a, string b) {

        int i( a.length() - 1 );
        int j( b.length() - 1 );
        int carry( 0 );
        string result;

        while( i >= 0 || j >= 0 || carry ){
            carry += i >= 0 && a[ i-- ] - '0' ? 1 : 0;
            carry += j >= 0 && b[ j-- ] - '0' ? 1 : 0;
            result = ( carry & 1 ? '1' : '0' ) + result;
            carry >>= 1;
        }

        return result;
    }
};
</code></pre>
<p>Runtime: 4 ms</p>
      
<h3><a name="234" class="anchor" href="#234"></a>#234 Palindrome Linked List (Easy)</h3>
<p>Reverse first half and compare.</p>
<pre><code>class Solution {
public:
    bool isPalindrome(ListNode* head) {
        
        if( head == NULL || head->next == NULL ) return true;
        
        ListNode dummy( 0 ); dummy.next = head;
        ListNode *fast( &dummy ), *slow( &dummy );
        ListNode *l, *r;
        
        while( fast->next && fast->next->next ){
            slow = slow->next;
            fast = fast->next->next;
        }
        
        l = slow; r = slow->next;
        if( fast->next ) r = r->next;
        l->next = NULL;
        
        for( auto p = &dummy, c = head, n = c->next; ; ){
            c->next = p;
            if( !n ){ head->next = NULL; break; }
            p = c; c = n; n = n->next;
        }
        
        for( ; l && l->val == r->val; l = l->next, r = r->next );
        return l == NULL;
    }
};
</code></pre>
<p>Runtime: 28 ms</p>
      
<h3><a name="257" class="anchor" href="#257"></a>#257 Binary Tree Paths (Easy)</h3>
<p>Simple DFS. Use a vector to record nodes on current path.</p>
<pre><code>class Solution {
public:
    vector<string> binaryTreePaths(TreeNode* root) {
        if( root == NULL ) 
            return vector< string >();
        else{ 
            traverse( root ); 
            return vs; 
        }
    }
    
    void traverse( TreeNode *root ){
        
        vi.push_back( root->val );
        
        if( root->left == NULL && root->right == NULL ){
            string s;
            for( int i : vi ) s += "->" + to_string( i );
            vs.push_back( s.substr( 2, -1 ) );
        }else{
            if( root->left ) traverse( root->left );
            if( root->right ) traverse( root->right );
        }
        
        vi.pop_back();
    }
    
    vector< string > vs;
    vector< int > vi;
};
</code></pre>
<p>Runtime: 8 ms</p>
      
<h3><a name="303" class="anchor" href="#303"></a>#303 Range Sum Query - Immutable (Easy)</h3>
<p>Precompute suffix sum array, then sumRange( i, j ) = suffixSum( j ) - suffixSum( i - 1 ).</p>
<pre><code>class NumArray {
public:
    NumArray(vector<int> &nums) {
        for( int i = 0; i < nums.size(); ++i )
            v.push_back( v[ i ] + nums[ i ] );
    }

    int sumRange(int i, int j) {
        return  v[ j + 1 ] - v[ i ];
    }

    vector< int > v{ 0 };
};
</code></pre>
<p>Runtime: 596 ms</p>
      
<h3><a name="28" class="anchor" href="#28"></a>#28 Implement strStr() (Easy)</h3>
<p>Compare by brute force.</p>
<pre><code>class Solution {
public:
    int strStr(string haystack, string needle) {
        
        int lenH( haystack.length() );
        int lenN( needle.length() );
        
        if( lenN == 0 ) return 0;
        if( lenH < lenN ) return -1;
        
        for( int i = 0; i < lenH - lenN + 1; ++i ){
            for( int j = 0; ; ++j ){
                if( haystack[ i + j ] != needle[ j ] ) break;
                if( j == lenN - 1 ) return i;
            }
        }
        
        return -1;
    }
};
</code></pre>
<p>Runtime: 4 ms</p>
      
<h3><a name="7" class="anchor" href="#7"></a>#7 Reverse Integer (Easy)</h3>
<p>Mind tricky inputs like INT_MAX, INT_MIN.</p>
<pre><code>class Solution {
public:
    int reverse(int x) {
        
        if( x == 1 << 31 ) return 0;
        if( x < 0 ) return -reverse( -x );
        
        long long y( 0LL );
        
        while( x ){
            y = y * 10LL + x % 10;
            x /= 10;
        }
        
        return y <= 0x7fffffffLL ? ( int )y : 0;
    }
};
</code></pre>
<p>Runtime: 8 ms</p>
      
<h3><a name="125" class="anchor" href="#125"></a>#125 Valid Palindrome (Easy)</h3>
<p>.</p>
<pre><code>class Solution {
public:
    bool isPalindrome(string s) {
        
        string t;
        int len( 0 );
        
        for( char ch : s ){
            if( ch >= '0' && ch <= '9'
                || ch >= 'a' && ch <= 'z'
                || ch >= 'A' && ch <= 'Z' ){
                t += ch > 'Z' ? ( char )( ch - 32 ) : ch;
                ++len;
            }
        }
        
        for( int i = 0; i < len >> 1; ++i ){
            if( t[ i ] != t[ len - i - 1 ] ) return false;
        }
        
        return true;
    }
};
</code></pre>
<p>Runtime: 16 ms</p>
      
<h3><a name="" class="anchor" href="#"></a># (Easy)</h3>
<p>.</p>
<pre><code>
</code></pre>
<p>Runtime: 4 ms</p>
      
<h3><a name="" class="anchor" href="#"></a># (Easy)</h3>
<p>.</p>
<pre><code>
</code></pre>
<p>Runtime: 4 ms</p>
      
<h3><a name="" class="anchor" href="#"></a># (Easy)</h3>
<p>.</p>
<pre><code>
</code></pre>
<p>Runtime: 4 ms</p>
      
<h3><a name="" class="anchor" href="#"></a># (Easy)</h3>
<p>.</p>
<pre><code>
</code></pre>
<p>Runtime: 4 ms</p>

      </section>
    </div>

    <!-- FOOTER  -->
    <div id="footer_wrap" class="outer">
      <footer class="inner">
        <p class="copyright">Liang's LeetCode Solutions maintained by <a href="https://github.com/itoupeter">itoupeter</a></p>
        <p>Published with <a href="http://pages.github.com">GitHub Pages</a></p>
      </footer>
    </div>

    

  </body>
</html>
