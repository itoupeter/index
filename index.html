<!DOCTYPE html>
<html>

  <head>
    <meta charset='utf-8'>
    <meta http-equiv="X-UA-Compatible" content="chrome=1">
    <meta name="description" content="Blogtest : PL&#39;s Blog Test">

    <link rel="stylesheet" type="text/css" media="screen" href="stylesheets/stylesheet.css">

    <title>Liang</title>
  </head>

  <body>

    <!-- HEADER -->
    <div id="header_wrap" class="outer">
        <header class="inner">
<!--         
          <a id="forkme_banner" href="https://github.com/itoupeter/blogtest">View on GitHub</a>
 -->
          <h1 id="project_title">My LeetCode Solutions</h1>
          <h2 id="project_tagline">Problems Solved: 11</h2>
          <h2 id="project_tagline">Use Ctrl+F to find solution:)</h2>
<!-- 
            <section id="downloads">
              <a class="zip_download_link" href="https://github.com/itoupeter/blogtest/zipball/master">Download this project as a .zip file</a>
              <a class="tar_download_link" href="https://github.com/itoupeter/blogtest/tarball/master">Download this project as a tar.gz file</a>
            </section>
 -->            
        </header>
    </div>

    <!-- MAIN CONTENT -->
    <div id="main_content_wrap" class="outer">
      <section id="main_content" class="inner">
      
<h3><a name="292" class="anchor" href="#292"><span class="octicon octicon-link"></span></a>#292 Nim Game (Easy)</h3>
<p>Determine if n can be exactly divided by 4. If yes, you lose, else you win.</p>
<pre><code>class Solution {
public:
    bool canWinNim(int n) {
        return n & 3;
    }
};
</code></pre>
<p>Runtime: 0 ms</p>
      
<h3><a name="258" class="anchor" href="#258"></a>#258 Add Digits (Easy)</h3>
<p>There are 10 possible results. If num is 0, print 0. Else if num can be exactly divided by 9, print 9. Else print the remainder.</p>
<pre><code>class Solution {
public:
    int addDigits(int num) {
        return ( num - 1 ) % 9 + 1;
    }
};
</code></pre>
<p>Runtime: 8 ms</p>
      
<h3><a name="104" class="anchor" href="#104"></a>#104 Maximum Depth of Binary Tree (Easy)</h3>
<p>Recursively find maximum depth of subtrees of the current node, return the larger one incremented by 1.</p>
<pre><code>class Solution {
public:
    int maxDepth(TreeNode* root) {
        return root? max( maxDepth( root->left ), maxDepth( root->right ) ) + 1 : 0;
    }
};
</code></pre>
<p>Runtime: 8 ms</p>
      
<h3><a name="237" class="anchor" href="#237"></a>#237 Delete Node in a Linked List (Easy)</h3>
<p>Instead of delete the given node, replace it by its next node and delete the next node.</p>
<pre><code>class Solution {
public:
    void deleteNode(ListNode* node) {
        
        ListNode *nextNode( node->next );
        ListNode *nextNextNode( nextNode->next );
        
        node->val = nextNode->val;
        node->next = nextNextNode;
        
        delete nextNode;
    }
};
</code></pre>
<p>Runtime: 20 ms</p>
      
<h3><a name="283" class="anchor" href="#283"></a>#283 Move Zeroes (Easy)</h3>
<p>Suppose we already have a "sorted" sequence in the form [num,...,num,0,...,0] and here comes a:<br>
I) zero: simply add it to the tail<br>
II) non-zero: add it to the tail and swap it with the first zero in the original sequence<br>
Run the algorithm above with original sequence empty.</p>
<pre><code>class Solution {
public:
    void moveZeroes(vector<int>& nums) {

        int nNums( nums.size() );
        int nZeros( 0 );

        for( int i = 0; i < nNums; ++i ){
            if( nums[ i ] == 0 ){
                ++nZeros;
            }else if( nZeros > 0 && i - nZeros >= 0 ){
                swap( nums[ i ], nums[ i - nZeros ] );
            }
        }
    }

    void swap( int &a, int &b ){
        a ^= b ^= a ^= b;
    }
};
</code></pre>
<p>Runtime: 20 ms</p>
      
<h3><a name="100" class="anchor" href="#100"></a>#100 Same Tree (Easy)</h3>
<p>Compare current node, then subtrees recursively. Mind null pointer error.</p>
<pre><code>class Solution {
public:
    bool isSameTree(TreeNode* p, TreeNode* q) {
        if( p == NULL && q == NULL ) return true;
        if( p == NULL && q != NULL ) return false;
        if( p != NULL && q == NULL ) return false;
        if( p->val != q->val ) return false;
        if( !isSameTree( p->left, q->left ) ) return false;
        if( !isSameTree( p->right, q->right ) ) return false;
        return true;
    }
};
</code></pre>
<p>Runtime: 0 ms</p>
      
<h3><a name="226" class="anchor" href="#226"></a>#226 Invert Binary Tree (Easy)</h3>
<p>Recursively swap left subtree and right subtree.</p>
<pre><code>class Solution {
public:
    TreeNode* invertTree(TreeNode* root) {
        
        if( root == NULL ) return NULL;
        
        TreeNode *tmp( root->left );
        root->left = root->right;
        root->right = tmp;
        
        invertTree( root->left );
        invertTree( root->right );
        
        return root;
    }
};
</code></pre>
<p>Runtime: 0 ms</p>
      
<h3><a name="242" class="anchor" href="#242"></a>#242 Valid Anagram (Easy)</h3>
<p>Simply compare occurrence of letters in each word.</p>
<pre><code>class Solution {
public:
    bool isAnagram(string s, string t) {
        
        if( s.length() != t.length() ) return false;
        
        int len( s.length() );
        int count[ 26 ];
        
        memset( count, 0, sizeof count );
        
        for( int i = 0; i < len; ++i ){
            ++count[ s[ i ] - ( int )'a' ];
            --count[ t[ i ] - ( int )'a' ];
        }
        
        for( int i = 0; i < 26; ++i ){
            if( count[ i ] ) return false;
        }
        
        return true;
    }
};
</code></pre>
<p>Runtime: 12 ms</p>
      
<h3><a name="217" class="anchor" href="#217"></a>#217 Contains Duplicate (Easy)</h3>
<p>Use std::unordered_set.</p>
<pre><code>class Solution {
public:
    bool containsDuplicate(vector<int>& nums) {
        
        unordered_set< int > uset;
        
        for( int num : nums ){
            
            if( uset.find( num ) != uset.end() )
                return true;
            else
                uset.insert( num );
        }
        
        return false;
    }
};
</code></pre>
<p>Runtime: 48 ms</p>
<p>Runtime (using std::set): 104 ms</p>
      
<h3><a name="171" class="anchor" href="#171"></a>#171 Excel Sheet Column Number (Easy)</h3>
<p>A new type of number with numerical base 26.</p>
<pre><code>class Solution {
public:
    int titleToNumber(string s) {
        
        int len( s.length() );
        int result( 0 );
        
        for( int i = 0; i < len; ++i ){
            if( i ) result *= 26;
            result += s[ i ] - ( int )'A' + 1;
        }
        
        return result;
    }
};
</code></pre>
<p>Runtime: 8 ms</p>
      
<h3><a name="169" class="anchor" href="#169"></a>#169 Majority Element (Easy)</h3>
<p>Since we are given the condition "majority element always exists", its number of occurrence is greater than that of other numbers. Subtract the number of occurrence of the currently expected ME by number of occurrence of other numbers.</p>
<pre><code>class Solution {
public:
    int majorityElement(vector<int>& nums) {

        int majorCount( 0 );
        int majorNum( 0 );
    
        for( int num : nums ){
            if( majorCount == 0 ){
                ++majorCount;
                majorNum = num;
            }else if( majorNum == num ){
                ++majorCount;
            }else{
                --majorCount;
            }
        }
        
        return majorNum;
    }
};
</code></pre>
<p>Runtime: 20 ms</p>


<!-- 
<h3>
<a name="designer-templates" class="anchor" href="#designer-templates"><span class="octicon octicon-link"></span></a>Designer Templates</h3>

<p>We've crafted some handsome templates for you to use. Go ahead and continue to layouts to browse through them. You can easily go back to edit your page before publishing. After publishing your page, you can revisit the page generator and switch to another theme. Your Page content will be preserved if it remained markdown format.</p>

<h3>
<a name="rather-drive-stick" class="anchor" href="#rather-drive-stick"><span class="octicon octicon-link"></span></a>Rather Drive Stick?</h3>

<p>If you prefer to not use the automatic generator, push a branch named <code>gh-pages</code> to your repository to create a page manually. In addition to supporting regular HTML content, GitHub Pages support Jekyll, a simple, blog aware static site generator written by our own Tom Preston-Werner. Jekyll makes it easy to create site-wide headers and footers without having to copy them across every page. It also offers intelligent blog support and other advanced templating features.</p>

<h3>
<a name="authors-and-contributors" class="anchor" href="#authors-and-contributors"><span class="octicon octicon-link"></span></a>Authors and Contributors</h3>

<p>You can <a href="https://github.com/blog/821" class="user-mention">@mention</a> a GitHub username to generate a link to their profile. The resulting <code>&lt;a&gt;</code> element will link to the contributor's GitHub Profile. For example: In 2007, Chris Wanstrath (<a href="https://github.com/defunkt" class="user-mention">@defunkt</a>), PJ Hyett (<a href="https://github.com/pjhyett" class="user-mention">@pjhyett</a>), and Tom Preston-Werner (<a href="https://github.com/mojombo" class="user-mention">@mojombo</a>) founded GitHub.</p>

<h3>
<a name="support-or-contact" class="anchor" href="#support-or-contact"><span class="octicon octicon-link"></span></a>Support or Contact</h3>

<p>Having trouble with Pages? Check out the documentation at <a href="http://help.github.com/pages">http://help.github.com/pages</a> or contact <a href="mailto:support@github.com">support@github.com</a> and weâ€™ll help you sort it out.</p>
 -->
      </section>
    </div>

    <!-- FOOTER  -->
    <div id="footer_wrap" class="outer">
      <footer class="inner">
        <p class="copyright">Blogtest maintained by <a href="https://github.com/itoupeter">itoupeter</a></p>
        <p>Published with <a href="http://pages.github.com">GitHub Pages</a></p>
      </footer>
    </div>

    

  </body>
</html>
