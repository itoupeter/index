<!DOCTYPE html>
<html>

  <head>
   <meta charset='utf-8'>
   <meta http-equiv="X-UA-Compatible" content="chrome=1">
   <meta name="description" content="Blogtest : PL&#39;s Blog Test">

   <link rel="stylesheet" type="text/css" media="screen" href="stylesheets/stylesheet.css">

   <title>Algorithm and Data Structure</title>
  </head>

  <body>

   <!-- HEADER -->
   <div id="header_wrap" class="outer">
      <header class="inner">
<!--
       <a id="forkme_banner" href="https://github.com/itoupeter/blogtest">View on GitHub</a>
 -->
       <h1 id="project_title">Algorithm and Data Structure</h1>
       <h2 id="project_tagline">Problem Source: <a href="https://leetcode.com/problemset/algorithms/">LeetCode</a></h2>
       <!-- <h2 id="project_tagline">Problems Solved: 155</h2> -->
       <h2 id="project_tagline">Use Ctrl+F to find solution:)</h2>
<!--
        <section id="downloads">
          <a class="zip_download_link" href="https://github.com/itoupeter/blogtest/zipball/master">Download this project as a .zip file</a>
          <a class="tar_download_link" href="https://github.com/itoupeter/blogtest/tarball/master">Download this project as a tar.gz file</a>
        </section>
 -->
      </header>
   </div>

   <!-- MAIN CONTENT -->
   <div id="main_content_wrap" class="outer">
    <section id="main_content" class="inner">

<h3><a name="344" class="anchor" href="#344"><span class="octicon octicon-link"></span></a>#344 Reverse String (Easy)</h3>
<p>Scan first half and swap characters.</p>
<pre><code>
class Solution {
public:
    string reverseString(string s) {

        int length( s.length() );
        char ch;

        for( int i = 0; i < length >> 1; ++i ){
            swap( s[ i ], s[ length - i - 1 ] );
        }

        return s;
    }
};
</code></pre>
<p>Runtime: 12 ms</p>

<h3><a name="126" class="anchor" href="#126"><span class="octicon octicon-link"></span></a>#126 Word Ladder II (Hard)</h3>
<p>Build graph using BFS starting from endWord, for each node record its distance to endWord, then find all solutions using DFS from beginWord to endWord with decreasing distance.</p>
<pre><code>
struct Node {
	Node(string word, int dist) {
		this->word = word;
		this->dist = dist;
	}

	int dist;
	string word;
	vector<int> next;
};

class Solution {
public:
    vector<vector<string>> findLadders(string beginWord, string endWord, unordered_set<string> &wordList) {
        if (beginWord.length() != endWord.length()) {
			return vector<vector<string>>();
		}

        current.clear();
        result.clear();
		graph.clear();
		id.clear();
		for(; !q.empty(); q.pop());

		wordList.insert(beginWord);
		wordList.insert(endWord);
		buildGraph(endWord, wordList);

		if (id.find(beginWord) == id.end()) {
		    return result;
		}

		findPath(beginWord, endWord);

		return result;
    }

	void buildGraph(string endWord, unordered_set<string> &dict) {
		q.push(make_pair(endWord, 0));
		id[endWord] = graph.size();
		graph.push_back(Node(endWord, 0));

		while (!q.empty()) {
			string word = q.front().first;
			int dist = q.front().second;
			int len = word.length();

			for (int i = 0; i < len; ++i) {
				// change one (ith) character
				for (char ch = 'a'; ch <= 'z'; ++ch) {
					string newWord = word;

					newWord[i] = ch;
					if (dict.find(newWord) == dict.end()) {
						// not in dict
						continue;
					}
					if (id.find(newWord) == id.end()) {
					    // new word
			            id[newWord] = graph.size();
                        graph.push_back(Node(newWord, dist + 1));
    					q.push(make_pair(newWord, dist + 1));
					}
					if (newWord != word) {
    			    	graph[id[word]].next.push_back(id[newWord]);
					}
				}
			}

			q.pop();
		}
	}

	void findPath(string beginWord, string endWord) {
	    current.push_back(beginWord);
	    helper(id[beginWord], graph[id[beginWord]].dist);
	}

	void helper(int id, int dist) {
	    if (dist == 0) {
	       result.push_back(current);
	       return;
	    }

	    for (int i : graph[id].next) {
	        if (graph[i].dist >= dist) {
	            continue;
	        }
	        current.push_back(graph[i].word);
	        helper(i, dist - 1);
	        current.pop_back();
	    }
	}

private:
	vector<Node> graph;
	unordered_map<string, int> id;
	queue<pair<string, int>> q;
	vector<vector<string>> result;
	vector<string> current;
};
</code></pre>
<p>Runtime: 565 ms</p>

<h3><a name="65" class="anchor" href="#65"><span class="octicon octicon-link"></span></a>#65 Valid Number (Hard)</h3>
<p>Complex state machine.</p>
<img src="images/NO65.jpg" width="650"></img>
<pre><code>
class Solution {
public:
    bool isNumber(string s) {

		if (s.empty()) {
			return false;
		}

		int length = (s += "#END#").length();
		int ptr = 0;
		enum state {
			START, DECIMAL_SIGN, INTEGER_DIGIT, DECIMAL_POINT, FRACTIONAL_DIGIT,
			E, EXPONENT_SIGN, EXPONENT_DIGIT, SPACE, TERMINATION, INVALID
		} stateId;
		bool isDecimalPointOnlyError = false;

		while (ptr < length && s[ptr] == ' ') {
			++ptr;
		}

		stateId = START;
		while (ptr < length) {
			char nxt = s[ptr];

			if (stateId == START) {
				if (nxt == '+' || nxt == '-') {
					stateId = DECIMAL_SIGN;
				} else if (nxt >= '0' && nxt <= '9') {
					stateId = INTEGER_DIGIT;
				} else if (nxt == '.') {
					isDecimalPointOnlyError = true;
					stateId = DECIMAL_POINT;
				} else {
					break;
				}

			} else if (stateId == DECIMAL_SIGN) {
				if (nxt >= '0' && nxt <= '9') {
					stateId = INTEGER_DIGIT;
				}else if (nxt == '.') {
					isDecimalPointOnlyError = true;
					stateId = DECIMAL_POINT;
				} else {
					break;
				}

			} else if (stateId == INTEGER_DIGIT) {
				if (nxt == ' ') {
					stateId = SPACE;
				} else if (nxt >= '0' && nxt <= '9') {
					// state unchanged
				} else if (nxt == '.') {
					stateId = DECIMAL_POINT;
				} else if (nxt == 'e' || nxt == 'E') {
					stateId = E;
				} else if (nxt == '#' && s.substr(ptr, 5) == "#END#") {
					stateId = TERMINATION;
					break;
				} else {
					break;
				}

			} else if (stateId == DECIMAL_POINT) {
				if (nxt == ' ') {
					stateId = SPACE;
				} else if (nxt >= '0' && nxt <= '9') {
					isDecimalPointOnlyError = false;
					stateId = FRACTIONAL_DIGIT;
				} else if (nxt == 'e' || nxt == 'E') {
					stateId = E;
				} else if (nxt == '#' && s.substr(ptr, 5) == "#END#") {
					stateId = TERMINATION;
					break;
				} else {
					break;
				}

				if (isDecimalPointOnlyError) {
					break;
				}

			} else if (stateId == FRACTIONAL_DIGIT) {
				if (nxt == 'e' || nxt == 'E') {
					stateId = E;
				} else if (nxt >= '0' && nxt <= '9') {
					// state unchanged
				} else if (nxt == ' ') {
					stateId = SPACE;
				} else if (nxt == '#' && s.substr(ptr, 5) == "#END#") {
					stateId = TERMINATION;
					break;
				} else {
					break;
				}

			} else if (stateId == E) {
				if (nxt == '+' || nxt == '-') {
					stateId = EXPONENT_SIGN;
				} else if (nxt >= '0' && nxt <= '9') {
					stateId = EXPONENT_DIGIT;
				} else {
					break;
				}

			} else if (stateId == EXPONENT_SIGN) {
				if (nxt >= '0' && nxt <= '9') {
					stateId = EXPONENT_DIGIT;
				} else if (nxt == ' ') {
					stateId = SPACE;
				} else {
					break;
				}

			} else if (stateId == EXPONENT_DIGIT) {
				if (nxt >= '0' && nxt <= '9') {
					// state unchanged
				} else if (nxt == ' ') {
					stateId = SPACE;
				} else if (nxt == '#' && s.substr(ptr, 5) == "#END#") {
					stateId = TERMINATION;
					break;
				} else {
					break;
				}

			} else if (stateId == SPACE) {
				if (nxt == ' ') {
					// state unchanged
				} else if (nxt == '#' && s.substr(ptr, 5) == "#END#") {
					stateId = TERMINATION;
					break;
				} else {
					break;
				}
			}

			++ptr;
		}

		return stateId == TERMINATION && !isDecimalPointOnlyError;
    }
};
</code></pre>
<p>Runtime: 6 ms</p>

<h3><a name="343" class="anchor" href="#343"><span class="octicon octicon-link"></span></a>#343 Integer Break (Medium)</h3>
<p>Dynamic Programming.</p>
<pre><code>
class Solution {
public:
    int integerBreak(int n) {
        vector<int> f(n + 1, 0);

		f[1] = 1;
		for (int i = 2; i <= n; ++i) {
			for (int j = 1; j <= (i >> 1); ++j) {
				f[i] = max(f[i], j * (i - j));
				f[i] = max(f[i], f[j] * (i - j));
				f[i] = max(f[i], j * f[i - j]);
				f[i] = max(f[i], f[j] * f[i - j]);
			}
		}

		return f[n];
    }
};
</code></pre>
<p>Runtime: 3 ms</p>

<h3><a name="357" class="anchor" href="#357"><span class="octicon octicon-link"></span></a>#357 Count Numbers with Unique Digits (Medium)</h3>
<p>Number of unique numbers using i digits can be computed based on number of unique numbers using i-1 digits.</p>
<pre><code>
class Solution {
public:
    int countNumbersWithUniqueDigits(int n) {
		if (n == 0) {
			return 1;
		} else if (n == 1) {
			return 10;
		} else if (n > 10) {
			n = 10;
		}

		vector<int> vi(11);

		vi[1] = 9;
		for (int i = 2; i <= n; ++i) {
			vi[i] = vi[i - 1] * (11 - i);
		}

		vi[1] = 10;
		for (int i = 2; i <= n; ++i) {
			vi[i] += vi[i - 1];
		}

		return vi[n];
    }
};
</code></pre>
<p>Runtime: 0 ms</p>

<h3><a name="392" class="anchor" href="#392"><span class="octicon octicon-link"></span></a>#392 Is Subsequence (Medium)</h3>
<p>Pointer i, j scan s, t respectively. If s[i] == t[j], move i, j forwards, else move j forwards only.</p>
<pre><code>
class Solution {
public:
    bool isSubsequence(string s, string t) {
        if (s.empty()) {
			return true;
		} else if (t.empty() || s.length() > t.length()) {
			return false;
		}

		int lenS = s.length();
		int lenT = t.length();
		int i = 0;

		for (int j = 0; i < lenS && j < lenT; ++i, ++j) {
			while (j < lenT && s[i] != t[j]) {
				++j;
			}
		}

		return i == lenS;
    }
};
</code></pre>
<p>Runtime: 72 ms</p>

<h3><a name="339" class="anchor" href="#339"><span class="octicon octicon-link"></span></a>#339 Shuffle an Array (Medium)</h3>
<p>Let all numbers be in the pool, each time randomly pick a number from the pool and append it to the result list.</p>
<pre><code>
class Solution {
public:
	Solution(vector<int> nums) {
	    this->nums = nums;
		this->numsShuffled = nums;
	}

	/** Resets the array to its original configuration and return it. */
	vector<int> reset() {
		return nums;
	}

	/** Returns a random shuffling of the array. */
	vector<int> shuffle() {
	    int n = nums.size();

		for (int i = 0; i < n - 1; ++i) {
			int j = rand() % (n - i);
			swap(numsShuffled[i], numsShuffled[j + i]);
		}

		return numsShuffled;
	}

private:
    vector<int> nums;
	vector<int> numsShuffled;
};
</code></pre>
<p>Runtime: 339 ms</p>

<h3><a name="167" class="anchor" href="#167"><span class="octicon octicon-link"></span></a>#167 Two Sum II - Input array is sorted (Medium)</h3>
<p>Pointer i, j scan from head to tail, tail to head respectively. If two sum is greater that target, move j backwards; else move i forwards.</p>
<pre><code>
class Solution {
public:
	vector<int> twoSum(vector<int>& numbers, int target) {
		int n = numbers.size();

		if (n < 2) {
			return vector<int>{-1, -1};
		}

		int i = 0;
		int j = n - 1;

		while (i < j && numbers[i] + numbers[j] != target) {
			if (numbers[i] + numbers[j] < target) {
				++i;
			} else {
				--j;
			}
		}

		return i < j ? vector<int>{i + 1, j + 1} : vector<int>{-1, -1};
    }
};
</code></pre>
<p>Runtime: 6 ms</p>

<h3><a name="406" class="anchor" href="#406"><span class="octicon octicon-link"></span></a>#406 Queue Reconstruction by Height (Medium)</h3>
<p>Sort by h (taller first) and k (smaller first), then for each person, shift him ahead until satisfying requirement on k.</p>
<pre><code>class Solution {
public:
	vector<pair<int, int>> reconstructQueue(vector<pair<int, int>>& people) {

		int n = people.size();

		if (n == 0) {
			return vector<pair<int, int>>();
		}

	    sort(people.begin(), people.end(), comparePeople);

		for (int i = 1; i < n; ++i) {
			for (int j = i; people[j].second < j; --j) {
				swap(people[j], people[j - 1]);
			}
		}

		return people;
	}

private:
	static bool comparePeople(const pair<int, int> &a, const pair<int, int> &b) {
		return (a.first == b.first) ? (a.second < b.second) : (a.first > b.first);
	}
};
</code></pre>
<p>Runtime: 139 ms</p>

<h3><a name="338" class="anchor" href="#338"><span class="octicon octicon-link"></span></a>#338 Counting Bits (Medium)</h3>
<p>Number of 1 in i is: <br>1) number of 1 in i/2 if i is even, <br>2) number of 1 in i/2 plus 1 if i is odd. </p>
<pre><code>
class Solution {
public:
    vector<int> countBits(int num) {

        vector<int> result(num + 1);

		result[0] = 0;
		for (int i = 1; i <= num; ++i) {
			result[i] = (i & 1) ? result[i >> 1] + 1: result[i >> 1];
		}

		return result;
    }
};
</code></pre>
<p>Runtime: 103 ms</p>

<h3><a name="292" class="anchor" href="#292"><span class="octicon octicon-link"></span></a>#292 Nim Game (Easy)</h3>
<p>Determine if n can be exactly divided by 4. If yes, you lose, else you win.</p>
<pre><code>class Solution {
public:
   bool canWinNim(int n) {
      return n & 3;
   }
};
</code></pre>
<p>Runtime: 0 ms</p>

<h3><a name="389" class="anchor" href="#389"><span class="octicon octicon-link"></span></a>#389 Find the Difference (Easy)</h3>
<p>Simply count letters in s and t.</p>
<pre><code>class Solution {
public:
	char findTheDifference(string s, string t) {

		int count[256];

		memset(count, 0, sizeof count);

		for (auto &ch : s) {
			++count[(int)ch];
		}

		for (auto &ch : t) {
			if (--count[(int)ch] == -1) {
				return ch;
			}
		}

		return 'A';
	}
};
</code></pre>
<p>Runtime: 3 ms</p>

<h3><a name="345" class="anchor" href="#345"><span class="octicon octicon-link"></span></a>#345 Reverse Vowels of a String (Easy)</h3>
<p>Scan from both ends and swap vowels.</p>
<pre><code>class Solution {
public:
	string reverseVowels(string s) {

		int length = s.length();
		int i = 0;
		int j = length - 1;
		char tmp;

		while( i < j ){
			while( !isVowel( s[ i ] ) && i < j ) ++i;
			while( !isVowel( s[ j ] ) && i < j ) --j;
			if( i < j ){
				tmp = s[ i ];
				s[ i ] = s[ j ];
				s[ j ] = tmp;
			}
			++i;
			--j;
		}

		return s;
	}

private:
	bool isVowel( char ch ){
		return ch == 'a' || ch == 'e' || ch == 'i' || ch == 'o' || ch == 'u'
			|| ch == 'A' || ch == 'E' || ch == 'I' || ch == 'O' || ch == 'U';
	}
};
</code></pre>
<p>Runtime: 16 ms</p>

<h3><a name="350" class="anchor" href="#350"><span class="octicon octicon-link"></span></a>#350 Intersection of Two Arrays II (Easy)</h3>
<p>Application of map.</p>
<pre><code>class Solution {
public:
	vector<int> intersect(vector<int>& nums1, vector<int>& nums2) {

		map< int, int > map1;
		vector< int > intersection;

		for( auto i : nums1 ){

			auto ite = map1.find( i );

			if( ite == map1.end() ){
				map1[ i ] = 1;
			}else{
				++ite->second;
			}
		}

		for( auto i : nums2 ){

			auto ite = map1.find( i );

			if( ite != map1.end() ){
				intersection.push_back( i );
				if( --ite->second == 0 ){
					map1.erase( ite );
				}
			}
		}

		return intersection;
	}
};
</code></pre>
<p>Runtime: 16 ms</p>

<h3><a name="349" class="anchor" href="#349"><span class="octicon octicon-link"></span></a>#349 Intersection of Two Arrays (Easy)</h3>
<p>Application of unordered_set.</p>
<pre><code>class Solution {
public:
	vector<int> intersection(vector<int>& nums1, vector<int>& nums2) {

		vector< int > intersection;
		unordered_set< int > uset1, uset2;

		for( auto i : nums1 ){
			uset1.insert( i );
		}

		for( auto i : nums2 ){
			if( uset1.find( i ) != uset1.end() ){
				uset2.insert( i );
			}
		}

		for( auto i : uset2 ){
			intersection.push_back( i );
		}

		return intersection;
	}
};
</code></pre>
<p>Runtime: 12 ms</p>

<h3><a name="371" class="anchor" href="#371"><span class="octicon octicon-link"></span></a>#371 Sum of Two Integers (Easy)</h3>
<p>Use AND to compute carry, lshift it by 1 bit and sum it to result of XOR till no carry.</p>
<pre><code>class Solution {
public:
    int getSum(int a, int b) {

		int c;

        while( b ){
			c = ( a & b ) << 1;
			a = a ^ b;
			b = c;
		}

		return a;
    }
};
</code></pre>
<p>Runtime: 0 ms</p>

<h3><a name="258" class="anchor" href="#258"></a>#258 Add Digits (Easy)</h3>
<p>There are 10 possible results. If num is 0, print 0. Else if num can be exactly divided by 9, print 9. Else print the remainder.</p>
<pre><code>class Solution {
public:
   int addDigits(int num) {
      return ( num - 1 ) % 9 + 1;
   }
};
</code></pre>
<p>Runtime: 8 ms</p>

<h3><a name="104" class="anchor" href="#104"></a>#104 Maximum Depth of Binary Tree (Easy)</h3>
<p>Recursively find maximum depth of subtrees of the current node, return the larger one incremented by 1.</p>
<pre><code>class Solution {
public:
   int maxDepth(TreeNode* root) {
      return root? max( maxDepth( root->left ), maxDepth( root->right ) ) + 1 : 0;
   }
};
</code></pre>
<p>Runtime: 8 ms</p>

<h3><a name="237" class="anchor" href="#237"></a>#237 Delete Node in a Linked List (Easy)</h3>
<p>Instead of delete the given node, replace it by its next node and delete the next node.</p>
<pre><code>class Solution {
public:
   void deleteNode(ListNode* node) {

      ListNode *nextNode( node->next );
      ListNode *nextNextNode( nextNode->next );

      node->val = nextNode->val;
      node->next = nextNextNode;

      delete nextNode;
   }
};
</code></pre>
<p>Runtime: 20 ms</p>

<h3><a name="283" class="anchor" href="#283"></a>#283 Move Zeroes (Easy)</h3>
<p>Suppose we already have a "sorted" sequence in the form [num,...,num,0,...,0] and here comes a:<br>
I) zero: simply add it to the tail<br>
II) non-zero: add it to the tail and swap it with the first zero in the original sequence<br>
Run the algorithm above with original sequence empty.</p>
<pre><code>class Solution {
public:
   void moveZeroes(vector< int >& nums) {

      int nNums( nums.size() );
      int nZeros( 0 );

      for( int i = 0; i < nNums; ++i ){
        if( nums[ i ] == 0 ){
          ++nZeros;
        }else if( nZeros > 0 && i - nZeros >= 0 ){
          swap( nums[ i ], nums[ i - nZeros ] );
        }
      }
   }

   void swap( int &a, int &b ){
      a ^= b ^= a ^= b;
   }
};
</code></pre>
<p>Runtime: 20 ms</p>

<h3><a name="100" class="anchor" href="#100"></a>#100 Same Tree (Easy)</h3>
<p>Compare current node, then subtrees recursively. Mind null pointer error.</p>
<pre><code>class Solution {
public:
   bool isSameTree(TreeNode* p, TreeNode* q) {
      if( p == NULL && q == NULL ) return true;
      if( p == NULL && q != NULL ) return false;
      if( p != NULL && q == NULL ) return false;
      if( p->val != q->val ) return false;
      if( !isSameTree( p->left, q->left ) ) return false;
      if( !isSameTree( p->right, q->right ) ) return false;
      return true;
   }
};
</code></pre>
<p>Runtime: 0 ms</p>

<h3><a name="226" class="anchor" href="#226"></a>#226 Invert Binary Tree (Easy)</h3>
<p>Recursively swap left subtree and right subtree.</p>
<pre><code>class Solution {
public:
   TreeNode* invertTree(TreeNode* root) {

      if( root == NULL ) return NULL;

      TreeNode *tmp( root->left );
      root->left = root->right;
      root->right = tmp;

      invertTree( root->left );
      invertTree( root->right );

      return root;
   }
};
</code></pre>
<p>Runtime: 0 ms</p>

<h3><a name="242" class="anchor" href="#242"></a>#242 Valid Anagram (Easy)</h3>
<p>Simply compare occurrence of letters in each word.</p>
<pre><code>class Solution {
public:
   bool isAnagram(string s, string t) {

      if( s.length() != t.length() ) return false;

      int len( s.length() );
      int count[ 26 ];

      memset( count, 0, sizeof count );

      for( int i = 0; i < len; ++i ){
        ++count[ s[ i ] - ( int )'a' ];
        --count[ t[ i ] - ( int )'a' ];
      }

      for( int i = 0; i < 26; ++i ){
        if( count[ i ] ) return false;
      }

      return true;
   }
};
</code></pre>
<p>Runtime: 12 ms</p>

<h3><a name="217" class="anchor" href="#217"></a>#217 Contains Duplicate (Easy)</h3>
<p>Use std::unordered_set.</p>
<pre><code>class Solution {
public:
   bool containsDuplicate(vector< int >& nums) {

      unordered_set< int > uset;

      for( int num : nums ){

        if( uset.find( num ) != uset.end() )
          return true;
        else
          uset.insert( num );
      }

      return false;
   }
};
</code></pre>
<p>Runtime: 48 ms</p>
<p>Runtime (using std::set): 104 ms</p>

<h3><a name="171" class="anchor" href="#171"></a>#171 Excel Sheet Column Number (Easy)</h3>
<p>A new type of number with numerical base 26.</p>
<pre><code>class Solution {
public:
   int titleToNumber(string s) {

      int len( s.length() );
      int result( 0 );

      for( int i = 0; i < len; ++i ){
        if( i ) result *= 26;
        result += s[ i ] - ( int )'A' + 1;
      }

      return result;
   }
};
</code></pre>
<p>Runtime: 8 ms</p>

<h3><a name="169" class="anchor" href="#169"></a>#169 Majority Element (Easy)</h3>
<p>Since we are given the condition "majority element always exists", its number of occurrence is greater than that of other numbers. Subtract the number of occurrence of the currently expected ME by number of occurrence of other numbers.</p>
<pre><code>class Solution {
public:
   int majorityElement(vector< int >& nums) {

      int majorCount( 0 );
      int majorNum( 0 );

      for( int num : nums ){
        if( majorCount == 0 ){
          ++majorCount;
          majorNum = num;
        }else if( majorNum == num ){
          ++majorCount;
        }else{
          --majorCount;
        }
      }

      return majorNum;
   }
};
</code></pre>
<p>Runtime: 20 ms</p>

<h3><a name="235" class="anchor" href="#235"></a>#235 Lowest Common Ancestor of a Binary Search Tree (Easy)</h3>
<p>Since the given tree is a BST, value of LCA must be between values of p and q.</p>
<pre><code>class Solution {
public:
   TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {

      if( p->val > q->val ){
        TreeNode *tmp( p );
        p = q;
        q = tmp;
      }

      if( root == p || root == q )
        return root;
      else if( root->val > p->val && root->val <= q->val )
        return root;
      else if( q->val < root->val )
        return lowestCommonAncestor( root->left, p, q );
      else
        return lowestCommonAncestor( root->right, p, q );
   }

};
</code></pre>
<p>Runtime: 44 ms</p>

<h3><a name="191" class="anchor" href="#191"></a>#191 Number of 1 Bits (Easy)</h3>
<p>Simple counting.</p>
<pre><code>class Solution {
public:
   int hammingWeight(uint32_t n) {
      n = ( n & 0x55555555U ) + ( n >> 1 & 0x55555555U );
      n = ( n & 0x33333333U ) + ( n >> 2 & 0x33333333U );
      n = ( n & 0x0f0f0f0fU ) + ( n >> 4 & 0x0f0f0f0fU );
      n = ( n & 0x00ff00ffU ) + ( n >> 8 & 0x00ff00ffU );
      n = ( n & 0x0000ffffU ) + ( n >> 16 & 0x0000ffffU );
      return ( int )n;
   }
};
</code></pre>
<p>Runtime: 4 ms</p>

<h3><a name="13" class="anchor" href="#13"></a>#13 Roman to Integer (Easy)</h3>
<p>If a digit is less than its following digit, subtract it from result, else add it to result.</p>
<pre><code>class Solution {
public:
   int romanToInt(string s) {

      static const int r2d[ 26 ]{
        0, 0, 100, 500, 0, 0, 0, 0, 1, 0, 0, 50, 1000,
        0, 0, 0, 0, 0, 0, 0, 0, 5, 0, 10, 0, 0,
      };

      int result( r2d[ s[ 0 ] - ( int )'A'] );
      int pre( result ), cur( 0 );
      int len( s.length() );

      for( int i = 1; i < len; ++i ){
        cur = r2d[ s[ i ] - ( int )'A' ];
        if( cur > pre ) result -= pre << 1;
        result += cur;
        pre = cur;
      }

      return result;
   }
};
</code></pre>
<p>Runtime: 36 ms</p>

<h3><a name="206" class="anchor" href="#206"></a>#206 Reverse Linked List (Easy)</h3>
<p>Use a vector. OK I am cheating.</p>
<pre><code>class Solution {
public:
   ListNode* reverseList(ListNode* head) {

      if( head == NULL ) return NULL;

      vector< ListNode * > nodes;

      for( ListNode *pNode = head; pNode != NULL; pNode = pNode->next ){
        nodes.push_back( pNode );
      }

      for( int i = nodes.size() - 1; i > 0; --i ){
        nodes[ i ]->next = nodes[ i - 1 ];
      }

      nodes[ 0 ]->next = NULL;

      return nodes.back();
   }
};
</code></pre>
<p>Runtime: 8 ms</p>

<h3><a name="70" class="anchor" href="#70"></a>#70 Climbing Stairs (Easy)</h3>
<p>Number of ways to reach nth step can be added up by:<br>
number of ways to reach (n-1)th step (climb 1 step from here) and<br>
number of ways to reach (n-2)th step (climb 2 steps from here).</p>
<pre><code>class Solution {
public:
   int climbStairs(int n) {

      vector< int > v( 2, 1 );

      for( int i = 2; i <= n; ++i ){
        v.push_back( v[ i - 1 ] + v[ i - 2 ] );
      }

      return v[ n ];
   }
};
</code></pre>
<p>Runtime: 0 ms</p>

<h3><a name="83" class="anchor" href="#83"></a>#83 Remove Duplicates from Sorted List (Easy)</h3>
<p>If next node has same value as current node, delete next node (and release memory).</p>
<pre><code>class Solution {
public:
   ListNode* deleteDuplicates(ListNode* head) {

      for( ListNode *cur = head; cur != NULL; ){

        ListNode *nxt( cur->next );

        if( nxt == NULL ) break;
        if( nxt->val == cur->val ){
          cur->next = nxt->next;
          delete nxt;
        }else{
          cur = nxt;
        }
      }

      return head;
   }
};
</code></pre>
<p>Runtime: 16 ms</p>

<h3><a name="263" class="anchor" href="#263"></a>#263 Ugly Number (Easy)</h3>
<p>Divide the number by 2, 3, and 5 repeatedly. If 1 is left, the number is ugly.</p>
<pre><code>class Solution {
public:
   bool isUgly(int num) {

      if( num <= 0 ) return false;

      while( num % 2 == 0 ) num /= 2;
      while( num % 3 == 0 ) num /= 3;
      while( num % 5 == 0 ) num /= 5;

      return num == 1;
   }
};
</code></pre>
<p>Runtime: 4 ms</p>

<h3><a name="202" class="anchor" href="#202"></a>#202 Happy Number (Easy)</h3>
<p>Use std::unordered_set to check if a cycle exists.</p>
<pre><code>class Solution {
public:
   bool isHappy(int n) {

      if( n <= 0 ) return false;

      unordered_set< int > uset;

      while( n != 1 ){
        if( uset.find( n ) != uset.end() )
          return false;
        else{
          uset.insert( n );
          n = nextN( n );
        }
      }

      return true;
   }

   int nextN( int n ){

      int result( 0 ), tmp;

      while( n ){
        tmp = n % 10;
        n /= 10;
        result += tmp * tmp;
      }

      return result;
   }
};
</code></pre>
<p>Runtime: 4 ms</p>

<h3><a name="21" class="anchor" href="#21"></a>#21 Merge Two Sorted Lists (Easy)</h3>
<p>Repeatedly take the larger head node of the lists.</p>
<pre><code>class Solution {
public:
   ListNode* mergeTwoLists(ListNode* l1, ListNode* l2) {

      if( l1 == NULL )
        return l2;
      else if( l2 == NULL )
        return l1;

      ListNode head( 0 ), *tail( &head );

      for( ; l1 != NULL && l2 != NULL; tail = tail->next ){

        if( l1->val < l2->val ){
          tail->next = l1;
          l1 = l1->next;
        }else{
          tail->next = l2;
          l2 = l2->next;
        }
      }

      if( l1 == NULL )
        tail->next = l2;
      else
        tail->next = l1;

      return head.next;
   }
};
</code></pre>
<p>Runtime: 12 ms</p>

<h3><a name="232" class="anchor" href="#232"></a>#232 Implement Queue using Stacks (Easy)</h3>
<p>Take advantage of 2 stacks to get access to both head and tail.</p>
<pre><code>class Queue {
public:
   // Push element x to the back of queue.
   void push(int x) {
      while( !b.empty() ){ a.push( b.top() ); b.pop(); }
      a.push( x );
   }

   // Removes the element from in front of queue.
   void pop(void) {
      while( !a.empty() ){ b.push( a.top() ); a.pop(); }
      b.pop();
   }

   // Get the front element.
   int peek(void) {
      while( !a.empty() ){ b.push( a.top() ); a.pop(); }
      return b.top();
   }

   // Return whether the queue is empty.
   bool empty(void) {
      return a.empty() && b.empty();
   }

   stack< int > a, b;
};
</code></pre>
<p>Runtime: 0 ms</p>

<h3><a name="231" class="anchor" href="#231"></a>#231 Power of 2 (Easy)</h3>
<p>In binary representation, (n & -n) is the rightmost 1 of n. Use it to cancel the rightmost 1 of n (by XOR) and n will be 0 if it is a power of 2.</p>
<pre><code>class Solution {
public:
   bool isPowerOfTwo(int n) {
      return n > 0 && ( n & -n ^ n ) == 0;
   }
};
</code></pre>
<p>Runtime: 4 ms</p>

<h3><a name="110" class="anchor" href="#110"></a>#110 Balanced Binary Tree (Easy)</h3>
<p>Recursively compare depths of subtrees.</p>
<pre><code>class Solution {
public:
   bool isBalanced(TreeNode* root) {

      int depth( 0 );

      return isBalancedAndGetDepth( root, depth );
   }

   bool isBalancedAndGetDepth( TreeNode *root, int &depth ){

      if( root == NULL ) return true;

      int lDepth( 0 ), rDepth( 0 );

      if( !isBalancedAndGetDepth( root->left, lDepth ) ) return false;
      if( !isBalancedAndGetDepth( root->right, rDepth ) ) return false;
      if( lDepth - rDepth > 1 || lDepth - rDepth < -1 ) return false;
      depth = lDepth > rDepth ? lDepth + 1 : rDepth + 1;

      return true;
   }
};
</code></pre>
<p>Runtime: 20 ms</p>

<h3><a name="101" class="anchor" href="#101"></a>#101 Symmetric Tree (Easy)</h3>
<p>For a symmetric tree, its right subtree is a mirror of its left subtree.<br>
For two mirrored trees A and B, A's right subtree is a mirror of B's left subtree, and A's left subtree is a mirror of B's right subtree.</p>
<pre><code>class Solution {
public:
   bool isSymmetric(TreeNode* root) {
      return root == NULL || isMirror( root->left, root->right );
   }

   bool isMirror( TreeNode *left, TreeNode *right ){
      if( left == NULL && right == NULL ) return true;
      if( left != NULL && right == NULL ) return false;
      if( left == NULL && right != NULL ) return false;

      return left->val == right->val
        && isMirror( left->left, right->right )
        && isMirror( left->right, right->left );
   }
};
</code></pre>
<p>Runtime: 4 ms</p>

<h3><a name="27" class="anchor" href="#27"></a>#27 Remove Element (Easy)</h3>
<p>Just remove element.</p>
<pre><code>class Solution {
public:
   int removeElement(vector< int >& nums, int val) {

      int len( nums.size() );

      for( int i = 0; i < len; ++i ){
        if( nums[ i ] != val ) continue;
        while( i < len && nums[ len - 1 ] == val ) --len;
        if( i < len ) nums[ i ] = nums[ --len ];
      }

      return len;
   }
};
</code></pre>
<p>Runtime: 4 ms</p>

<h3><a name="107" class="anchor" href="#107"></a>#107 Binary Tree Level Order Traversal II (Easy)</h3>
<p>Use std::queue to implement BFS and use std::stack to print result in expected order.</p>
<pre><code>class Solution {
public:
   vector< vector< int > > levelOrderBottom(TreeNode* root) {

      if( root == NULL ) return vector< vector< int > >();

      vector< vector< int > > result;
      queue< pair< TreeNode *, int > > mqueue;
      stack< pair< TreeNode *, int > > mstack;

      mqueue.push( make_pair( root, 0 ) );

      while( !mqueue.empty() ){

        TreeNode *node( mqueue.front().first );
        int layer( mqueue.front().second );

        mstack.push( mqueue.front() );
        if( node->right != NULL ) mqueue.push( make_pair( node->right, layer + 1 ) );
        if( node->left != NULL ) mqueue.push( make_pair( node->left, layer + 1 ) );
        mqueue.pop();
      }

      while( !mstack.empty() ){

        vector< int > v;
        int maxLayer( mstack.top().second );

        while( !mstack.empty() && mstack.top().second == maxLayer ){
          v.push_back( mstack.top().first->val );
          mstack.pop();
        }

        result.push_back( v );
      }

      return result;
   }
};
</code></pre>
<p>Runtime: 8 ms</p>

<h3><a name="198" class="anchor" href="#198"></a>#198 House Robber (Easy)</h3>
<p>Dynamic Progromming<br>
a[i] is the maximum value I can get from previous i houses without robbing the ith house,<br>
b[i] is the maximum value I can get from previous i houses with robbing the ith house,<br>
Then we have:<br>
a[i+1] = max{ a[i], b[i] }, without robbing (i+1)th house,<br>
b[i+1] = a[i] + {value of (i+1)th house}, with robbing (i+1)th house.</p>
<pre><code>class Solution {
public:
   int rob(vector< int >& nums) {

      int nNums( nums.size() );
      vector< int > a( nNums + 1, 0 ), b( nNums + 1, 0 );

      for( int i = 0; i < nNums; ++i ){
        a[ i + 1 ] = max( a[ i ], b[ i ] );
        b[ i + 1 ] = a[ i ] + nums[ i ];
      }

      return max( a[ nNums ], b[ nNums ] );
   }
};
</code></pre>
<p>Runtime: 0 ms</p>

<h3><a name="26" class="anchor" href="#26"></a>#26 Remove Duplicates from Sorted Array (Easy)</h3>
<p>Iterate and remove duplicates.</p>
<pre><code>class Solution {
public:
   int removeDuplicates(vector< int >& nums) {

      if( nums.empty() ) return 0;

      int nNums( nums.size() ), result( 1 );

      for( int i = 1; i < nNums; ++i ){
        if( nums[ i ] != nums[ i - 1 ] ){
          nums[ result++ ] = nums[ i ];
        }
      }

      return result;
   }
};
</code></pre>
<p>Runtime: 32 ms</p>

<h3><a name="66" class="anchor" href="#66"></a>#66 Plus One (Easy)</h3>
<p>Simple iteration. Increment from least significant digit and break if no carry.</p>
<pre><code>class Solution {
public:
   vector< int > plusOne(vector< int >& digits) {

      vector< int > result;
      int nDigits( digits.size() );
      bool carry( true );

      for( int i = nDigits - 1; i >= 0; --i ){
        if( ++digits[ i ] > 9 ){
          digits[ i ] -= 10;
        }else{
          carry = false;
          break;
        }
      }

      if( carry ) result.push_back( 1 );
      result.insert( result.end(), digits.begin(), digits.end() );

      return result;
   }
};
</code></pre>
<p>Runtime: 4 ms</p>

<h3><a name="118" class="anchor" href="#118"></a>#118 Pascal's Triangle (Easy)</h3>
<p>a[i,1] = a[i,i] = 1<br>
a[i,j] = a[i-1,j-1] + a[i-1,j].</p>
<pre><code>class Solution {
public:
   vector< vector< int > > generate(int numRows) {

      if( numRows == 0 ) return vector< vector< int > >();

      vector< vector< int > > result{{1}};

      for( int i = 2; i <= numRows; ++i ){

        vector< int > v{1};

        for( int j = 1; j <= i - 2; ++j ){
          v.push_back( result[ i - 2 ][ j - 1 ] + result[ i - 2 ][ j ] );
        }

        v.push_back( 1 );
        result.push_back( v );
      }

      return result;
   }
};
</code></pre>
<p>Runtime: 0 ms</p>

<h3><a name="172" class="anchor" href="#172"></a>#172 Factorial Trailing Zeroes (Easy)</h3>
<p>Since trailing zeroes are produced by 2 and 5 (2*5=10) in n!'s factors and 5 appears less frequently, simply count number of occurrence of 5 in n!'s factors.</p>
<pre><code>class Solution {
public:
   int trailingZeroes(int n) {

      int result( 0 );
      long long N( n ), powerOf5( 5 );

      while( N >= powerOf5 ){
        result += ( int )( N / powerOf5 );
        powerOf5 *= 5LL;
      }

      return result;
   }
};
</code></pre>
<p>Runtime: 4 ms</p>

<h3><a name="119" class="anchor" href="#119"></a>#119 Pascal's Triangle II (Easy)</h3>
<p>Reverse order of calculation so that next row can be produced in place.</p>
<pre><code>class Solution {
public:
   vector< int > getRow(int rowIndex) {

      vector< int > result{ 1 };

      for( int i = 1; i <= rowIndex; ++i ){
        for( int j = i - 1; j > 0; --j ){
          result[ j ] += result[ j - 1 ];
        }
        result.push_back( 1 );
      }

      return result;
   }
};
</code></pre>
<p>Runtime: 0 ms</p>

<h3><a name="102" class="anchor" href="#102"></a>#102 Binary Tree Level Order Traversal (Easy)</h3>
<p>Use a queue to implement BFS.</p>
<pre><code>class Solution {
public:
   vector< vector< int > > levelOrder(TreeNode* root) {

      if( root == NULL ) return vector< vector< int > >();

      vector< vector< int > > result;
      vector< int > v;
      queue< pair< TreeNode *, int > > mqueue;
      int currentLevel( 0 );

      mqueue.push( make_pair( root, 0 ) );

      while( !mqueue.empty() ){

        TreeNode *node( mqueue.front().first );
        int nodeLevel( mqueue.front().second );

        if( nodeLevel != currentLevel ){
          result.push_back( v );
          v.clear();
          ++currentLevel;
        }

        v.push_back( node->val );

        if( node->left != NULL ){
          mqueue.push( make_pair( node->left, currentLevel + 1 ) );
        }
        if( node->right != NULL ){
          mqueue.push( make_pair( node->right, currentLevel + 1 ) );
        }

        mqueue.pop();
      }

      result.push_back( v );

      return result;
   }
};
</code></pre>
<p>Runtime: 8 ms</p>

<h3><a name="112" class="anchor" href="#112"></a>#112 Path Sum (Easy)</h3>
<p>If there's a path from current node to leaf summed to {Sum}, there's a path from its child node to leaf Summed to {Sum - value of current node}.</p>
<pre><code>class Solution {
public:
   bool hasPathSum(TreeNode* root, int sum) {

      if( root == NULL ) return false;
      if( root->left == NULL && root->right == NULL ){
        return root->val == sum;
      }else{
        sum -= root->val;
        if( root->left != NULL && hasPathSum( root->left, sum ) ) return true;
        if( root->right != NULL && hasPathSum( root->right, sum ) ) return true;
        return false;
      }
   }
};
</code></pre>
<p>Runtime: 12 ms</p>

<h3><a name="225" class="anchor" href="#225"></a>#225 Implement Stack using Queues (Easy)</h3>
<p>Take advantage of 2 queues to get access to both head and tail.</p>
<pre><code>class Stack {
public:
   // Push element x onto stack.
   void push(int x) {
      b.push( x );
   }

   // Removes the element on top of the stack.
   void pop() {
      if( !b.empty() ){
        while( b.size() > 1 ){ a.push( b.front() ); b.pop(); }
        b.pop();
      }else{
        while( !a.empty() ){ b.push( a.front() ); a.pop(); }
        pop();
      }
   }

   // Get the top element.
   int top() {
      if( !b.empty() ){
        while( b.size() > 1 ){ a.push( b.front() ); b.pop(); }
        return b.front();
      }else{
        while( !a.empty() ){ b.push( a.front() ); a.pop(); }
        return top();
      }
   }

   // Return whether the stack is empty.
   bool empty() {
      return a.empty() && b.empty();
   }

   queue< int > a, b;
};
</code></pre>
<p>Runtime: 0 ms</p>

<h3><a name="9" class="anchor" href="#9"></a>#9 Panlindrome Number (Easy)</h3>
<p>(Discussion) Reverse till half and compare.</p>
<pre><code>class Solution {
public:
   bool isPalindrome(int x) {

      if( x < 0 || x != 0 && x % 10 == 0 ) return false;

      int y( 0 );

      while( x >= y ){
        if( x == y || x / 10 == y ) return true;
        y = y * 10 + x % 10;
        x /= 10;
      }

      return false;
   }
};
</code></pre>
<p>Runtime: 80 ms</p>

<h3><a name="111" class="anchor" href="#111"></a>#111 Minimum Depth of Binary Tree (Easy)</h3>
<p>Recursively find min depth. Trim branches deeper than current min depth.</p>
<pre><code>class Solution {
public:
   int minDepth(TreeNode* root) {

      if( root == NULL ) return 0;

      result = 0x7fffffff;
      traverse( root, 1 );

      return result;
   }

   void traverse( TreeNode *root, int depth ){

      if( root->left == NULL && root->right == NULL )
        result = depth;
      else if( result <= depth )
        return;
      else{
        if( root->left != NULL ) traverse( root->left, depth + 1 );
        if( root->right != NULL ) traverse( root->right, depth + 1 );
      }
   }

   int result;
};
</code></pre>
<p>Runtime: 12 ms</p>

<h3><a name="160" class="anchor" href="#160"></a>#160 Intersection of Two Linked Lists (Easy)</h3>
<p>Calculate difference of length of the given lists D.<br>
Two pointers walk on the lists, with the pointer on longer list walked D steps in advance.<br>
The intersection is where they meet.</p>
<pre><code>class Solution {
public:
   ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {

      ListNode *ptrA( headA ), *ptrB( headB );
      ListNode *tailA( NULL ), *tailB( NULL );
      int lenA( 0 ), lenB( 0 );

      for( ; ptrA != NULL; ptrA = ptrA->next ){
        if( ptrA->next == NULL ) tailA = ptrA;
        ++lenA;
      }

      for( ; ptrB != NULL; ptrB = ptrB->next ){
        if( ptrB->next == NULL ) tailB = ptrB;
        ++lenB;
      }

      if( tailA != tailB ) return NULL;

      if( lenA < lenB ){
        auto tmp1( lenA ); lenA = lenB; lenB = tmp1;
        auto tmp2( headA ); headA = headB; headB = tmp2;
      }

      ptrA = headA;
      ptrB = headB;

      for( int i = lenA - lenB; i > 0; ptrA = ptrA->next, --i );
      for( ; ptrA != ptrB; ptrA = ptrA->next, ptrB = ptrB->next );

      return ptrA;
   }
};
</code></pre>
<p>Runtime: 52 ms</p>
<p>(Discussion) Smart solution!</p>
<pre><code>class Solution {
public:
   ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {
      ListNode *ptrA = headA, *ptrB = headB;
      while (ptrA != ptrB) {
        ptrA = ptrA ? ptrA->next : headB;
        ptrB = ptrB ? ptrB->next : headA;
      }
      return ptrA;
   }
};
</code></pre>

<h3><a name="88" class="anchor" href="#88"></a>#88 Merge Sorted Array (Easy)</h3>
<p>Merge from tail, so that no extra memory is needed.</p>
<pre><code>class Solution {
public:
   void merge(vector< int >& nums1, int m, vector< int >& nums2, int n) {

      if( m == 0 ){ nums1 = nums2; return; }
      if( n == 0 ) return;

      nums1.resize( m + n );

      for( int i = m - 1, j = n - 1, k = m + n - 1; k >= 0; --k ){
        if( i < 0 ){ nums1[ k ] = nums2[ j-- ]; continue; }
        if( j < 0 ){ nums1[ k ] = nums1[ i-- ]; continue; }
        nums1[ k ] = nums1[ i ] > nums2[ j ] ? nums1[ i-- ] : nums2[ j-- ];
      }
   }
};
</code></pre>
<p>Runtime: 4 ms</p>

<h3><a name="190" class="anchor" href="#190"></a>#190 Reverse Bits (Easy)</h3>
<p>Simple bits manipulation.</p>
<pre><code>class Solution {
public:
   uint32_t reverseBits(uint32_t n) {

      n = ( n << 1 & 0xAAAAAAAAU ) | ( n >> 1 & 0x55555555U );
      n = ( n << 2 & 0xCCCCCCCCU ) | ( n >> 2 & 0x33333333U );
      n = ( n << 4 & 0xF0F0F0F0U ) | ( n >> 4 & 0x0F0F0F0FU );
      n = ( n << 8 & 0xFF00FF00U ) | ( n >> 8 & 0x00FF00FFU );
      n = ( n << 16 & 0xFFFF0000U ) | ( n >> 16 & 0x0000FFFFU );

      return n;
   }
};
</code></pre>
<p>Runtime: 4 ms</p>

<h3><a name="36" class="anchor" href="#36"></a>#36 Valid Sudoku (Easy)</h3>
<p>Simple counting.</p>
<pre><code>class Solution {
public:
   bool isValidSudoku(vector< vector<char>>& board) {

      vector< bool > flag;
      char tmp;

      for( int i = 0, jj, kk; i < 9; ++i ){

        flag.assign( 10, false );
        for( int j = 0; j < 9; ++j ){
          if( ( tmp = board[ i ][ j ] ) == '.' ) continue;
          if( flag[ tmp - '0' ] ) return false;
          flag[ tmp - '0' ] = true;
        }

        flag.assign( 10, false );
        for( int j = 0; j < 9; ++j ){
          if( ( tmp = board[ j ][ i ] ) == '.' ) continue;
          if( flag[ tmp - '0' ] ) return false;
          flag[ tmp - '0' ] = true;
        }

        jj = i / 3 * 3; kk = i % 3 * 3;
        flag.assign( 10, false );
        for( int j = 0; j < 3; ++j ){
          for( int k = 0; k < 3; ++k ){
              if( ( tmp = board[ jj + j ][ kk + k ] ) == '.' ) continue;
              if( flag[ tmp - '0' ] ) return false;
              flag[ tmp - '0' ] = true;
          }
        }
      }

      return true;
   }
};
</code></pre>
<p>Runtime: 16 ms</p>

<h3><a name="223" class="anchor" href="#223"></a>#223 Rectangle Area (Easy)</h3>
<p>Use long long to avoid int overflow.</p>
<pre><code>class Solution {
public:
   int computeArea(int A, int B, int C, int D, int E, int F, int G, int H) {

      long long a( ( 0LL + C - A ) * ( 0LL + D - B ) );
      long long b( ( 0LL + G - E ) * ( 0LL + H - F ) );
      long long c( 0LL + min( C, G ) - max( A, E ) );
      long long d( 0LL + min( D, H ) - max( B, F ) );
      long long e( c > 0LL && d > 0LL ? c * d : 0LL );

      return ( int )( a + b - e );
   }
};
</code></pre>
<p>Runtime: 32 ms</p>

<h3><a name="219" class="anchor" href="#219"></a>#219 Contains Duplicate II (Easy)</h3>
<p>Use std::unordered_set.</p>
<pre><code>class Solution {
public:
   bool containsNearbyDuplicate(vector< int >& nums, int k) {

      if( k <= 0 ) return false;

      unordered_set< int > uset;
      int nNums( nums.size() );

      for( int i = 0; i < nNums; ++i ){
        if( uset.find( nums[ i ] ) != uset.end() ) return true;
        if( i - k >= 0 ) uset.erase( nums[ i - k ] );
        uset.insert( nums[ i ] );
      }

      return false;
   }
};
</code></pre>
<p>Runtime: 32 ms</p>

<h3><a name="58" class="anchor" href="#58"></a>#58 Length of Last Word (Easy)</h3>
<p>Simple counting.</p>
<pre><code>class Solution {
public:
   int lengthOfLastWord(string s) {

      int len( s.length() );
      int result( 0 );

      while( len > 0 && s[ len - 1 ] == ' ' ) --len;
      while( len > 0 && s[ len - 1 ] != ' ' ) --len, ++result;

      return result;
   }
};
</code></pre>
<p>Runtime: 4 ms</p>

<h3><a name="19" class="anchor" href="#19"></a>#19 Remove Nth Node From End of List (Easy)</h3>
<p>2 pointers walk along the list with fast one ahead of slow one by N steps. Delete slow one when fast one meets the end.</p>
<pre><code>class Solution {
public:
   ListNode* removeNthFromEnd(ListNode* head, int &n) {

      ListNode *fast( head ), *slow( head );

      for( int i = 0; i < n; ++i, fast = fast->next );

      if( !fast ){
        auto tmp( head );
        head = head->next;
        delete tmp;
        return head;
      }else{
        fast = fast->next;
        while( fast ){ slow = slow->next; fast = fast->next; }
        auto nxt( slow->next ); slow->next = nxt->next; delete nxt;
      }

      return head;
   }
};
</code></pre>
<p>Runtime: 4 ms</p>

<h3><a name="20" class="anchor" href="#20"></a>#20 Valid Parentheses (Easy)</h3>
<p>Use a stack. When it comes a left bracket, push into stack, or it comes a right bracket, check if it makes a pair with the top element in stack.</p>
<pre><code>class Solution {
public:
   bool isValid(string s) {

      stack< int > mstack;
      unordered_map< char, int > umap{
        { '(', 0 }, { ')', 1 },
        { '{', 2 }, { '}', 3 },
        { '[', 4 }, { ']', 5 },
      };

      for( char ch : s ){
        int code( umap[ ch ] );
        if( code & 1 ){
          if( mstack.empty() ) return false;
          if( mstack.top() != code - 1 ) return false;
          mstack.pop();
        }else
          mstack.push( code );
      }

      return mstack.empty();
   }
};
</code></pre>
<p>Runtime: 0 ms</p>

<h3><a name="205" class="anchor" href="#205"></a>#205 Isomorphic Strings (Easy)</h3>
<p>Check 1-to-1 mapping.</p>
<pre><code>class Solution {
public:
   bool isIsomorphic(string s, string t) {

      char chmap[ 256 ]{ 0 };
      bool used[ 256 ]{ false };
      int len( s.length() );

      for( int i = 0; i < len; ++i ){
        if( chmap[ s[ i ] ] ){
          if( chmap[ s[ i ] ] != t[ i ] ) return false;
        }else{
          if( used[ t[ i ] ] ) return false;
          chmap[ s[ i ] ] = t[ i ];
          used[ t[ i ] ] = true;
        }
      }

      return true;
   }
};
</code></pre>
<p>Runtime: 36 ms</p>
<p>(Discussion) Smarter solution.</p>
<pre><code>class Solution {
public:
   bool isIsomorphic(string s, string t) {

      char stmap[ 512 ]{ 0 };
      int len( s.length() );

      for( int i = 0; i < len; ++i ){
        if( stmap[ s[ i ] ] != stmap[ t[ i ] + 256 ] return false;
        stmap[ s[ i ] ] = stmap[ t[ i ] + 256 ] = i + 1;
      }

      return true;
   }
};
</code></pre>
<p>Runtime: 8 ms</p>

<h3><a name="290" class="anchor" href="#290"></a>#290 Word Pattern (Easy)</h3>
<p>1-to-1 map, similar idea as #205.<br>
(Discussion) Use istringstream to read words from str.</p>
<pre><code>class Solution {
public:
   bool wordPattern(string pattern, string str) {

      unordered_map< char, int > pmap;
      unordered_map< string, int > smap;
      int head( 0 ), tail( 0 ), len( pattern.length() ), i;
      string word;

      for( i = 0; i < len && tail != -1; ++i ){
        tail = str.find( " ", head );
        word = str.substr( head, tail - head );
        head = tail + 1;

        auto ite1( pmap.find( pattern[ i ] ) );
        auto ite2( smap.find( word ) );

        if( ( ite1 == pmap.end() ) != ( ite2 == smap.end() ) )
          return false;
        if( ( ite1 != pmap.end() ) && ( ite2 != smap.end() )
          && ( ite1->second != ite2->second ) ) return false;

        pmap[ pattern[ i ] ] = smap[ word ] = i;
      }

      return i == len && tail == -1;
   }
};
</code></pre>
<p>Runtime: 0 ms</p>

<h3><a name="203" class="anchor" href="#203"></a>#203 Remove Linked List Elements (Easy)</h3>
<p>Use a dummy head node to simplify situation.</p>
<pre><code>class Solution {
public:
   ListNode* removeElements(ListNode* head, int val) {

      ListNode result( 0 ); result.next = head;

      for( auto ptr = &result; ptr->next; ){
        if( ptr->next->val == val ){
          auto tmp( ptr->next->next );
          delete ptr->next;
          ptr->next = tmp;
        }else
          ptr = ptr->next;
      }

      return result.next;
   }
};
</code></pre>
<p>Runtime: 32 ms</p>

<h3><a name="38" class="anchor" href="#38"></a>#38 Count and Say (Easy)</h3>
<p>Use std::stringstream to simplify string manipulation.</p>
<pre><code>class Solution {
public:
   string countAndSay(int n) {

      if( n <= 1 ) return string( "1" );

      stringstream ss;
      string s( "1" );

      while( --n ){

        char pre( '\0' );
        int preCount( 0 );

        for( char cur : s ){
          if( cur != pre ){
              if( preCount ) ss << preCount << pre;
              pre = cur;
              preCount = 1;
          }else
              ++preCount;
        }

        if( preCount ) ss << preCount << pre;
        ss >> s; ss.clear(); ss.str( "" );
      }

      return s;
   }
};
</code></pre>
<p>Runtime: 4 ms</p>

<h3><a name="299" class="anchor" href="#299"></a>#299 Bulls and Cows (Easy)</h3>
<p>Simple counting. Use std::stringstream or std::to_string.</p>
<pre><code>class Solution {
public:
   string getHint(string secret, string guess) {

      stringstream ss;
      int nBulls( 0 ), nCows( 0 );
      int count[ 20 ]{ 0 };
      int len( secret.length() );

      for( int i = 0; i < len; ++i ){
        nBulls += secret[ i ] == guess[ i ] ? 1 : 0;
        ++count[ secret[ i ] - '0' ];
        ++count[ guess[ i ] - '0' + 10 ];
      }

      for( int i = 0; i < 10; ++i ){
        nCows += min( count[ i ], count[ i + 10 ] );
      }

      ss << nBulls << "A" << nCows - nBulls << "B";
      return ss.str();
   }
};
</code></pre>
<p>Runtime: 4 ms</p>

<h3><a name="14" class="anchor" href="#14"></a>#14 Longest Common Prefix (Easy)</h3>
<p>Simple counting.</p>
<pre><code>class Solution {
public:
   string longestCommonPrefix(vector<string>& strs) {

      if( strs.empty() ) return string( "" );

      int nStrs( strs.size() );
      int maxLen( strs[ 0 ].length() );

      for( int i = 1; i < nStrs; ++i ){
        int len( strs[ i ].length() ), j;
        for( j = 0; j < len && j < maxLen; ++j )
          if( strs[ 0 ][ j ] != strs[ i ][ j ] ) break;
        maxLen = j;
      }

      return strs[ 0 ].substr( 0, maxLen );
   }
};
</code></pre>
<p>Runtime: 4 ms</p>

<h3><a name="67" class="anchor" href="#67"></a>#67 Add Binary (Easy)</h3>
<p>Split digits into vector and add.</p>
<pre><code>class Solution {
public:
   string addBinary(string a, string b) {

      vector< int > va, vb;
      string result;

      split( a, va );
      split( b, vb );

      int lenA( va.size() );
      int lenB( vb.size() );

      if( lenA < lenB ){
        va.swap( vb );
        lenA = lenB;
      }
      vb.resize( lenA );
      va.push_back( 0 );

      for( int i = 0; i < lenA; ++i ){
        va[ i + 1 ] += va[ i ] + vb[ i ] >> 1;
        result = ( va[ i ] + vb[ i ] & 1 ? '1' : '0' ) + result;
      }

      return va.back() ? '1' + result : result;
   }

   void split( const string &s, vector< int > &v ){
      for( int i = s.length() - 1; i >= 0; --i ){
        v.push_back( s[ i ] - '0' );
      }
   }
};
</code></pre>
<p>Runtime: 8 ms</p>
(Discussion) More concise code!</p>
<pre><code>class Solution {
public:
   string addBinary(string a, string b) {

      int i( a.length() - 1 );
      int j( b.length() - 1 );
      int carry( 0 );
      string result;

      while( i >= 0 || j >= 0 || carry ){
        carry += i >= 0 && a[ i-- ] - '0' ? 1 : 0;
        carry += j >= 0 && b[ j-- ] - '0' ? 1 : 0;
        result = ( carry & 1 ? '1' : '0' ) + result;
        carry >>= 1;
      }

      return result;
   }
};
</code></pre>
<p>Runtime: 4 ms</p>

<h3><a name="234" class="anchor" href="#234"></a>#234 Palindrome Linked List (Easy)</h3>
<p>Reverse first half and compare.</p>
<pre><code>class Solution {
public:
   bool isPalindrome(ListNode* head) {

      if( head == NULL || head->next == NULL ) return true;

      ListNode dummy( 0 ); dummy.next = head;
      ListNode *fast( &dummy ), *slow( &dummy );
      ListNode *l, *r;

      while( fast->next && fast->next->next ){
        slow = slow->next;
        fast = fast->next->next;
      }

      l = slow; r = slow->next;
      if( fast->next ) r = r->next;
      l->next = NULL;

      for( auto p = &dummy, c = head, n = c->next; ; ){
        c->next = p;
        if( !n ){ head->next = NULL; break; }
        p = c; c = n; n = n->next;
      }

      for( ; l && l->val == r->val; l = l->next, r = r->next );
      return l == NULL;
   }
};
</code></pre>
<p>Runtime: 28 ms</p>

<h3><a name="257" class="anchor" href="#257"></a>#257 Binary Tree Paths (Easy)</h3>
<p>Simple DFS. Use a vector to record nodes on current path.</p>
<pre><code>class Solution {
public:
   vector<string> binaryTreePaths(TreeNode* root) {
      if( root == NULL )
        return vector< string >();
      else{
        traverse( root );
        return vs;
      }
   }

   void traverse( TreeNode *root ){

      vi.push_back( root->val );

      if( root->left == NULL && root->right == NULL ){
        string s;
        for( int i : vi ) s += "->" + to_string( i );
        vs.push_back( s.substr( 2, -1 ) );
      }else{
        if( root->left ) traverse( root->left );
        if( root->right ) traverse( root->right );
      }

      vi.pop_back();
   }

   vector< string > vs;
   vector< int > vi;
};
</code></pre>
<p>Runtime: 8 ms</p>

<h3><a name="303" class="anchor" href="#303"></a>#303 Range Sum Query - Immutable (Easy)</h3>
<p>Precompute suffix sum array, then sumRange( i, j ) = suffixSum( j ) - suffixSum( i - 1 ).</p>
<pre><code>class NumArray {
public:
   NumArray(vector< int > &nums) {
      for( int i = 0; i < nums.size(); ++i )
        v.push_back( v[ i ] + nums[ i ] );
   }

   int sumRange(int i, int j) {
      return  v[ j + 1 ] - v[ i ];
   }

   vector< int > v{ 0 };
};
</code></pre>
<p>Runtime: 596 ms</p>

<h3><a name="28" class="anchor" href="#28"></a>#28 Implement strStr() (Easy)</h3>
<p>Compare by brute force.</p>
<pre><code>class Solution {
public:
   int strStr(string haystack, string needle) {

      int lenH( haystack.length() );
      int lenN( needle.length() );

      if( lenN == 0 ) return 0;
      if( lenH < lenN ) return -1;

      for( int i = 0; i < lenH - lenN + 1; ++i ){
        for( int j = 0; ; ++j ){
          if( haystack[ i + j ] != needle[ j ] ) break;
          if( j == lenN - 1 ) return i;
        }
      }

      return -1;
   }
};
</code></pre>
<p>Runtime: 4 ms</p>

<h3><a name="7" class="anchor" href="#7"></a>#7 Reverse Integer (Easy)</h3>
<p>Mind tricky inputs like INT_MAX, INT_MIN.</p>
<pre><code>class Solution {
public:
   int reverse(int x) {

      if( x == 1 << 31 ) return 0;
      if( x < 0 ) return -reverse( -x );

      long long y( 0LL );

      while( x ){
        y = y * 10LL + x % 10;
        x /= 10;
      }

      return y <= 0x7fffffffLL ? ( int )y : 0;
   }
};
</code></pre>
<p>Runtime: 8 ms</p>

<h3><a name="125" class="anchor" href="#125"></a>#125 Valid Palindrome (Easy)</h3>
<p>Extract alphanumerics and check palindrome.</p>
<pre><code>class Solution {
public:
   bool isPalindrome(string s) {

      string t;
      int len( 0 );

      for( char ch : s ){
        if( ch >= '0' && ch <= '9'
          || ch >= 'a' && ch <= 'z'
          || ch >= 'A' && ch <= 'Z' ){
          t += ch > 'Z' ? ( char )( ch - 32 ) : ch;
          ++len;
        }
      }

      for( int i = 0; i < len >> 1; ++i ){
        if( t[ i ] != t[ len - i - 1 ] ) return false;
      }

      return true;
   }
};
</code></pre>
<p>Runtime: 16 ms</p>

<h3><a name="6" class="anchor" href="#6"></a>#6 ZigZag Conversion (Easy)</h3>
<p>Simple simulation.</p>
<pre><code>class Solution {
public:
   string convert(string s, int numRows) {

      if( s.empty() || numRows < 2 ) return s;

      vector< string > vs( numRows, "" );
      int len( s.length() ), loop( numRows - 1 << 1 );
      string result;

      for( int i = 0, j = 0; i < len; ++i ){
        j = i % loop;
        if( j >= numRows ) j = ( numRows - 1 << 1 ) - j;
        vs[ j ] += s[ i ];
      }

      for( string str : vs ) result += str;

      return result;
   }
};
</code></pre>
<p>Runtime: 48 ms</p>

<h3><a name="204" class="anchor" href="#204"></a>#Count Primes (Easy)</h3>
<p>"Sift" non-primes out using known primes. Mind int range overflow.</p>
<pre><code>class Solution {
public:
   int countPrimes(int n) {

      if( n < 2 ) return 0;

      vector< bool > prime( n, true );
      int result( 0 );

      for( int i = 2; i < n; ++i ){
        if( !prime[ i ] ) continue;
        ++result;
        if( i > 46340 ) continue;
        for( int j = i * i; j < n; j += i ){
          prime[ j ] = false;
        }
      }

      return result;
   }
};
</code></pre>
<p>Runtime: 312 ms</p>

<h3><a name="228" class="anchor" href="#228"></a>#228 Summary Ranges (Easy)</h3>
<p>Simple iteration. Append an end symbol to simplify situation.</p>
<pre><code>class Solution {
public:
   vector<string> summaryRanges(vector< int >& nums) {

      if( nums.empty() ) return vector< string >();

      vector< string > result;
      int nNums( nums.size() );
      int head( 0 ), tail( 0 );

      nums.push_back( nums[ nNums++ - 1 ] );

      for( int i = 1; i < nNums; tail = i++ ){
        if( nums[ i ] != nums[ i - 1 ] + 1 ){
          if( tail - head )
              result.push_back( to_string( nums[ head ] )
                + "->" + to_string( nums[ tail ] ) );
          else
              result.push_back( to_string( nums[ head ] ) );
          head = i;
        }
      }

      return result;
   }
};
</code></pre>
<p>Runtime: 4 ms</p>

<h3><a name="278" class="anchor" href="#278"></a>#278 First Bad Version (Easy)</h3>
<p>Binary search. Mind int range overflow when computing middle.</p>
<pre><code>bool isBadVersion(int version);

class Solution {
public:
   int firstBadVersion(int n) {

      int lower( 1 ), upper( n ), middle;

      while( upper - lower ){
        middle = lower + ( upper - lower >> 1 );
        if( isBadVersion( middle ) )
          upper = middle;
        else
          lower = middle + 1;
      }

      return isBadVersion( upper ) ? upper : 0;
   }
};
</code></pre>
<p>Runtime: 0 ms</p>

<h3><a name="155" class="anchor" href="#155"></a>#155 Min Stack (Easy)</h3>
<p>Use 2 stacks. One for normal use, the other to store mins.</p>
<pre><code>class MinStack {
public:
   void push(int x) {
      if( b.empty() || x <= b.top() ) b.push( x );
      a.push( x );
   }

   void pop() {
      if( b.top() == a.top() ) b.pop();
      a.pop();
   }

   int top() {
      return a.top();
   }

   int getMin() {
      return b.top();
   }

   stack< int > a, b;
};
</code></pre>
<p>Runtime: 28 ms</p>

<h3><a name="168" class="anchor" href="#168"></a>#168 Excel Sheet Column Title (Easy)</h3>
<p>A new type of number with a numeral base of 26.</p>
<pre><code>class Solution {
public:
   string convertToTitle(int n) {

      string result;

      do{
        result = ( char )( --n % 26 + 'A' ) + result;
      }while( n /= 26 );

      return result;
   }
};
</code></pre>
<p>Runtime: 0 ms</p>

<h3><a name="189" class="anchor" href="#189"></a>#189 Rotate Array (Easy)</h3>
<p>Reverse first part, reverse second part, then reverse whole.<br>
Note that k might be greater than size of nums.</p>
<pre><code>class Solution {
public:
   void rotate(vector< int >& nums, int k) {
      if( nums.empty() || ( k %= nums.size() ) < 1 ) return;
      reverse( nums, 0, nums.size() - k - 1 );
      reverse( nums, nums.size() - k, nums.size() - 1 );
      reverse( nums, 0, nums.size() - 1 );
   }

   void reverse( vector< int > &nums, int a, int b ){
      for( int i = 0; i < b - a + 1 >> 1; ++i ){
        auto tmp( nums[ a + i ] );
        nums[ a + i ] = nums[ b - i ];
        nums[ b - i ] = tmp;
      }
   }
};
</code></pre>
<p>Runtime: 4 ms</p>

<h3><a name="165" class="anchor" href="#165"></a>#165 Compare Version Numbers(Easy)</h3>
<p>Use std::istringstream to ease string manipulation.</p>
<pre><code>class Solution {
public:
   int compareVersion(string version1, string version2) {

      for( char &ch : version1 ) ch == '.' ? ch = ' ' : 0;
      for( char &ch : version2 ) ch == '.' ? ch = ' ' : 0;

      int a( 0 ), b( 0 );
      bool getA, getB;
      istringstream iss1( version1 );
      istringstream iss2( version2 );

      while( true ){
        a = b = 0;
        getA = iss1 >> a ? true : false;
        getB = iss2 >> b ? true : false;
        if( !getA && !getB ) return 0;
        if( a != b ) return a > b ? 1 : -1;
      }
   }
};
</code></pre>
<p>Runtime: 0 ms</p>

<h3><a name="8" class="anchor" href="#8"></a>#8 String to Integer (Easy)</h3>
<p>Simple state machine.</p>
<pre><code>class Solution {
public:
   int myAtoi(string str) {

      bool positive( true );
      bool starting( true );
      long long result( 0 );

      for( char ch : str ){
        if( starting ){
          if( ch == ' ' || ch == '\t' )  continue;
          if( ch == '+' || ch == '-' || ch >= '0' && ch <= '9' ){
              if( ch == '-' ) positive = false;
              else if( ch != '+' ) result = ch - '0';
              starting = false;
              continue;
          }
          return 0;
        }else{
          if( ch < '0' || ch > '9' ) break;
          result = result * 10 + ( ch - '0' );
          if( positive && result > 0x7fffffffLL ) return 0x7fffffff;
          if( !positive && result > 0x80000000LL ) return 0x80000000;
        }
      }

      return positive ? ( int )result : ( int )( -result );
   }
};
</code></pre>
<p>Runtime: 8 ms</p>

<h3><a name="136" class="anchor" href="#136"></a>#136 Single Number (Medium)</h3>
<p>Idea similar to qsort. Choose a standard and make left part less than or equal to standard and right part greater than standard. The answer is in the part with odd number of elements.</p>
<pre><code>class Solution {
public:
   int singleNumber(vector< int >& nums) {

      if( nums.empty() ) return 0;

      return find( nums, 0, nums.size() - 1 );
   }

   int find( vector< int > &nums, int l, int r ){

      if( r == l ) return nums[ l ];

      int i( l ), j( r );
      int m( nums[ l + rand() % ( r - l + 1 ) ] );

      while( i < j ){
        while( nums[ i ] <= m ) ++i;
        while( nums[ j ] > m ) --j;
        if( i < j ){
          auto tmp( nums[ i ] );
          nums[ i ] = nums[ j ];
          nums[ j ] = tmp;
        }
      }

      if( i <= r && ( r - i + 1 & 1 ) )
        return find( nums, i, r );
      else
        return find( nums, l, j );
   }
};
</code></pre>
<p>Runtime: 0 ms</p>
<p>(Discussion) XOR! Genius!</p>
<pre><code>class Solution {
public:
   int singleNumber(vector< int >& nums) {

      int result( 0 );

      for( int i : nums ) result ^= i;

      return result;
   }
};
</code></pre>

<h3><a name="260" class="anchor" href="#260"></a>#260 Single Number III (Medium)</h3>
<p>XOR all numbers. Use a bit set of the result to classify all numbers into two parts. The answer is the XOR of each part.</p>
<pre><code>class Solution {
public:
   vector< int > singleNumber(vector< int >& nums) {

      int all( 0 ), first( 0 ), second( 0 );

      for( int i : nums ) all ^= i; all &= -all;
      for( int i : nums ) i & all ? first ^= i : second ^= i;

      return vector< int >{ first, second };
   }
};
</code></pre>
<p>Runtime: 0 ms</p>

<h3><a name="122" class="anchor" href="#122"></a>#122 Best Time to Buy and Sell Stock II (Medium)</h3>
<p>If price today is higher than yesterday, "bought" yesterday and sell today.</p>
<pre><code>class Solution {
public:
   int maxProfit(vector< int >& prices) {

      int result( 0 ), yesterday( 0x7fffffff );

      for( int today : prices ){
        result += today > yesterday ? today - yesterday : 0;
        yesterday = today;
      }

      return result;
   }
};
</code></pre>
<p>Runtime: 12 ms</p>

<h3><a name="238" class="anchor" href="#238"></a>#238 Product of Array Except Self (Medium)</h3>
<p>Use output to store prefix product and nums to store suffix product, then combine them together.</p>
<pre><code>class Solution {
public:
   vector< int > productExceptSelf(vector< int >& nums) {

      vector< int > output( nums.size(), 1 );

      for( int i = 1; i < nums.size(); ++i ){
        output[ i ] = output[ i - 1] * nums[ i - 1 ];
      }

      for( int i = nums.size() - 2; i >= 0; --i ){
        nums[ i ] *= nums[ i + 1 ];
        output[ i ] *= nums[ i + 1 ];
      }

      return output;
   }
};
</code></pre>
<p>Runtime: 60 ms</p>

<h3><a name="144" class="anchor" href="#144"></a>#144 Binary Tree Preorder Traversal (Medium)</h3>
<p>Use stack to solve it iteratively.</p>
<pre><code>class Solution {
public:
   vector< int > preorderTraversal(TreeNode* root) {

      if( root == NULL ) return vector< int >();

      vector< int > result;
      stack< TreeNode * > mstack;
      TreeNode *pNode;

      mstack.push( root );

      while( !mstack.empty() ){
        pNode = mstack.top();
        mstack.pop();
        result.push_back( pNode->val );
        if( pNode->right ) mstack.push( pNode->right );
        if( pNode->left ) mstack.push( pNode->left );
      }

      return result;
   }

};
</code></pre>
<p>Runtime: 0 ms</p>

<h3><a name="319" class="anchor" href="#319"></a>#319 Bulb Switcher (Medium)</h3>
<p>Lights at positions of perfect square will be on.</p>
<pre><code>class Solution {
public:
   int bulbSwitch(int n) {
      return ( int )sqrt( n + 0. );
   }
};
</code></pre>
<p>Runtime: 0 ms</p>

<h3><a name="94" class="anchor" href="#94"></a>#94 Binary Tree Inorder Traversal (Medium)</h3>
<p>Use stack to solve it iteratively. Add a flag to indicate inorder.</p>
<pre><code>class Solution {
public:
   vector< int > inorderTraversal(TreeNode* root) {

      if( root == NULL ) return vector< int >();

      vector< int > result;
      stack< pair< TreeNode *, bool > > mstack;
      bool inorder;

      mstack.push( make_pair( root, false ) );

      while( !mstack.empty() ){
        root = mstack.top().first;
        inorder = mstack.top().second;
        mstack.pop();
        if( inorder ){ result.push_back( root->val ); continue; }
        if( root->right ) mstack.push( make_pair( root->right, false ) );
        mstack.push( make_pair( root, true ) );
        if( root->left ) mstack.push( make_pair( root->left, false ) );
      }

      return result;
   }
};
</code></pre>
<p>Runtime: 0 ms</p>

<h3><a name="268" class="anchor" href="#268"></a>#268 Missing Number (Medium)</h3>
<p>All Hail XOR!!</p>
<pre><code>class Solution {
public:
   int missingNumber(vector< int >& nums) {

      int result( 0 );

      for( int i = 0; i <= nums.size(); ++i ) result ^= i;
      for( int i : nums ) result ^= i;

      return result;
   }
};
</code></pre>
<p>Runtime: 36 ms</p>

<h3><a name="318" class="anchor" href="#318"></a>#318 Maximum Product of Word Lengths (Medium)</h3>
<p>Use bitset to indicate letter usage. Compare by brute force.</p>
<pre><code>class Solution {
public:
   int maxProduct(vector<string>& words) {

      int hash( 0 ), result( 0 );
      int nWords( words.size() );
      vector< pair< int, int > > vp;

      for( const string &str : words ){
        hash = 0;
        for( const char &ch : str ) hash |= 1 << ch - 'a';
        vp.push_back( make_pair( hash, str.length() ) );
      }

      for( int i = 0; i < nWords - 1; ++i ){
        for( int j = i + 1; j < nWords; ++j ){
          if( vp[ i ].first & vp[ j ].first != 0 ) continue;
          result = max( result, vp[ i ].second * vp[ j ].second );
        }
      }

      return result;
   }
};
</code></pre>
<p>Runtime: 148 ms</p>

<h3><a name="" class="anchor" href="#"></a># (Medium)</h3>
<p>Fast pointer walks twice as fast as slow pointer. There is a loop if fast one meets slow one before it meets end.</p>
<pre><code>class Solution {
public:
   bool hasCycle(ListNode *head) {

      if( head == NULL ) return false;

      ListNode *slow( head ), *fast( head->next );

      while( fast && slow != fast ){
        slow = slow->next;
        fast = fast->next;
        if( fast == NULL ) return false;
        fast = fast->next;
      }

      return fast != NULL;
   }
};
</code></pre>
<p>Runtime: 12 ms</p>

<h3><a name="137" class="anchor" href="#137"></a>#137 Single Number II (Medium)</h3>
<p>Can be solved similarly to #136.</p>
<p>(Discussion)Crazy XOR!!</p>
<pre><code>class Solution {
public:
   int singleNumber(vector< int >& nums) {

      int ones( 0 ), twos( 0 );

      for( int x : nums ){
        ones ^= x & ~twos;
        twos ^= x & ~ones;
      }

      return ones;
   }
};
</code></pre>
<p>Runtime: 12 ms</p>

<h3><a name="116" class="anchor" href="#116"></a>#116 Populating Next Right Pointers in Each Node (Medium)</h3>
<p>Next of a left child is its parent's right child. Next of a right child is its parent's next node's left child. So we should populate the tree from right to left.</p>
<pre><code>class Solution {
public:
   void connect(TreeLinkNode *root) {
      traverse( root, NULL, RIGHT );
   }

   void traverse( TreeLinkNode *root, TreeLinkNode *parent, int flag ){

      if( root == NULL ) return;
      if( parent != NULL ){
        if( flag == LEFT ){
          root->next = parent->right;
        }else if( parent->next != NULL ){
          root->next = parent->next->left;
        }else{
          root->next = NULL;
        }
      }else{
        root->next = NULL;
      }

      traverse( root->right, root, RIGHT );
      traverse( root->left, root, LEFT );
   }

   static const int LEFT = 0;
   static const int RIGHT = 1;
};
</code></pre>
<p>Runtime: 24 ms</p>

<h3><a name="108" class="anchor" href="#108"></a>#108 Convert Sorted Array to Binary Search Tree (Medium)</h3>
<p>Recursively build tree using first half for left subtree and the other half for right subtree.</p>
<pre><code>class Solution {
public:
   TreeNode* sortedArrayToBST(vector< int >& nums) {
      return buildTree( nums, 0, nums.size() - 1 );
   }

   TreeNode* buildTree( vector< int > &nums, int l, int r ){

      if( l > r ) return NULL;

      int m( r + l + 1 >> 1 );
      TreeNode *root = new TreeNode( nums[ m ] );
      root->left = buildTree( nums, l, m - 1 );
      root->right = buildTree( nums, m + 1, r );

      return root;
   }
};
</code></pre>
<p>Runtime: 16 ms</p>

<h3><a name="53" class="anchor" href="#53"></a>#53 Maximum Subarray (Medium)</h3>
<p>Greedy strategy. Add current number to sum. Set sum to zero if it is less than zero.</p>
<pre><code>class Solution {
public:
   int maxSubArray(vector< int >& nums) {

      int result( 1 << 31 ), sum( 0 );

      for( int i : nums ){
        sum += i;
        result = max( result, sum );
        sum < 0 ? sum = 0 : 0;
      }

      return result;
   }
};
</code></pre>
<p>Runtime: 12 ms</p>

<h3><a name="153" class="anchor" href="#153"></a>#153 Find Minimum in Rotated Sorted Array (Medium)</h3>
<p>Binary search.</p>
<pre><code>class Solution {
public:
   int findMin(vector< int >& nums) {

      int lower( 0 ), upper( nums.size() - 1 ), middle;

      while( upper - lower ){
        middle = lower + ( upper - lower >> 1 );
        if( nums[ middle ] <= nums[ upper ] )
          upper = middle;
        else
          lower = middle + 1;
      }

      return nums[ upper ];
   }
};
</code></pre>
<p>Runtime: 4 ms</p>

<h3><a name="22" class="anchor" href="#22"></a>#22 Generate Parentheses (Medium)</h3>
<p>Recursively generate.</p>
<pre><code>class Solution {
public:
   vector<string> generateParenthesis(int n) {

      result.clear();
      generate( "", 0, n );

      return result;
   }

   void generate( string str, int m, int n ){
      if( !n ){ result.push_back( str + string( m, ')' ) ); return; }
      if( m ) generate( str + ")", m - 1, n );
      generate( str + "(", m + 1, n - 1 );
   }

   vector< string > result;
};
</code></pre>
<p>Runtime: 0 ms</p>

<h3><a name="62" class="anchor" href="#62"></a>#62 Unique Paths (Medium)</h3>
<p>Since grid(i,j) can be reached from grid(i-1,j) or grid(i,j-1), thus f[i,j] = f[i-1,j] + f[i,j-1]. Can use only an 1*n or m*1 array.</p>
<pre><code>class Solution {
public:
   int uniquePaths(int m, int n) {

      vector< int > vi( n, 1 );

      for( int i = 1; i < m; ++i ){
        for( int j = 1; j < n; ++j ){
          vi[ j ] += vi[ j - 1 ];
        }
      }

      return vi[ n - 1 ];
   }
};
</code></pre>
<p>Runtime: 0 ms</p>

<h3><a name="89" class="anchor" href="#89"></a>#89 Gray Code (Medium)</h3>
<p>First half is symmetric to second half except that LSB of first half is 0 while second half is 1.</p>
<pre><code>class Solution {
public:
   vector< int > grayCode(int n) {

      vector< int > vi{ 0 };

      for( int i = 0; i < n; ++i ){
        for( int j = vi.size() - 1; j >=0; --j ){
          vi.push_back( 1 << i | vi[ j ] );
        }
      }

      return vi;
   }
};
</code></pre>
<p>Runtime: 8 ms</p>

<h3><a name="230" class="anchor" href="#230"></a>#230 Kth Smallest Element in a BST (Medium)</h3>
<p>Recursively count number of nodes of tree and find kth smallest element.</p>
<pre><code>class Solution {
public:
   int kthSmallest(TreeNode* root, int k) {

      int nNodes;

      return kthAndNNodes( root, k, nNodes );
   }

   int kthAndNNodes( TreeNode *root, int k, int &nNodes ){

      if( root == NULL ) return 0;

      int nLNodes( 0 ), nRNodes( 0 ), result;

      result = kthAndNNodes( root->left, k, nLNodes );
      nNodes = nLNodes;
      if( k <= nNodes ) return result;

      nNodes += 1;
      if( k <= nNodes ) return root->val;

      result = kthAndNNodes( root->right, k - nNodes, nRNodes );
      nNodes += nRNodes;
      return result;
   }
};
</code></pre>
<p>Runtime: 0 ms</p>

<h3><a name="309" class="anchor" href="#309"></a>#309 Best Time to Buy and Sell Stock with Cooldown (Medium)</h3>
<p>DP on state machine:<br>
State A: can buy (goto B) or rest (goto A):   A[i] = max( A[i-1], C[i-1] ).<br>
State B: can sell (goto C) or rest (goto B): B[i] = max( B[i-1], A[i-1] - today's price ).<br>
State C: can rest (goto A) only: C[i] = max( C[i-1], B[i-1] + today's price ).
</p>
<pre><code>class Solution {
public:
   int maxProfit(vector< int >& prices) {

      int nPrices( prices.size() );
      vector< int > a( nPrices + 1, 0 );
      vector< int > b( nPrices + 1, 1 << 31 );
      vector< int > c( nPrices + 1, 1 << 31 );

      for( int i = 1; i <= nPrices; ++i ){
        a[ i ] = max( a[ i - 1 ], c[ i - 1 ] );
        b[ i ] = max( b[ i - 1 ], a[ i - 1 ] - prices[ i - 1 ] );
        c[ i ] = max( c[ i - 1 ], b[ i - 1 ] + prices[ i - 1 ] );
      }

      return max( a[ nPrices ], c[ nPrices ] );
   }
};
</code></pre>
<p>Runtime: 0 ms</p>

<h3><a name="46" class="anchor" href="#46"></a>#46 Permutations (Medium)</h3>
<p>Permutations of n numbers can be generated by inserting nth number into permutations of n-1 numbers.</p>
<pre><code>class Solution {
public:
   vector< vector< int > > permute(vector< int >& nums) {

      N = nums.size();
      vi.clear();
      vi.push_back( 0 );
      result.clear();
      generatePermutations();

      for( auto &i : result )
        for( auto &j: i )
          j = nums[ j ];

      return result;
   }

   void generatePermutations(){

      if( vi.size() == N ){
        result.push_back( vi );
        return;
      }

      vi.push_back( vi.size() );
      generatePermutations();
      for( int i = vi.size() - 1; i; --i ){
        swap( vi[ i ], vi[ i - 1 ] );
        generatePermutations();
      }
      for( int i = 0; i < vi.size() - 1; ++i )
        vi[ i ] = vi[ i + 1 ];
      vi.pop_back();
   }

   void swap( int &a, int &b ){
      auto c = a; a = b; b = c;
   }

   int N;
   vector< int > vi;
   vector< vector< int > > result;
};
</code></pre>
<p>Runtime: 16 ms</p>

<h3><a name="96" class="anchor" href="#96"></a>#96 Unique Binary Search Trees (Medium)</h3>
<p>Let F[n] denote the number of different BSTs that store 1..n, and number of trees rooted at ith number is F[i-1] (number of left subtrees) times F[n-i] (number of right subtrees).<br>
Thus, F[n] = F[0]*F[n-1] + F[1]*F[n-2] +...+ F[n-1]*F[0], where F[0] = 1.</p>
<pre><code>class Solution {
public:
   int numTrees(int n) {

      vector< int > vi{ 1 };

      for( int i = 1; i <= n; ++i ){
        vi.push_back( 0 );
        for( int j = 0; j < i; ++j ){
          vi[ i ] += vi[ j ] * vi[ i - j - 1 ];
        }
      }

      return vi.back();
   }
};
</code></pre>
<p>Runtime: 0 ms</p>

<h3><a name="35" class="anchor" href="#35"></a>#35 Search Insert Position (Medium)</h3>
<p>Simple binary search. Mind edge case.</p>
<pre><code>class Solution {
public:
   int searchInsert(vector< int >& nums, int target) {

      if( target > nums.back() ) return nums.size();

      int lower( 0 ), upper( nums.size() - 1 ), middle;

      while( upper - lower ){
        middle = lower + ( upper - lower >> 1 );
        if( nums[ middle ] < target )
          lower = middle + 1;
        else
          upper = middle;
      }

      return upper;
   }
};
</code></pre>
<p>Runtime: 8 ms</p>

<h3><a name="121" class="anchor" href="#121"></a>#121 Best Time to Buy and Sell Stock (Medium)</h3>
<p>Record the lowest price before today and calculate profit you can make if you sell today. Maximize the profit.</p>
<pre><code>class Solution {
public:
   int maxProfit(vector< int >& prices) {

      int minBefore( 1 << 30 ), result( 0 );

      for( int today : prices ){
        result = max( result, today - minBefore );
        minBefore = min( minBefore, today );
      }

      return result;
   }
};
</code></pre>
<p>Runtime: 12 ms</p>

<h3><a name="24" class="anchor" href="#24"></a>#24 Swap Nodes in Pairs (Medium)</h3>
<p>Linked list manipulation.</p>
<pre><code>class Solution {
public:
   ListNode* swapPairs(ListNode* head) {

      ListNode dummy( 0 ); dummy.next = head;

      for( auto pNode = &dummy; pNode; pNode = pNode->next->next ){
        if( !pNode->next || !pNode->next->next ) break;
        auto pNN( pNode->next->next );
        pNode->next->next = pNN->next;
        pNN->next = pNode->next;
        pNode->next = pNN;
      }

      return dummy.next;
   }
};
</code></pre>
<p>Runtime: 4 ms</p>

<h3><a name="12" class="anchor" href="#12"></a>#12 Integer to Roman (Medium)</h3>
<p>Add "M" to make x less than 1000.<br>
For x within [100,1000): <br>
- if x >= 900, add "CM", x -= 900;<br>
- else if x >= 500, add "D", x -= 500;<br>
- else if x >= 400, add "CD", x -= 400;<br>
- else if x >= 100, add "C", x -= 100.<br>
Similarly for x within [10,100) and [1,10).</p>
<pre><code>class Solution {
public:
   string intToRoman(int num) {

      static const vector< pair< char, int > > vp{
        { 'I', 1 }, { 'V', 5 }, { 'X', 10 }, { 'L', 50 },
        { 'C', 100, }, { 'D', 500 },  { 'M', 1000 },
      };

      string result( num / 1000, 'M' ); num %= 1000;
      int size( 9 );

      while( num && ( size -= 2 ) ){
        if( num >= vp[ size - 1 ].second - vp[ size - 3 ].second ){
          num -= vp[ size - 1 ].second - vp[ size - 3 ].second;
          result += vp[ size - 3 ].first;
          result += vp[ size - 1 ].first;
        }else if( num >= vp[ size - 2 ].second ){
          num -= vp[ size - 2 ].second;
          result += vp[ size - 2 ].first;
        }else if( num >= vp[ size - 2 ].second - vp[ size - 3 ].second ){
          num -= vp[ size - 2 ].second - vp[ size - 3 ].second;
          result += vp[ size - 3 ].first;
          result += vp[ size - 2 ].first;
        }
        while( num >= vp[ size - 3 ].second ){
          num -= vp[ size - 3 ].second;
          result += vp[ size - 3 ].first;
        }
      }

      return result;
   }
};
</code></pre>
<p>Runtime: 36 ms</p>
<p>(Discussion) Use a table!<br>
<pre><code>public static String intToRoman(int num) {
   String M[]{"", "M", "MM", "MMM"};
   String C[]{"", "C", "CC", "CCC", "CD", "D", "DC", "DCC", "DCCC", "CM"};
   String X[]{"", "X", "XX", "XXX", "XL", "L", "LX", "LXX", "LXXX", "XC"};
   String I[]{"", "I", "II", "III", "IV", "V", "VI", "VII", "VIII", "IX"};
   return M[num/1000] + C[(num%1000)/100] + X[(num%100)/10] + I[num%10];
}
</code></pre>

<h3><a name="75" class="anchor" href="#75"></a>#75 Sort Colors (Medium)</h3>
<p>Simple counting.</p>
<pre><code>class Solution {
public:
   void sortColors(vector< int >& nums) {

       int count[]{ 0, 0, 0, };

       for( int &num : nums ) ++count[ num ];
       for( int i = 0, j = 0; i < 3; ++i ){
          while( count[ i ]-- ) nums[ j++ ] = i;
       }
   }
};
</code></pre>
<p>Runtime: 4 ms</p>

<h3><a name="64" class="anchor" href="#64"></a>#64 Minimum Path Sum (Medium)</h3>
<p>DP: F[i,j] = min( F[i-1,j], F[i,j-1] ).</p>
<pre><code>class Solution {
public:
   int minPathSum(vector< vector< int > >& grid) {

       int m( grid.size() ), n( grid[ 0 ].size() ), tmp;

       for( int i = 1; i < m; ++i ) grid[ i ][ 0 ] += grid[ i - 1 ][ 0 ];
       for( int i = 1; i < n; ++i ) grid[ 0 ][ i ] += grid[ 0 ][ i - 1 ];
       for( int i = 1; i < m; ++i ) for( int j = 1; j < n; ++j )
          grid[ i ][ j ] += min( grid[ i - 1 ][ j ], grid[ i ][ j - 1 ] );

       return grid[ m - 1 ][ n - 1 ];
   }
};
</code></pre>
<p>Runtime: 28 ms</p>

<h3><a name="48" class="anchor" href="#48"></a>#48 Rotate Image (Medium)</h3>
<p>Flip along middle vertical, then flip along topright-bottomleft diagonal.</p>
<pre><code>class Solution {
public:
   void rotate(vector< vector< int > >& matrix) {

       int n( matrix.size() );

       for( int i = 0; i < n; ++i ) for( int j = 0; j < n >> 1; ++j )
          swap( matrix[ i ][ j ], matrix[ i ][ n - j - 1 ] );
       for( int i = 0; i < n; ++i ) for( int j = 0; j < n - i - 1; ++j )
          swap( matrix[ i ][ j ], matrix[ n - j - 1 ][ n - i - 1 ]);
   }
};
</code></pre>
<p>Runtime: 4 ms</p>

<h3><a name="59" class="anchor" href="#59"></a>#59 Spiral Matrix II (Medium)</h3>
<p>Simple simulation.</p>
<pre><code>class Solution {
public:
    vector< vector< int > > generateMatrix(int n) {

       static const int dx[]{ 0, 1, 0, -1 };
       static const int dy[]{ 1, 0, -1, 0 };

       int step( n ), x( 0 ), y( -1 ), k( 1 );
       vector< vector< int > > result( n, vector< int >( n, 0 ) );

       while( step ){
          for( int i = 0; i < 4; ++i ){
              for( int j = 0; j < step; ++j )
                  result[ x += dx[ i ] ][ y += dy[ i ] ] = k++;
              if( ( i & 1 ) == 0 && --step == 0 ) break;
          }
       }

       return result;
   }
};
</code></pre>
<p>Runtime: 4 ms</p>

<h3><a name="11" class="anchor" href="#11"></a>#11 Container With Most Water (Medium)</h3>
<p>Assume the answer is formed by line i and j, we can be sure that H[i] > H[k] where k > j, and H[j] > H[k] where k < i, so we can shrink left and right borders to cover the answer situation.</p>
<pre><code>class Solution {
public:
   int maxArea(vector< int >& height) {

       int water( 0 );

       for( int i = 0, j = height.size() - 1; i < j; ){
          water = max( water, min( height[ i ], height[ j ] ) * ( j - i ) );
          height[ i ] < height[ j ] ? ++i : --j;
       }

       return water;
   }
};
</code></pre>
<p>Runtime: 24 ms</p>

<h3><a name="216" class="anchor" href="#216"></a>#216 Combination Sum III (Medium)</h3>
<p>Recursively generate.</p>
<pre><code>class Solution {
public:
   vector< vector< int > > combinationSum3(int k, int n) {

       N = n;
       K = k;
       v.clear();
       result.clear();
       generate( 0, 0, 0 );

       return result;
   }

   void generate( int num, int sum, int last ){

       if( num == K || sum == N ){
          if( num == K && sum == N ) result.push_back( v );
          return ;
       }

       for( int i = last + 1; i <= N - sum && i <= 9; ++i ){
          v.push_back( i );
          generate( num + 1, sum + i, i );
          v.pop_back();
       }
   }

   int N, K;
   vector< int > v;
   vector< vector< int > > result;
};
</code></pre>
<p>Runtime: 0 ms</p>

<h3><a name="74" class="anchor" href="#74"></a>#74 Search a 2D Matrix (Medium)</h3>
<p>Treat the matrix as array and use binary search.</p>
<pre><code>class Solution {
public:
    bool searchMatrix(vector< vector< int > >& matrix, int target) {

        int M( matrix.size() ), N( matrix[ 0 ].size() );
        int lower( 0 ), upper( M * N - 1 ), middle, i, j;

        while( upper - lower ){
            middle = lower + ( upper - lower >> 1 );
            if( matrix[ middle / N ][ middle % N ] >= target )
                upper = middle;
            else
                lower = middle + 1;
        }

        return matrix[ upper / N ][ upper % N ] == target;
    }
};
</code></pre>
<p>Runtime: 16 ms</p>

<h3><a name="289" class="anchor" href="#289"></a>#289 Game of Life (Medium)</h3>
<p>Simple simulation. Use second LSB to record new state to solve it in-place.</p>
<pre><code>class Solution {
public:
    void gameOfLife(vector< vector< int > >& board) {

        if( board.empty() || board[ 0 ].empty() ) return;

        static const int dx[]{ -1, -1, -1, 0, 1, 1, 1, 0 };
        static const int dy[]{ -1, 0, 1, 1, 1, 0, -1, -1 };

        int M( board.size() ), N( board[ 0 ].size() ), x, y;

        for( int i = 0; i < M; ++i ){
            for( int j = 0; j < N; ++j ){
                int lives( 0 );
                for( int k = 0; k < 8; ++k ){
                    x = i + dx[ k ]; y = j + dy[ k ] ;
                    if( x >= 0 && x < M && y >= 0 && y < N )
                        lives += board[ x ][ y ] & 1;
                }
                if( lives == 2 )
                    board[ i ][ j ] |= board[ i ][ j ] << 1;
                else if( lives == 3 )
                    board[ i ][ j ] |= 2;
            }
        }

        for( auto &i : board ) for( auto &j : i ) j >>= 1;
    }
};
</code></pre>
<p>Runtime: 0 ms</p>

<h3><a name="77" class="anchor" href="#77"></a>#77 Combinations (Medium)</h3>
<p>Recursively generate.</p>
<pre><code>class Solution {
public:
    vector< vector< int > > combine(int n, int k) {

        N = n; K = k;
        v.clear();
        vv.clear();
        generate( 0, 0 );

        return vv;
    }

    void generate( int num, int last ){

        if( num == K ){ vv.push_back( v ); return; }

        for( int i = last + 1; i <= N; ++i ){
            v.push_back( i );
            generate( num + 1, i );
            v.pop_back();
        }
    }

    int N, K;
    vector< int > v;
    vector< vector< int > > vv;
};
</code></pre>
<p>Runtime: 12 ms</p>

<h3><a name="162" class="anchor" href="#162"></a>#162 Find Peak Element (Medium)</h3>
<p>Ternary search.</p>
<pre><code>class Solution {
public:
    int findPeakElement(vector< int >& nums) {

        int lower( 0 ), upper( nums.size() - 1 );
        int first, second, result;

        while( upper - lower > 2 ){
            first = lower + ( upper - lower ) / 3;
            second = upper - first + lower;
            nums[ first ] < nums[ second ] ? lower = first : upper = second;
        }

        result = lower;
        if( upper - lower > 0 ) result =
            nums[ result ] > nums[ lower + 1 ] ? result : lower + 1;
        if( upper - lower > 1 ) result =
            nums[ result ] > nums[ lower + 2 ] ? result : lower + 2;

        return result;
    }
};
</code></pre>
<p>Runtime: 8 ms</p>

<h3><a name="73" class="anchor" href="#73"></a>#73 Set Matrix Zeroes (Medium)</h3>
<p>The idea is to find a row containing zero, and use it to mark columns to be set to zeroes.</p>
<pre><code>class Solution {
public:
    void setZeroes(vector< vector< int > >& matrix) {

        int zeroRow( -1 );
        int M( matrix.size() ), N( matrix[ 0 ].size() );

        for( int i = 0; i < M; ++i )
            for( int j = 0; j < N; ++j )
                if( matrix[ i ][ j ] == 0 ){ zeroRow = i; i = M; break; }

        if( zeroRow == -1 ) return;

        for( int i = 0; i < M; ++i )
            for( int j = 0; j < N; ++j )
                if( matrix[ i ][ j ] == 0 )
                    matrix[ zeroRow ][ j ] = 0;

        for( int i = 0; i < M; ++i ){
            if( i == zeroRow ) continue;
            for( int j = 0; j < N; ++j ){
                if( matrix[ i ][ j ] ) continue;
                for( int &k : matrix[ i ] ) k = 0;
                break;
            }
        }

        for( int j = 0; j < N; ++j ){
            if( matrix[ zeroRow ][ j ] ) continue;
            for( int i = 0; i < M; ++i )
                matrix[ i ][ j ] = 0;
        }

        for( int &i : matrix[ zeroRow ] ) i = 0;
    }
};
</code></pre>
<p>Runtime: 88 ms</p>

<h3><a name="300" class="anchor" href="#300"></a>#300 Longest Increasing Subsequence (Medium)</h3>
<p>Maintain a ascending list of numbers and use binary search to insert new number.</p>
<pre><code>class Solution {
public:
    int lengthOfLIS(vector< int >& nums) {

        vector< int > v{ 1 << 31 };

        for( int num : nums ) insert( v, num );

        return v.size() - 1;
    }

    void insert( vector< int > &v, int x ){

        if( x > v.back() ){ v.push_back( x ); return; }

        int lower( 0 ), upper( v.size() - 1 ), middle;

        while( upper - lower ){
            middle = lower + ( upper - lower >> 1 );
            v[ middle ] >= x ? upper = middle : lower = middle + 1;
        }

        v[ upper ] = x;
    }
};
</code></pre>
<p>Runtime: 4 ms</p>

<h3><a name="284" class="anchor" href="#284"></a>#284 Peeking Iterator (Medium)</h3>
<p>Create a copy of this iterator and use it to call next().</p>
<pre><code>class PeekingIterator : public Iterator {
public:
    PeekingIterator(const vector< int >& nums) : Iterator(nums) {
    }

    int peek() {
        Iterator iterator( *this );
        return iterator.next();
    }

    int next() {
        return Iterator::next();
    }

    bool hasNext() const {
        return Iterator::hasNext();
    }
};
</code></pre>
<p>Runtime: 4 ms</p>

<h3><a name="173" class="anchor" href="#173"></a>#173 Binary Search Tree Iterator (Medium)</h3>
<p>Use a stack to implement pre-order traversal.</p>
<pre><code>class BSTIterator {
public:
    BSTIterator(TreeNode *root) {
        if( root ) vp.push( make_pair( root, false ) );
    }

    /** @return whether we have a next smallest number */
    bool hasNext() {
        return !vp.empty();
    }

    /** @return the next smallest number */
    int next() {

        auto top( vp.top() ); vp.pop();

        while( !top.second ){
            if( top.first->right ) vp.push( make_pair( top.first->right, false ) );
            vp.push( make_pair( top.first, true ) );
            if( top.first->left ) vp.push( make_pair( top.first->left, false ) );
            top = vp.top(); vp.pop();
        }

        return top.first->val;
    }

    stack< pair< TreeNode *, bool > > vp;
};
</code></pre>
<p>Runtime: 32 ms</p>

<h3><a name="240" class="anchor" href="#240"></a>#240 Search a 2D Matrix II (Medium)</h3>
<p>Perform binary search twice.</p>
<pre><code>class Solution {
public:
    bool searchMatrix(vector< vector< int > >& matrix, int target) {

        int m( 0 ), M( matrix.size() );
        int n( -1 ), N( matrix[ 0 ].size() );
        int lower, upper, mid;

        while( ++n < N ){
            lower = 0; upper = M - 1;
            while( upper - lower ){
                mid = lower + ( upper - lower + 1 >> 1 );
                matrix[ mid ][ n ] > target ? ( upper = mid - 1 ) : ( lower = mid );
            }
            if( matrix[ m = upper ][ n ] == target ) return true;

            lower = n; upper = N - 1;
            while( upper - lower ){
                mid = lower + ( upper - lower + 1 >> 1 );
                matrix[ m ][ mid ] > target ? ( upper = mid - 1 ) : ( lower = mid );
            }
            if( matrix[ m ][ n = upper ] == target ) return true;
        }
    }
};
</code></pre>
<p>Runtime: 360 ms</p>
<p>(Discussion) Different solution. Not necessarily faster.</p>
<pre><code>class Solution {
public:
    bool searchMatrix(vector< vector< int > >& matrix, int target) {

        int M( matrix.size() ), m( 0 );
        int N( matrix[ 0 ].size() ), n( N - 1 );

        while( m < M && n >= 0 ){
            if( matrix[ m ][ n ] == target ) return true;
            matrix[ m ][ n ] > target ? --n : ++m;
        }

        return false;
    }
};
</code></pre>
<p>Runtime: 360 ms</p>

<h3><a name="199" class="anchor" href="#199"></a>#199 Binary Tree Right Side View (Medium)</h3>
<p>Traverse right subtree first then left subtree. Record first met node of each layer.</p>
<pre><code>class Solution {
public:
    vector< int > rightSideView(TreeNode* root) {

        v.clear();
        if( root ) traverse( root, 1 );

        return v;
    }

    void traverse( TreeNode *root, int depth ){
        if( depth > v.size() ) v.push_back( root->val );
        if( root->right ) traverse( root->right, depth + 1 );
        if( root->left ) traverse( root->left, depth + 1 );
    }

    vector< int > v;
};
</code></pre>
<p>Runtime: 4 ms</p>

<h3><a name="274" class="anchor" href="#274"></a>#274 H-Index (Medium)</h3>
<p>Sort citations and perform binary search.</p>
<pre><code>class Solution {
public:
    int hIndex(vector< int >& citations) {

        if( citations.empty() ) return 0;

        sort( citations.begin(), citations.end() );

        int nCitations( citations.size() );
        int lower( 0 ), upper( citations.back() ), mid;

        while( upper - lower ){
            mid = lower + ( upper - lower + 1 >> 1 );
            if( nCitations - find( citations, mid ) >= mid )
                lower = mid;
            else
                upper = mid - 1;
        }

        return upper;
    }

    int find( vector< int > &v, int x ){
        int lower( 0 ), upper( v.size() - 1 ), mid;
        while( upper - lower ){
            mid = lower + ( upper - lower >> 1 );
            v[ mid ] < x ? lower = mid + 1 : upper = mid;
        }
        return upper;
    }
};
</code></pre>
<p>Runtime: 4 ms</p>
<p>(Discussion) Citations greater that n can be treated as n.</p>
<pre><code>class Solution {
public:
    int hIndex(vector< int >& citations) {

        if( citations.empty() ) return 0;

        int N( citations.size() );
        vector< int > v( N + 1, 0 );

        for( int i : citations ) i > N ? ++v[ N ] : ++v[ i ];
        for( int i = N, j = 0; i >= 0; --i )
            if( ( j += v[ i ] ) >= i ) return i;
    }
};
</code></pre>
<p>Runtime: 4 ms</p>

<h3><a name="275" class="anchor" href="#275"></a>#275 H-Index II (Medium)</h3>
<p>Binary search.</p>
<pre><code>class Solution {
public:
    int hIndex(vector< int >& citations) {

        if( citations.empty() ) return 0;
        if( citations.back() == 0 ) return 0;

        int nCitations( citations.size() );
        int lower( 1 ), upper( nCitations ), mid;

        while( upper - lower ){
            mid = lower + ( upper - lower + 1 >> 1 );
            if( mid <= citations[ nCitations - mid ] )
                lower = mid;
            else
                upper = mid - 1;
        }

        return upper;
    }
};
</code></pre>
<p>Runtime: 12 ms</p>

<h3><a name="80" class="anchor" href="#80"></a>#80 Remove Duplicates from Sorted Array II (Medium)</h3>
<p>If the current number is equal to the third number from the current one, do not add it to result.</p>
<pre><code>class Solution {
public:
    int removeDuplicates(vector< int >& nums) {

        int nNums( nums.size() ), j( 0 );

        for( int i = 0; i < nNums; ++i ){
            if( i + 2 < nNums && nums[ i ] == nums[ i + 2 ] ) continue;
            nums[ j++ ] = nums[ i ];
        }

        return j;
    }
};
</code></pre>
<p>Runtime: 20 ms</p>

<h3><a name="200" class="anchor" href="#200"></a>#200 Number of Islands (Medium)</h3>
<p></p>
<pre><code>class Solution {
public:
    int numIslands(vector< vector<char>>& grid) {

        if( grid.empty() || grid[ 0 ].empty() ) return 0;

        static const int dx[]{ -1, 0, 1, 0 };
        static const int dy[]{ 0, 1, 0, -1 };

        int M( grid.size() );
        int N( grid[ 0 ].size() );
        int result( 0 );

        for( int i = 0; i < M; ++i ){
            for( int j = 0; j < N; ++j ){
                if( grid[ i ][ j ] == '0' ) continue;
                ++result; grid[ i ][ j ] = '0';
                mqueue.push( make_pair( i, j ) );
                while( !mqueue.empty() ){
                    for( int k = 0; k < 4; ++k ){
                        int x( mqueue.front().first + dx[ k ] );
                        int y( mqueue.front().second + dy[ k ] );
                        if( x < 0 || x >= M || y < 0 || y >= N ) continue;
                        if( grid[ x ][ y ] == '0' ) continue;
                        grid[ x ][ y ] = '0';
                        mqueue.push( make_pair( x, y ) );
                    }
                    mqueue.pop();
                }
            }
        }

        return result;
    }

    queue< pair< int, int > > mqueue;
};
</code></pre>
<p>Runtime: 16 ms</p>

<h3><a name="241" class="anchor" href="#241"></a>#241 Different Ways to Add Parentheses (Medium)</h3>
<p>DFS.</p>
<pre><code>[ugly code]
</code></pre>
<p>Runtime: 4 ms</p>

<h3><a name="142" class="anchor" href="#142"></a>#142 Linked List Cycle II (Medium)</h3>
<p>Fast pointer walks twice as fast as slow pointer. When they meet, let one of them point to head then they walk at same speed. The entry is where they meet.</p>
<pre><code>class Solution {
public:
    ListNode *detectCycle(ListNode *head) {

        ListNode dummy( 0 ); dummy.next = head;
        ListNode *slow( &dummy ), *fast( &dummy );

        while( fast == &dummy || fast && slow != fast ){
            slow = slow->next;
            fast = fast->next;
            if( fast == NULL ) return NULL;
            fast = fast->next;
        }

        if( !fast ) return NULL;

        slow = &dummy;

        while( slow != fast ){
            slow = slow->next;
            fast = fast->next;
        }

        return fast;
    }
};
</code></pre>
<p>Runtime: 12 ms</p>

<h3><a name="129" class="anchor" href="#129"></a>#129 Sum Root to Leaf Numbers (Medium)</h3>
<p>DFS.</p>
<pre><code>class Solution {
public:
    int sumNumbers(TreeNode* root) {

        if( !root ) return 0;
        result = 0;
        traverse( root, 0 );

        return result;
    }
    <!--  -->
    void traverse( TreeNode *root, int a ){
        a = a * 10 + root->val;
        if( !root->left && !root->right ){ result += a; return; }
        if( root->left ) traverse( root->left, a );
        if( root->right ) traverse( root->right, a );
    }

    int result;
};
</code></pre>
<p>Runtime: 4 ms</p>

<h3><a name="81" class="anchor" href="#81"></a>#81 Search in Rotated Sorted Array II (Medium)</h3>
<p>Worst case time complexity: O(n).</p>
<pre><code>class Solution {
public:
    bool search(vector< int >& nums, int target ) {

        int lower( 0 ), upper( nums.size() - 1 ), mid;

        while( upper - lower ){
            mid = lower + ( upper - lower >> 1 );
            if( nums[ mid ] == nums[ upper ] ) --upper;
            else if( nums[ mid ] < nums[ upper ] ){
                target > nums[ mid ] && target <= nums[ upper ] ?
                    ( lower = mid + 1 ) : ( upper = mid );
            }else{
                target > nums[ mid ] || target <= nums[ upper ] ?
                    ( lower = mid + 1 ) : ( upper = mid );
            }
        }

        return nums[ upper ] == target;
    }
};
</code></pre>
<p>Runtime: 8 ms</p>

<h3><a name="215" class="anchor" href="#215"></a>#215 Kth Largest Element in an Array (Medium)</h3>
<p>Idea of partition in qsort. Or use std::nth_element.</p>
<pre><code>class Solution {
public:
    int findKthLargest(vector< int >& nums, int k) {
        return find( nums, k, 0, nums.size() - 1 );
    }

    int find( vector< int > &nums, int k, int l, int r ){

        if( r == l ) return nums[ l ];

        int m( nums[ l + rand() % ( r - l + 1 ) ] );
        int i( l - 1 ), j( r + 1 );

        for( int k = l; k < j; ){
            if( nums[ k ] > m ) nums[ ++i ] = nums[ k++ ];
            else if( nums[ k ] < m ){ --j; swap( nums[ k ], nums[ j ] ); }
            else ++k;
        }

        if( i - l + 1 >= k )
            return find( nums, k, l, i );
        else if( k > j - l )
            return find( nums, k - j + l, j, r );
        else
            return m;
    }
};
</code></pre>
<p>Runtime: 12 ms</p>

<h3><a name="279" class="anchor" href="#279"></a>#279 Perfect Squares (Medium)</h3>
<p>Recursively search for solutions with least number of squares that sum to n.</p>
<pre><code>class Solution {
public:
    int numSquares(int n) {

        for( int i = 1; ; ++i )
            if( helper( i, n ) )
                return i;
    }

    bool helper( int a, int s ){

        int r( sqrt( s + 0. ) );

        if( a == 1 ) return s == r * r ? true : false;

        for( int i = r; r >= 1; --r )
            if( helper( a - 1, s - r * r ) )
                return true;

        return false;
    }
};
</code></pre>
<p>Runtime: 4 ms</p>

<h3><a name="114" class="anchor" href="#114"></a>#114 Flatten Binary Tree to Linked List (Medium)</h3>
<p>Recursively flatten the left subtree and right subtree, connect right subtree to tail of left subtree and make left subtree into right, finally return tail of whole tree.</p>
<pre><code>class Solution {
public:
    void flatten(TreeNode* root) {
        if( root ) helper( root );
    }

    TreeNode* helper( TreeNode* root ){

        TreeNode* tail( root );

        if( root->left ){
            tail = helper( root->left );
            tail->right = root->right;
            root->right = root->left;
            root->left = NULL;
        }
        if( tail->right )
            tail = helper( tail->right );

        return tail;
    }
};
</code></pre>
<p>Runtime: 8 ms</p>

<h3><a name="313" class="anchor" href="#313"></a>#313 Super Ugly Number (Medium)</h3>
<p>Use an array to record the next ugly number to multiply with to produce a new ugly number.</p>
<pre><code>class Solution {
public:
    int nthSuperUglyNumber(int n, vector< int >& primes) {

        int nPrimes( primes.size() );
        vector< int > ugly( n, 0x7fffffff );
        vector< int > next( nPrimes, 0 );

        ugly[ 0 ] = 1;

        for( int i = 1; i < n; ++i ){
            for( int j = 0; j < nPrimes; ++j )
                ugly[ i ] = min( ugly[ i ], primes[ j ] * ugly[ next[ j ] ] );
            for( int j = 0; j < nPrimes; ++j )
                next[ j ] += ugly[ i ] == primes[ j ] * ugly[ next[ j ] ];
        }

        return ugly[ n - 1 ];
    }
};
</code></pre>
<p>Runtime: 140 ms</p>

<h3><a name="78" class="anchor" href="#78"></a>#78 Subsets (Medium)</h3>
<p>Sort the numbers. Iterate a variable from 0 to 2^{# of numbers} and use its bitsets to indicate seletion of numbers.</p>
<pre><code>class Solution {
public:
    vector< vector< int > > subsets(vector< int >& nums) {

        int nNums( nums.size() );
        vector< vector< int > > vv;
        vector< int > v;

        sort( nums.begin(), nums.end() );

        for( int i = 0; i < 1 << nNums; ++i ){
            v.clear();
            for( int j = 0; j < nNums; ++j )
                if( 1 << j & i ) v.push_back( nums[ j ] );
            vv.push_back( v );
        }

        return vv;
    }
};
</code></pre>
<p>Runtime: 8 ms</p>

<h3><a name="39" class="anchor" href="#39"></a>#39 Combination Sum (Medium)</h3>
<p>Sort the numbers. DFS for all combinations.</p>
<pre><code>class Solution {
public:
    vector< vector< int > > combinationSum(vector< int >& candidates, int target) {

        sort( candidates.begin(), candidates.end() );
        v.clear(); vv.clear();
        generate( candidates, 0, target );

        return vv;
    }

    void generate( vector< int >& nums, int a, int sum ){

        if( sum == 0 ){ vv.push_back( v ); return; }
        if( a == nums.size() || sum < nums[ a ] ) return;

        generate( nums, a + 1, sum );
        v.push_back( nums[ a ] );
        generate( nums, a, sum - nums[ a ] );
        v.pop_back();
    }

    vector< int > v;
    vector< vector< int > > vv;
};
</code></pre>
<p>Runtime: 16 ms</p>

<h3><a name="109" class="anchor" href="#109"></a>#109 Convert Sorted List to Binary Search Tree (Medium)</h3>
<p>Find middle node and create root then recursively build left and right subtrees.</p>
<pre><code>class Solution {
public:
    TreeNode* sortedListToBST(ListNode* head) {

        if( !head ) return NULL;

        auto slow( head ), fast( head );

        while( true ){
            fast = fast->next;
            if( !fast || !fast->next ) break;
            fast = fast->next;
            if( !fast || !fast->next ) break;
            slow = slow->next;
        }

        fast = slow->next;
        slow->next = NULL;

        TreeNode* root;

        if( fast ){
            root = new TreeNode( fast->val );
            root->left = sortedListToBST( head );
            root->right = sortedListToBST( fast->next );
        }else{
            root = new TreeNode( head->val );
        }

        return root;
    }
};
</code></pre>
<p>Runtime: 28 ms</p>

<h3><a name="90" class="anchor" href="#90"></a>#90 Subsets II (Medium)</h3>
<p>DFS for all combinations.</p>
<pre><code>class Solution {
public:
    vector< vector< int > > subsetsWithDup(vector< int >& nums) {

        v.clear();
        vv.clear();
        m.clear();
        for( int num : nums )
            m.find( num ) == m.end() ?
                m[ num ] = 1 : m[ num ] += 1;
        ite = m.begin();
        generate( nums );

        return vv;
    }

    void generate( vector< int >& nums ){

        if( ite == m.end() ){ vv.push_back( v ); return; }

        ++ite; generate( nums ); --ite;
        for( int i = ite->second; i > 0; --i ){
            v.push_back( ite->first );
            ++ite; generate( nums ); --ite;
        }
        for( int i = ite->second; i > 0; --i )
            v.pop_back();
    }

    vector< int > v;
    vector< vector< int > > vv;
    map< int, int > m;
    map< int, int >::iterator ite;
};
</code></pre>
<p>Runtime: 12 ms</p>

<h3><a name="213" class="anchor" href="#213"></a>#213 House Robber II (Medium)</h3>
<p>Assume the first house is robbed or not and do DP as in #109.</p>
<pre><code>class Solution {
public:
    int rob(vector< int >& nums) {

        if( nums.empty() ) return 0;
        if( nums.size() == 1 ) return nums.back();

        int result1, result2;
        int nNums( nums.size() );
        vector< int > a( nNums );
        vector< int > b( nNums );

        a[ 0 ] = nums[ 0 ];
        b[ 0 ] = 1 << 31;

        for( int i = 1; i < nNums; ++i ){
            a[ i ] = max( a[ i - 1 ], b[ i - 1 ] + nums[ i ] );
            b[ i ] = max( a[ i - 1 ], b[ i - 1 ] );
        }

        result1 = b.back();

        a[ 0 ] = 1 << 31;
        b[ 0 ] = 0;

        for( int i = 1; i < nNums; ++i ){
            a[ i ] = max( a[ i - 1 ], b[ i - 1 ] + nums[ i ] );
            b[ i ] = max( a[ i - 1 ], b[ i - 1 ] );
        }

        result2 = max( a.back(), b.back() );

        return max( result1, result2 );
    }
};
</code></pre>
<p>Runtime: 0 ms</p>

<h3><a name="120" class="anchor" href="#120"></a>#120 Triangle (Medium)</h3>
<p>Simple DP. Let F[i,j] denote minimum points can be gained arriving at position(i, j), then we have:<br>
F[i, j] = min( F[i-1, j-1], F[i-1, j] ) + point[i, j].</p>
<pre><code>class Solution {
public:
    int minimumTotal(vector< vector< int > >& triangle) {

        int n( triangle.size() ), result( 1 << 30 );

        for( int i = 1; i < n; ++i ){
            triangle[ i ].front() += triangle[ i - 1 ].front();
            triangle[ i ].back() += triangle[ i - 1 ].back();
            for( int j = 1; j < i; ++j )
                triangle[ i ][ j ] += min(
                    triangle[ i - 1 ][ j - 1 ],
                    triangle[ i - 1 ][ j ]
                );
        }

        for( int i : triangle.back() ) result = min( result, i );

        return result;
    }
};
</code></pre>
<p>Runtime: 16 ms</p>

<h3><a name="95" class="anchor" href="#95"></a>#95 Unique Binary Search Trees II (Medium)</h3>
<p>Generate using DP.</p>
<pre><code>class Solution {
public:
    vector<TreeNode*> generateTrees(int n) {

        if( !n ) return vector< TreeNode* >();

        vector< TreeNode* > result;
        vector< int > start{ -1 };
        vector< int > count{ 1 };

        for( int m = 1; m <= n; ++m ){
            start.push_back( result.size() );
            count.push_back( 0 );
            for( int root = 1; root <= m; ++root ){
                for( int i = 0; i < count[ root - 1 ]; ++i )
                for( int j = 0; j < count[ m - root ]; ++j ){
                    TreeNode* rt( new TreeNode( root ) );
                    if( start[ root - 1 ] >= 0 ) rt->left = clone( result[ start[ root - 1 ] + i ], 0 );
                    if( start[ m - root ] >= 0 ) rt->right = clone( result[ start[ m - root ] + j ], root );
                    result.push_back( rt );
                    ++count.back();
                }
            }
        }

        return vector< TreeNode* >( result.begin() + start[ n ], result.end() );
    }

private:
    TreeNode* clone( TreeNode* root, int add ){
        TreeNode* root2 = new TreeNode( root->val + add );
        if( root->left ) root2->left = clone( root->left, add );
        if( root->right ) root2->right = clone( root->right, add );
        return root2;
    }
};
</code></pre>
<p>Runtime: 24 ms</p>

<h3><a name="63" class="anchor" href="#63"></a>#63 Unique Paths II (Medium)</h3>
<p>Same as #62, except that the grid with obstacle should be set to 0.</p>
<pre><code>class Solution {
public:
    int uniquePathsWithObstacles(vector< vector< int > >& obstacleGrid) {

        int M( obstacleGrid.size() );
        int N( obstacleGrid[ 0 ].size() );
        vector< vector< int > >& f( obstacleGrid );

        if( f[ 0 ][ 0 ] == 1 ) return 0;
        f[ 0 ][ 0 ] = 1;

        for( int i = 0; i < M; ++i )
        for( int j = i == 0; j < N; ++j ){
            if( f[ i ][ j ] == 1 ){ f[ i ][ j ] = 0; continue; }
            if( i > 0 ) f[ i ][ j ] += f[ i - 1 ][ j ];
            if( j > 0 ) f[ i ][ j ] += f[ i ][ j - 1 ];
        }

        return f.back().back();
    }
};
</code></pre>
<p>Runtime: 8 ms</p>

<h3><a name="201" class="anchor" href="#201"></a>#201 Bitwise AND of Numbers Range (Medium)</h3>
<p>The result shares the same suffix with n and m in binary representation.</p>
<pre><code>class Solution {
public:
    int rangeBitwiseAnd(int m, int n) {

        int result( 0xffffffff ), shift( 0 );

        while( m && n - m > 1 ){
            m >>= 1;
            n >>= 1;
            ++shift;
        }

        return m ? ( m & n ) << shift : 0;
    }
};
</code></pre>
<p>Runtime: 68 ms</p>

<h3><a name="86" class="anchor" href="#86"></a>#86 Partition List (Medium)</h3>
<p>Simple linked list operations.</p>
<pre><code>class Solution {
public:
    ListNode* partition(ListNode* head, int x) {

        ListNode headA( 0 ), *tailA( &headA );
        ListNode headB( 0 ), *tailB( &headB );

        for( auto ptr = head; ptr; ptr = ptr->next )
            ptr->val < x ? tailA = tailA->next = ptr : tailB = tailB->next = ptr;

        tailA->next = headB.next;
        tailB->next = NULL;

        return headA.next;
    }
};
</code></pre>
<p>Runtime: 8 ms</p>

<h3><a name="34" class="anchor" href="#34"></a>#34 Search for a Range (Medium)</h3>
<p>Binary search twice.</p>
<pre><code>class Solution {
public:
    vector< int > searchRange(vector< int >& nums, int target) {

        vector< int > result;
        int lower( 0 ), upper( nums.size() - 1 ), mid;

        while( upper - lower ){
            mid = lower + ( upper - lower >> 1 );
            nums[ mid ] < target ? ( lower = mid + 1 ) : ( upper = mid );
        }

        if( nums[ upper ] != target ) return vector< int >{ -1, -1 };
        result.push_back( upper );
        lower = 0; upper = nums.size() - 1;

        while( upper - lower ){
            mid = lower + ( upper - lower + 1 >> 1 );
            nums[ mid ] > target ? ( upper = mid - 1 ) : ( lower = mid );
        }

        result.push_back( upper );
        return result;
    }
};
</code></pre>
<p>Runtime: 12 ms</p>

<h3><a name="147" class="anchor" href="#147"></a>#147 Insertion Sort List (Medium)</h3>
<p>Sort recursively.</p>
<pre><code>class Solution {
public:
    ListNode* insertionSortList(ListNode* head) {

        if( !head ) return NULL;

        ListNode dummy( 0 ); dummy.next = head;
        helper( &dummy );

        return dummy.next;
    }

private:
    void helper( ListNode* head ){
        if( head->next ) helper( head->next );
        insert( head );
    }

    void insert( ListNode* head ){

        if( !head->next || !head->next->next ) return;

        auto nxt( head->next );
        auto ptr( head->next );

        while( ptr->next && ptr->next->val < nxt->val ) ptr = ptr->next;
        if( ptr == nxt ) return;

        head->next = nxt->next;
        nxt->next = ptr->next;
        ptr->next = nxt;
    }
};
</code></pre>
<p>Runtime: 80 ms</p>

<h3><a name="106" class="anchor" href="#106"></a>#106 Construct Binary Tree from Inorder and Postorder Traversal (Medium)</h3>
<p>Recursively build tree.</p>
<pre><code>class Solution {
public:
    TreeNode* buildTree(vector< int >& inorder, vector< int >& postorder) {

        if( inorder.empty() ) return NULL;

        this->inorder = inorder;
        this->postorder = postorder;

        return build( 0, inorder.size() - 1, 0, postorder.size() - 1 );
    }

    TreeNode* build( int a, int b, int c, int d ){

        if( a == b ) return new TreeNode( inorder[ a ] );

        TreeNode *root = new TreeNode( postorder[ d ] );

        int m; for( m = a; inorder[ m ] != postorder[ d ]; ++m );
        if( m > a ) root->left = build( a, m - 1, c, c - 1 + m - a );
        if( m < b ) root->right = build( m + 1, b, c + m - a, d - 1 );

        return root;
    }

    vector< int > inorder;
    vector< int > postorder;
};
</code></pre>
<p>Runtime: 48 ms</p>

<h3><a name="16" class="anchor" href="#16"></a>#16 3Sum Closest (Medium)</h3>
<p>Loop for first element, shrink range of second and third elements to make sum closer to target.</p>
<pre><code>class Solution {
public:
    int threeSumClosest(vector< int >& nums, int target) {

        int N( nums.size() );
        int result( 0x7fffffff );

        sort( nums.begin(), nums.end() );

        for( int i = 0; i < N - 2; ++i ){
            int j( i + 1 ), k( N - 1 ), M( target - nums[ i ] );
            while( j < k ){
                if( abs( nums[ j ] + nums[ k ] - M ) < abs( result ) )
                    result = nums[ j ] + nums[ k ] - M;
                if( result == 0 ) return target;
                M - nums[ j ] - nums[ k ] > 0 ? ++j : --k;
            }
        }

        return target + result;
    }
};
</code></pre>
<p>Runtime: 16 ms</p>

<h3><a name="236" class="anchor" href="#236"></a>#236 Lowest Common Ancestor of a Binary Tree (Medium)</h3>
<p>During traversal the first root whose tree contains v and w is LCA.</p>
<pre><code>class Solution {
public:
    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {

        this->p = p;
        this->q = q;
        isFound = false;
        helper( root );

        return result;
    }

    int helper( TreeNode* root ){

        if( !root ) return 0;

        int count{
            ( root == p ) + ( root == q )
            + helper( root->left )
            + helper( root->right )
        };

        if( count == 2 && !isFound ){
            isFound = true;
            result = root;
        }

        return count;
    }

    bool isFound;
    TreeNode *p, *q, *result;
};
</code></pre>
<p>Runtime: 24 ms</p>

<h3><a name="103" class="anchor" href="#103"></a>#103 Binary Tree Zigzag Level Order Traversal (Medium)</h3>
<p>Search and print in layers. Print order corresponds to parity of layer.</p>
<pre><code>typedef pair< TreeNode*, int > PTI;

class Solution {
public:
    vector< vector< int > > zigzagLevelOrder(TreeNode* root) {

        if( !root ) return vector< vector< int > >();

        int depth( 0 ), lastSize( 0 );
        vector< int > v;
        vector< PTI > q;
        vector< vector< int > > vv;

        q.push_back( PTI( root, 0 ) );

        while( q.size() - lastSize ){

            int start( depth & 1 ? q.size() - 1 : lastSize );
            int end( depth & 1 ? lastSize - 1 : q.size() );
            int step( depth & 1 ? -1 : 1 );

            for( int i = start; i != end; i += step )
                v.push_back( q[ i ].first->val );

            start = lastSize; end = lastSize = q.size();

            for( int i = start; i != end; ++i ){
                auto p( q[ i ].first );
                if( p->left ) q.push_back( PTI( p->left, depth + 1 ) );
                if( p->right ) q.push_back( PTI( p->right, depth + 1 ) );
            }

            vv.push_back( v );
            v.clear();
            ++depth;
        }

        return vv;
    }
};
</code></pre>
<p>Runtime: 4 ms</p>

<h3><a name="55" class="anchor" href="#55"></a>#55 Jump Game (Medium)</h3>
<p>Record the maximal index so for can be jumped to. Return false if current index is less then the max index.</p>
<pre><code>class Solution {
public:
    bool canJump(vector< int >& nums) {

        int N( nums.size() ), M( 0 );

        for( int i = 0; i < N; ++i ){
            if( i > M ) return false;
            M = max( M, nums[ i ] + i );
        }

        return true;
    }
};
</code></pre>
<p>Runtime: 16 ms</p>

<h3><a name="50" class="anchor" href="#50"></a>#50 Pow( x, n ) (Medium)</h3>
<p>Use binary optimization.</p>
<pre><code>class Solution {
public:
    double myPow(double x, int n) {

        if( n == 1 << 31 ) return myPow( x * x, n >> 1 );
        if( n < 0 ) return 1. / myPow( x, -n );

        double result( 1. );

        while( n ){
            if( n & 1 ) result *= x;
            x *= x;
            n >>= 1;
        }

        return result;
    }
};
</code></pre>
<p>Runtime: 4 ms</p>

<h3><a name="105" class="anchor" href="#105"></a>#105 Construct Binary Tree from Preorder and Inorder Traversal (Medium)</h3>
<p>Recursively build tree.</p>
<pre><code>class Solution {
public:
    TreeNode* buildTree(vector< int >& preorder, vector< int >& inorder) {

        if( inorder.empty() ) return NULL;

        this->inorder = inorder;
        this->preorder = preorder;

        return build( 0, inorder.size() - 1, 0, preorder.size() - 1 );
    }

    TreeNode* build( int a, int b, int c, int d ){

        if( a == b ) return new TreeNode( inorder[ a ] );

        TreeNode *root = new TreeNode( preorder[ c ] );

        int m; for( m = a; inorder[ m ] != preorder[ c ]; ++m );
        if( m > a ) root->left = build( a, m - 1, c + 1, c + m - a );
        if( m < b ) root->right = build( m + 1, b, c + 1 + m - a, d );

        return root;
    }

    vector< int > inorder;
    vector< int > preorder;
};
</code></pre>
<p>Runtime: 48 ms</p>

<h3><a name="113" class="anchor" href="#113"></a>#113 Path Sum II (Medium)</h3>
<p>DFS for all path.</p>
<pre><code>class Solution {
public:
    vector< vector< int > > pathSum(TreeNode* root, int sum) {

        if( !root ) return vector< vector< int > >();

        vi.clear();
        vvi.clear();
        helper( root, sum );

        return vvi;
    }

    void helper( TreeNode* root, int sum ){

        vi.push_back( root->val );

        if( !root->left && !root->right ){
            if( sum == root->val ) vvi.push_back( vi );
            vi.pop_back();
            return;
        }
        if( root->left ) helper( root->left, sum - root->val );
        if( root->right ) helper( root->right, sum - root->val );
        vi.pop_back();
    }

    vector< int > vi;
    vector< vector< int > > vvi;
};
</code></pre>
<p>Runtime: 12 ms</p>

<h3><a name="131" class="anchor" href="#131"></a>#131 Palindrome Partitioning (Medium)</h3>
<p>DFS for all ways of partitioning.</p>
<pre><code>class Solution {
public:
    vector< vector<string>> partition(string s) {

        length = s.length();
        vs.clear();
        vvs.clear();
        helper( s, 0 );

        return vvs;
    }

private:
    void helper( const string &s, int a ){

        if( a == length ){ vvs.push_back( vs ); return; }

        for( int i = a; i < length; ++i )
            if( isPalindrome( s.substr( a, i - a + 1 ) ) ){
                vs.push_back( s.substr( a, i - a + 1 ) );
                helper( s, i + 1 );
                vs.pop_back();
            }
    }

    bool isPalindrome( const string &s ){

        int length( s.length() );

        for( int i = 0; i < length >> 1; ++i )
            if( s[ i ] != s[ length - i - 1 ] )
                return false;

        return true;
    }

    int length;
    vector< string > vs;
    vector< vector< string > > vvs;
};
</code></pre>
<p>Runtime: 20 ms</p>

<h3><a name="17" class="anchor" href="#17"></a>#17 Letter Combination of a Phone Number (Medium)</h3>
<p>DFS for all combinations.</p>
<pre><code>class Solution {
public:
    vector<string> letterCombinations(string digits) {

        if( digits.empty() ) return vector< string >();

        s = "";
        vs.clear();
        helper( digits, 0 );

        return vs;
    }

private:
    void helper( string &digits, int a ){

        if( a == digits.length() ){ vs.push_back( s ); return; }

        for( char ch : d2l[ digits[ a ] - '0' ] ){
            s.push_back( ch );
            helper( digits, a + 1 );
            s.pop_back();
        }
    }

    const vector< vector< char > > d2l{
        {}, {}, { 'a', 'b', 'c' }, { 'd', 'e', 'f' }, { 'g', 'h', 'i' },
        { 'j', 'k', 'l' }, { 'm', 'n', 'o' }, { 'p', 'q', 'r', 's' },
        { 't', 'u', 'v' }, { 'w', 'x', 'y', 'z' }
    };

    string s;
    vector< string > vs;
};
</code></pre>
<p>Runtime: 0 ms</p>

<h3><a name="47" class="anchor" href="#47"></a>#47 Permutations II (Medium)</h3>
<p>Sort nums first. Insert the new number into previously generated permutations to prodece new permutations. Should not insert to positions prior to its previous appearance.</p>
<pre><code>class Solution {
public:
    vector< vector< int > > permuteUnique( vector< int >& nums) {

        sort( nums.begin(), nums.end() );
        vi.clear();
        vvi.clear();
        vi.push_back( nums.front() );
        helper( nums, 1 );

        return vvi;
    }

    void helper( vector< int > &nums, int a ){

        if( a == nums.size() ){
            vvi.push_back( vi );
            return;
        }

        vi.push_back( nums[ a ] );
        helper( nums, a + 1 );
        int i; for( i = a; i > 0; --i ){
            if( vi[ i ] == vi[ i - 1 ] ) break;
            swap( vi[ i ], vi[ i - 1 ] );
            helper( nums, a + 1 );
        }
        for( ; i < a; ++i )
            vi[ i ] = vi[ i + 1 ];
        vi.pop_back();
    }

    vector< int > vi;
    vector< vector< int > > vvi;
};
</code></pre>
<p>Runtime: 32 ms</p>

<h3><a name="92" class="anchor" href="#92"></a>#92 Reverse Linked List II (Medium)</h3>
<p>Linked list manipulation.</p>
<pre><code>class Solution {
public:
    ListNode* reverseBetween(ListNode* head, int m, int n) {

        if( m == n ) return head;

        ListNode dummy( 0 ); dummy.next = head;
        ListNode *ptrA( &dummy ), *ptrB( &dummy );

        for( int i = 0; i < m - 1; ++i, ptrA = ptrA->next );
        for( int j = 0; j < n + 1; ++j, ptrB = ptrB->next );

        ListNode *pre( ptrA ), *cur( pre->next ), *nxt( cur->next );

        for( cur->next = pre; nxt != ptrB; cur->next = pre ){
            pre = cur; cur = nxt; nxt = nxt->next;
        }

        ptrA->next->next = ptrB;
        ptrA->next = cur;

        return dummy.next;
    }
};
</code></pre>
<p>Runtime: 4 ms</p>

<h3><a name="134" class="anchor" href="#134"></a>#134 Gas Station (Medium)</h3>
<p>First simulate regardless of negative amount of gas. The station where the car has least amount of gas is the starting station.</p>
<pre><code>class Solution {
public:
    int canCompleteCircuit(vector< int >& gas, vector< int >& cost) {

        int start, minGas( 0x7fffffff );
        int sumGas( 0 ), sumCost( 0 );

        for( int i = 0; i < gas.size(); ++i ){
            sumGas += gas[ i ];
            sumCost += cost[ i ];
            if( minGas > sumGas - sumCost ){
                minGas = sumGas - sumCost;
                start = i + 1;
            }
        }

        return sumGas < sumCost ? -1 : start == gas.size() ? 0 : start;
    }
};
</code></pre>
<p>Runtime: 0 ms</p>

<h3><a name="40" class="anchor" href="#40"></a>#40 Combination Sum II (Medium)</h3>
<p>DFS for all combinations.</p>
<pre><code>class Solution {
public:
    vector< vector< int > > combinationSum2(vector< int >& candidates, int target) {

        vi.clear();
        vvi.clear();
        sort( candidates.begin(), candidates.end() );
        helper( candidates, 0, target );

        return vvi;
    }

    void helper( vector< int > &nums, int a, int sum ){

        if( !sum || a == nums.size() ){
            if( !sum ) vvi.push_back( vi );
            return;
        }

        int b; for( b = a; b < nums.size() && nums[ b ] == nums[ a ]; ++b );
        int c; for( c = 1; c <= b - a && nums[ a ] * c <= sum; ++c ){
            vi.push_back( nums[ a ] );
            helper( nums, b, sum - nums[ a ] * c );
        }
        while( --c ) vi.pop_back();
        helper( nums, b, sum );
    }

    vector< int > vi;
    vector< vector< int > > vvi;
};
</code></pre>
<p>Runtime: 16 ms</p>

<h3><a name="82" class="anchor" href="#82"></a>#82 Remove Duplicates from Sorted List iI (Medium)</h3>
<p>Add a dummy head to simplify operation.</p>
<pre><code>class Solution {
public:
    ListNode* deleteDuplicates(ListNode* head) {

        ListNode dummy( 0 ); dummy.next = head;
        ListNode *ptr( &dummy );

        while( ptr->next && ptr->next->next ){
            if( ptr->next->val != ptr->next->next->val ){
                ptr = ptr->next;
                continue;
            }

            int val( ptr->next->val );
            while( ptr->next && ptr->next->val == val ){
                auto nnxt( ptr->next->next );
                delete ptr->next;
                ptr->next = nnxt;
            }
        }

        return dummy.next;
    }
};
</code></pre>
<p>Runtime: 8 ms</p>

<h3><a name="49" class="anchor" href="#49"></a>#49 Group Anagrams (Medium)</h3>
<p>Hash function accounts for word length and letter components.</p>
<pre><code>class Solution {
public:
    vector< vector< string > > groupAnagrams( vector< string >& strs) {

        map< pair< int, int >, int > umap;
        vector< vector< string > > vvs;

        for( auto &s : strs ){
            auto hashVal( s2pii( s ) );
            if( umap.find( hashVal ) != umap.end() )
                vvs[ umap[ hashVal ] ].push_back( s );
            else{
                umap[ hashVal ] = vvs.size();
                vvs.push_back( vector< string >{ s } );
            }
        }

        for( auto &vs : vvs ) sort( vs.begin(), vs.end() );

        return vvs;
    }

    pair< int, int > s2pii( const string &s ){

        int tmp1( 0 ), tmp2( 1 );

        for( const char &ch : s ){
            tmp1 |= 1 << ( ch - 'a' );
            tmp2 *= ch - 'a' + 2;
        }

        return make_pair( tmp1, tmp2 );
    }
};
</code></pre>
<p>Runtime: 68 ms</p>

<h3><a name="31" class="anchor" href="#31"></a>#31 Nextr Permutation (Medium)</h3>
<p>Locate the rightmost number we can augment and swap it with the smallest number that is greater that it behind and sort the whole following part.</p>
<pre><code>class Solution {
public:
    void nextPermutation(vector<int>& nums) {

        int i; for( i = nums.size() - 2; i >= 0; --i )
            if( nums[ i ] < nums[ i + 1 ] ) break;

        if( i >= 0 ){
            int k( i + 1 );
            for( int j = k; j < nums.size(); ++j )
                if( nums[ j ] > nums[ i ] && nums[ j ] < nums[ k ] ) k = j;
            swap( nums[ i ], nums[ k ] );
        }

        sort( nums.begin() + i + 1, nums.end() );
    }
};
</code></pre>
<p>Runtime: 12 ms</p>

<h3><a name="209" class="anchor" href="#209"></a>#209 Minimum Size Subarray Sum (Medium)</h3>
<p>Scan the array of numbers. When it comes a new number, add it to sum and try to subtract earliest numbers in the sum.</p>
<pre><code>class Solution {
public:
    int minSubArrayLen(int s, vector<int>& nums) {

        int result( 0x7fffffff );
        int sum( 0 );

        for( int i = 0, j = 0; j < nums.size(); ++j ){
            sum += nums[ j ];
            while( sum - nums[ i ] >= s ) sum -= nums[ i++ ];
            if( sum >= s ) result = min( result, j - i + 1 );
        }

        return result == 0x7fffffff ? 0 : result;
    }
};
</code></pre>
<p>Runtime: 4 ms</p>

<h3><a name="264" class="anchor" href="#264"></a>#Ugly Number II (Medium)</h3>
<p></p>
<pre><code>class Solution {
public:
    int nthUglyNumber(int n) {

        vector< int > ugly( n, 0x7fffffff );
        vector< int > next{ 0, 0, 0 };
        vector< int > primes{ 2, 3, 5 };

        ugly[ 0 ] = 1;

        for( int i = 1; i < n; ++i ){
            for( int j = 0; j < 3; ++j ) ugly[ i ] = min( ugly[ i ], ugly[ next[ j ] ] * primes[ j ] );
            for( int j = 0; j < 3; ++j ) next[ j ] += ugly[ i ] == ugly[ next[ j ] ] * primes[ j ] ? 1 : 0;
        }

        return ugly.back();
    }
};
</code></pre>
<p>Runtime: 32 ms</p>

<h3><a name="297" class="anchor" href="#297"></a>#297 Serialize and Deserialize Binary Tree (Medium)</h3>
<p>Use std::queue.</p>
<pre><code>class Codec {
public:

    // Encodes a tree to a single string.
    string serialize(TreeNode* root) {

        queue< TreeNode * > mqueue;
        string result;

        mqueue.push( root );

        while( !mqueue.empty() ){
            auto pNode( mqueue.front() ); mqueue.pop();
            if( pNode == NULL ){ result += "# "; continue; }
            result += to_string( pNode->val ) + " ";
            mqueue.push( pNode->left ? pNode->left : NULL );
            mqueue.push( pNode->right ? pNode->right : NULL );
        }

        while( result.back() == ' ' || result.back() == '#' )
            result.pop_back();

        return result;
    }

    // Decodes your encoded data to tree.
    TreeNode* deserialize(string data) {

        TreeNode *root;
        queue< TreeNode * > mqueue, mqueue2;
        istringstream iss( data );
        string s;
        int i;

        while( true ){
            while( iss >> i ) mqueue.push( new TreeNode( i ) );
            iss.clear(); if( !( iss >> s ) ) break;
            mqueue.push( NULL );
        }

        if( mqueue.empty() ) return NULL;

        root = mqueue.front();
        mqueue.pop();
        mqueue2.push( root );

        while( !mqueue.empty() ){
            auto pNode( mqueue2.front() ); mqueue2.pop();
            pNode->left = mqueue.front(); mqueue.pop();
            if( mqueue.empty() ) break;
            pNode->right = mqueue.front(); mqueue.pop();
            if( pNode->left ) mqueue2.push( pNode->left );
            if( pNode->right ) mqueue2.push( pNode->right );
        }

        return root;
    }
};
</code></pre>
<p>Runtime: 48 ms</p>

<h3><a name="326" class="anchor" href="#326"></a>#326 Power of Three (Medium)</h3>
<p>1162261467 can be divided by power of 3.</p>
<pre><code>class Solution {
public:
    bool isPowerOfThree(int n) {
        return n > 0 && 1162261467 % n == 0;
    }
};
</code></pre>
<p>Runtime: 124 ms</p>

<h3><a name="" class="anchor" href="#"></a># (Medium)</h3>
<p></p>
<pre><code>
</code></pre>
<p>Runtime: 0 ms</p>

<h3><a name="" class="anchor" href="#"></a># (Medium)</h3>
<p></p>
<pre><code>
</code></pre>
<p>Runtime: 0 ms</p>

<h3><a name="" class="anchor" href="#"></a># (Medium)</h3>
<p></p>
<pre><code>
</code></pre>
<p>Runtime: 0 ms</p>

<h3><a name="" class="anchor" href="#"></a># (Medium)</h3>
<p></p>
<pre><code>
</code></pre>
<p>Runtime: 0 ms</p>

<h3><a name="" class="anchor" href="#"></a># (Medium)</h3>
<p></p>
<pre><code>
</code></pre>
<p>Runtime: 0 ms</p>

    </section>
   </div>

   <!-- FOOTER  -->
   <div id="footer_wrap" class="outer">
    <footer class="inner">
      <p class="copyright">Liang's LeetCode Solutions maintained by <a href="https://github.com/itoupeter">itoupeter</a></p>
      <p>Published with <a href="http://pages.github.com">GitHub Pages</a></p>
    </footer>
   </div>



  </body>
</html>
